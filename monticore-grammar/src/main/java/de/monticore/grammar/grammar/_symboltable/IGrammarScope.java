/* (c) https://github.com/MontiCore/monticore */
/* generated by template symboltable.ScopeInterface*/

package de.monticore.grammar.grammar._symboltable;

import de.monticore.grammar.MCGrammarSymbolTableHelper;
import de.monticore.symboltable.modifiers.AccessModifier;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION;
import static java.util.Optional.empty;

public interface IGrammarScope extends IGrammarScopeTOP {

  // all resolveImported Methods for ProdSymbol
  default public Optional<ProdSymbol> resolveProdImported(String name, AccessModifier modifier) {
    Optional<ProdSymbol> s = this.resolveProdLocally(name);
    if (s.isPresent()) {
      return s;
    }
    return resolveInSuperGrammars(name, modifier);
  }


  default public List<ProdSymbol> resolveProdMany(boolean foundSymbols, String name, AccessModifier modifier, Predicate<ProdSymbol> predicate)  {
    if (!isProdSymbolsAlreadyResolved()) {
      setProdSymbolsAlreadyResolved(true);
    } else {
      return new ArrayList<>();
    }

    final List<ProdSymbol> resolvedSymbols = this.resolveProdLocallyMany(foundSymbols, name, modifier, predicate);
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }

    resolveInSuperGrammars(name, modifier).ifPresent(resolvedSymbols::add);
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }

    resolvedSymbols.addAll(resolveAdaptedProdLocallyMany(foundSymbols, name, modifier, predicate));
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }
    final Collection<ProdSymbol> resolvedFromEnclosing = continueProdWithEnclosingScope((foundSymbols | !resolvedSymbols.isEmpty()), name, modifier, predicate);
    resolvedSymbols.addAll(resolvedFromEnclosing);
    setProdSymbolsAlreadyResolved(false);
    return resolvedSymbols;
  }

  default Optional<ProdSymbol> resolveInSuperGrammars(String name,  AccessModifier modifier) {
    Optional<ProdSymbol> resolvedSymbol = empty();
    Optional<MCGrammarSymbol> spanningSymbol = MCGrammarSymbolTableHelper.getMCGrammarSymbol(this);
    if (spanningSymbol.isPresent()) {
      MCGrammarSymbol grammarSymbol = spanningSymbol.get();
      for (MCGrammarSymbolSurrogate superGrammarRef : grammarSymbol.getSuperGrammars()) {
        final MCGrammarSymbol superGrammar = superGrammarRef.lazyLoadDelegate();
        resolvedSymbol = resolveInSuperGrammar(name, superGrammar);
        // Stop as soon as symbol is found in a super grammar.
        if (resolvedSymbol.isPresent()) {
          break;
        }
      }
    }
    return resolvedSymbol;
  }

  default Optional<ProdSymbol> resolveInSuperGrammar(String name, MCGrammarSymbol superGrammar) {
    return superGrammar.getSpannedScope().resolveProdImported(name, ALL_INCLUSION);
  }

  default boolean isQualified(MCGrammarSymbolSurrogate grammarRef) {
    if (grammarRef.getName().contains(".")) {
      return true;
    }
    MCGrammarSymbol grammarSymbol = grammarRef.lazyLoadDelegate();
    if (!grammarSymbol.getFullName().contains(".")) {
      // The complete name has no package name, therefore the grammarRefName
      // without "." is qualified
      return true;
    }

    return false;
  }

  default boolean isQualified(String name) {
    if (name.contains(".")) {
      return true;
    }
    return false;
  }

  default List<AdditionalAttributeSymbol> getAstAttributeList () {
    return getLocalAdditionalAttributeSymbols().stream().filter(a -> a.isAstAttr).collect(Collectors.toList());
  }

  default List<AdditionalAttributeSymbol> getSymbolAttributeList () {
    return getLocalAdditionalAttributeSymbols().stream().filter(a -> !a.isAstAttr).collect(Collectors.toList());
  }

}

