/* (c) https://github.com/MontiCore/monticore */
/* generated by template symboltable.ScopeInterface*/

package de.monticore.grammar.grammar._symboltable;

import de.monticore.codegen.mc2cd.MCGrammarSymbolTableHelper;
import de.monticore.symboltable.modifiers.AccessModifier;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

import static de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION;
import static de.se_rwth.commons.Names.getSimpleName;
import static java.util.Optional.empty;

public interface IGrammarScope extends IGrammarScopeTOP {

  // all resolveImported Methods for ProdSymbol
  default public Optional<ProdSymbol> resolveProdImported(String name, AccessModifier modifier) {
    Optional<ProdSymbol> s = this.resolveProdLocally(name);
    if (s.isPresent()) {
      return s;
    }
    return resolveInSuperGrammars(name, modifier);
  }


  default public List<ProdSymbol> resolveProdMany(boolean foundSymbols, String name, AccessModifier modifier, Predicate<ProdSymbol> predicate)  {
    if (!isProdSymbolsAlreadyResolved()) {
      setProdSymbolsAlreadyResolved(true);
    } else {
      return new ArrayList<>();
    }

    final List<ProdSymbol> resolvedSymbols = this.resolveProdLocallyMany(foundSymbols, name, modifier, predicate);
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }

    resolveInSuperGrammars(name, modifier).ifPresent(resolvedSymbols::add);
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }

    resolvedSymbols.addAll(resolveAdaptedProdLocallyMany(foundSymbols, name, modifier, predicate));
    if (!resolvedSymbols.isEmpty()) {
      setProdSymbolsAlreadyResolved(false);
      return resolvedSymbols;
    }
    final Collection<ProdSymbol> resolvedFromEnclosing = continueProdWithEnclosingScope((foundSymbols | resolvedSymbols.size() > 0), name, modifier, predicate);
    resolvedSymbols.addAll(resolvedFromEnclosing);
    setProdSymbolsAlreadyResolved(false);
    return resolvedSymbols;
  }

  default Optional<ProdSymbol> resolveInSuperGrammars(String name,  AccessModifier modifier) {
    Optional<ProdSymbol> resolvedSymbol = empty();

    // TODO (GV, MB)
    // Die Methode muss Ã¼berarbeitet werden. GrammarSymbols sollen nicht gefunden werden? Dann braucht man u.U.
    // checkIfContinueWithSuperGrammar gar nicht mehr ...
    Optional<MCGrammarSymbol> spanningSymbol = MCGrammarSymbolTableHelper.getMCGrammarSymbol(this);
    if (spanningSymbol.isPresent()) {
      MCGrammarSymbol grammarSymbol = spanningSymbol.get();
      for (MCGrammarSymbolLoader superGrammarRef : grammarSymbol.getSuperGrammars()) {
        if ((superGrammarRef.isSymbolLoaded())) {
          final MCGrammarSymbol superGrammar = superGrammarRef.getLoadedSymbol();
          resolvedSymbol = resolveInSuperGrammar(name, superGrammar);
          // Stop as soon as symbol is found in a super grammar.
          if (resolvedSymbol.isPresent()) {
            break;
          }
        }
      }
    }
    return resolvedSymbol;
  }

  default Optional<ProdSymbol> resolveInSuperGrammar(String name, MCGrammarSymbol superGrammar) {
    return superGrammar.getSpannedScope().resolveProdImported(name, ALL_INCLUSION);
  }

  default boolean isQualified(MCGrammarSymbolLoader grammarRef) {
    if (grammarRef.getName().contains(".")) {
      return true;
    }
    if (grammarRef.isSymbolLoaded()) {
      MCGrammarSymbol grammarSymbol = grammarRef.getLoadedSymbol();
      if (!grammarSymbol.getFullName().contains(".")) {
        // The complete name has no package name, therefore the grammarRefName
        // without "." is qualified
        return true;
      }
    }
    return false;
  }

  default boolean isQualified(String name) {
    if (name.contains(".")) {
      return true;
    }
    return false;
  }

}

