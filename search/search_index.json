{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p></p>"},{"location":"#monticore-language-workbench-and-development-tool-framework","title":"MontiCore - Language Workbench and Development Tool Framework","text":"<p>NEWS:</p> <ul> <li>ISW Stuttgart and RWTH Aachen organize the third MontiCore Symposium 2025 March 23 - March 26 in Gem\u00fcnd, Germany</li> <li>Deadline for submission of papers or abstracts: January, 10th.</li> </ul> <p>MontiCore is a language workbench for the efficient  development of domain-specific languages (DSLs). It processes an extended  grammar format which defines the DSL and generates Java components for processing  the DSL documents. Examples for these components are parsers,  AST classes, symboltables or pretty printers. This enables a user to rapidly define a language and use it together  with the MontiCore-framework to build domain-specific tools. </p> <p>Some MontiCore advantages are the reusability of predefined language  components, conservative extension and composition mechanisms, and an  optimal integration of handwritten code into the generated tools. Its  grammar languages are comfortable to use. </p> <p>Start here for developing with MontiCore.</p> [HKR21] Katrin H\u00f6lldobler, Oliver Kautz, Bernhard Rumpe:        MontiCore Language Workbench and Library Handbook: Edition 2021.        Shaker, 2021.  <p></p>"},{"location":"#a-teaser-for-monticore","title":"A Teaser for MontiCore","text":"<p>To show a little of MontiCore's capabilities, the following (incomplete)  grammar might help:</p> <pre><code>grammar MyStatemachine extends Automata,                  // MontiCore grammar \n                               MCBasicTypes, SetExpressions, MCCommonLiterals {     \n  start Automaton;\n\n  // overriding a nonterminal (to add optional conditions):\n  Transition = from:Name@State \":\" Expression? \"-&gt;\" to:Name@State;\n\n  // add new variants of expressions\n  LogicalNotExpr implements Expression = \"!\" Expression;\n\n  XorExpr        implements Expression =\n        left:Expression \"xor\" right:Expression;\n\n  scope LetExpr  implements Expression =\n        \"let\" (VarDeclaration || \",\")+ \"in\" Expression;\n\n  symbol VarDeclaration = MCType? Name \"=\" Expression ;\n}\n</code></pre> <p>The grammar language has a variety of mechanisms to define new nonterminals using constants <code>\"!\"</code>,  brackets <code>(..)</code>, optionals <code>?</code>, lists <code>*</code>, repetitions <code>(..||..)+</code>, etc.  The grammar builds an extended version of Statemachines reusing existing grammar components, here <code>Automata</code>, <code>MCBasicTypes</code>, <code>SetExpressions</code> and <code>MCCommonLiterals</code>. The grammar has 5 productions introducing 4 new nonterminals and overrides <code>Transition</code>, which is inherited from <code>Automata</code>. <code>Transition</code> additionally has an optional <code>Expression?</code> as firing condition. <code>LogicalNotExpr</code>, <code>XorExpr</code>, and <code>LetExpr</code> extend the already existing <code>Expression</code> nonterminal and add new forms of expressions.</p> <p><code>LetExpr</code> introduces a new local variable, which is visible only in that scope (indicated by keyword). <code>VarDeclaration</code> defines the new place to define symbols (that have a <code>Name</code>). There is an extensive infrastructure to manage the definition of names, visibility, etc.</p> <p>MontiCore compiles the above grammar  into <code>78</code> classes with in  total <code>18629</code> lines of code that define the complete frontend and a larger part of the backend of a statemachine processor. We now can write statemachines like:</p> <pre><code>statemachine PingPong {                                         // MyStatemachine\n  state Ping, Pong;\n  Ping : (speed &gt; 14km/h &amp;&amp; !missedBall) -&gt; Pong\n}\n</code></pre> <p>MontiCore provides versions of expressions that use SI Units like <code>240km/h</code> or <code>14.2 m/s^2</code>, but also Java  expressions like <code>2_000_000</code> and other variants including appropriate type checks. We include these forms of expressions by importing their grammars.</p> <p>Please note that in both cases (extension and overwriting existing nonterminals), we do not  touch nor copy/paste the predefined grammars, but achieve an out-of-the-box reuse. Out-of-the-box reuse also includes reuse of predefined typechecks, code generation, etc.  They only need to be extended to the added variants. Please also note that <code>PlusExpr</code> is mutually left-recursive. -- Yes, that works in MontiCore 6.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>$ cd /usr/local\n$ wget www.monticore.de/download/aut.tar.gz\n$ tar -xf aut.tar.gz\n$ cd mc-workspace\n$ wget www.monticore.de/download/monticore-cli.jar\n$ java -jar monticore-cli.jar -g Automata.mc4 -hcp hwc/ -mp monticore-cli.jar\n$ javac -cp monticore-cli.jar -sourcepath \"src/;out/;hwc/\" src/automata/AutomataTool.java\n$ java -cp \"src/;out/;hwc/;monticore-cli.jar\" automata.AutomataTool example/PingPong.aut PingPong.autsym\n</code></pre>"},{"location":"#monticore-has-a-relaxed-3-level-license","title":"MontiCore has a Relaxed 3-Level License","text":"<p>Informal summary:  The MontiCore Language Workbench deals with three levels of code  (MontiCore LWB, tool derivates, product code). Each has its own licenses:  (1) Product code generated by a MontiCore tool derivate  is absolutely free for each form of use  including commercial use without any license restriction.  (2) Tool derivates created using the MontiCore language  workbench mention that it is built using MontiCore. There is  no other restriction. (BSD 3 Clause license)  (3) Adaptations of the MontiCore language workbench itself should mention MontiCore and results are published back into the MontiCore repository (LGPL license) -- for other purposes an individual Dual License is available.</p> <p>For details see Licenses.</p>"},{"location":"#more-information-about-monticore","title":"More Information about MontiCore","text":"<ul> <li> <p>MontiCore handbook.    The handbook describes how to use MontiCore as an out-of-the-box     language workbench, but also as grey box tooling framework.    It thus also gives an overview over a number of core mechanisms of MontiCore.</p> </li> <li> <p>List of core grammars.    MontiCore concentrates on reuse. It therefore offers a set of    predefined language components, usually identified through an appropriate     component grammar allowing to define your own language as a    composition of reusable assets efficiently. reusable assets are among others:     several sets of literals, expressions, types, and statements,     which are freely composable.</p> </li> <li> <p>List of languages.    This is a list of languages that can be used out of the box. Some of them    are in development, others rather stable. Several of these languages    are inspired by the UML/P (see [Rum16,Rum17]).    These complete languages are usually composed of a number of language    components.</p> </li> <li> <p>This project is freely available software; you can redistribute    the MontiCore language workbench according to the rules described   in the licensing section.</p> </li> <li> <p>Contributing to MontiCore: MontiCore is originally developed by the    Software Engineering group at RWTH.    Meanwhile, it is maintained by several groups and individual persons.    If you want to contribute to MontiCore, please create a    fork    and issue corresponding pull requests.    The RWTH and the Stuttgart development teams will review and merge changes.    (A more open process for common development is currently in discussion and    depends on interests from further people/groups.)   You may also ask to become a member of the project.</p> </li> <li> <p>If questions appear e.g. on building an interpreter, please contact    monticore@se-rwth.de. </p> </li> </ul>"},{"location":"#further-information","title":"Further Information","text":"<ul> <li>see also MontiCore handbook</li> <li>MontiCore Reference Languages - Languages Built Using MontiCore</li> <li>Build MontiCore - How to Build MontiCore</li> <li>Getting Started - How to start using MontiCore</li> <li>Changelog - Release Notes</li> <li>FAQ - FAQ </li> <li>Licenses - MontiCore 3-Level License</li> <li>Project root: MontiCore @github</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/","title":"Changelog","text":""},{"location":"00.org/Explanations/CHANGELOG/#release-notes","title":"Release Notes","text":""},{"location":"00.org/Explanations/CHANGELOG/#monticore-770","title":"MontiCore 7.7.0","text":"<p>released: 20.01.2025</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions","title":"Additions","text":"<ul> <li>grammars</li> <li>SIUnits, SIUnitLiterals, SIUnitTypes4Math, SIUnitTypes4Computing     (ported from SIUnit project)</li> <li>TypeParameters for generics</li> <li>Stream constructor for StreamExpressions</li> <li>Symbols</li> <li>DeSer has access to outer scope while deserializing</li> <li>CoCos</li> <li>new CoCo QualifiedTypeHasNoTypeParameters</li> <li>new CoCo TypeParameterNoCyclicInheritance</li> <li>new CoCo TypeParametersHaveUniqueNames</li> <li>TypeCheck</li> <li>initial support for generics/type inference</li> <li>TypeCheck3 static delegate with implementation MapBasedTypeCheck3</li> <li>new class SymTypeOf(NumericWith)SIUnit</li> <li>new class SymTypeSourceInfo to reference symbols</li> <li>new class SymTypeCollectionVisitor to collect sub-SymTypeExpressions</li> <li>new class SymTypeExpressionCalculator to sort SymTypeExpressions</li> <li>new class SymTypePredicateVisitor to check predicates over STEs</li> <li>new class TypeVisitorOperatorCalculator to reuse operator calculations</li> <li>Tests</li> <li>Junit 5.10.3 for tests and parametrization</li> <li>Templates</li> <li>introduced scopes for template inclusion</li> <li>CD2Java support for Javadocs</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes","title":"Changes","text":"<ul> <li>grammars</li> <li>JavaLight uses TypeParameters</li> <li>updated MLC models</li> <li>AST</li> <li>deprecated definingSymbol (TypeCheck1)</li> <li>CoCos</li> <li>LiteralAssignmentMatchesRegExExpressionCoCo uses TypeCheck3</li> <li>ExpressionStatementIsValid uses TypeCheck3</li> <li>VarDeclarationInitializationHasCorrectType uses TypeCheck3</li> <li>Updated Gradle version to 7.6.4</li> <li>Pretty Printers</li> <li>Removed (deprecated) handwritten pretty printers</li> <li>Replaced handwritten usage of pretty printers with the generated printers </li> <li>Logger has changed to a log-hook based logging infrastructure</li> <li>Reporting</li> <li>Removed reporting of unused templates</li> <li>Adapted reporting to the new Logger</li> <li>TypeCheck</li> <li>deprecated IDerive/ISynthesize</li> <li>deprecated TypeCheckResult</li> <li>deprecated ITypeCalculator</li> <li>better error messages</li> <li>Parser</li> <li>Further improved readability of parse errors</li> <li>Refactored the parser generation to increase readability</li> <li>Usage of a two-phased parser approach (using ParseVisitors to create the AST)</li> <li>Updated the Getting Started document</li> <li>The development of MontiCore now occurs on GitHub</li> <li>Exposition of internal objects of the DSTL-transformation generation </li> <li>GlobalExtensionManagement: extend template replacement</li> <li>monticore-generator</li> <li>Removed GrammarFamily</li> <li>Removed dependencies to bootstrap-jars</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>Symbols</li> <li>Deserialization uses outer scope</li> <li>MCPath don't throw PatternSyntaxException</li> <li>Pretty Printer generation of constant groups with usage names</li> <li>Memory exhaustion of the Gradle plugin</li> <li>compatibility with Gradle's build and configuration cache</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-760","title":"MontiCore 7.6.0","text":"<p>released: --to be determined--</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_1","title":"Additions","text":"<ul> <li>template replacement: addBefore &amp; addAfter </li> <li>CoCo ensuring only lvalues are valid values for assignments</li> <li>new grammars:</li> <li>CompSymbols for C&amp;C symbol interfaces</li> <li>RegularExpressions (ported from RegEx project)</li> <li>RegExType (ported from RegEx project)</li> <li>UglyExpressions to move reflection based expressions to and 'new'</li> <li>OCLExpressions (ported from OCL project)</li> <li>OptionalOperators (ported from OCL project)</li> <li>SetExpressions (ported from OCL project)</li> <li>a generated toString() method for symbols</li> <li>grammar options ParserSuperClass and LexerSuperClass to influence ANTLR</li> <li>CoCo to forbid non-unique production names in composed grammars (A0144)</li> <li>new gradle plugin docs</li> <li>domain-specific tagging models:</li> <li>new grammar Tags, to describe tags of symbols </li> <li>new grammar TagSchema</li> <li>generate a language-specific Tagger class as an API to tags</li> <li>derive a language-specific TagSchema grammar, to describe the set of allowed tags for a symbol kind</li> <li>new TagRepository class to facilitate loading of tag models</li> <li>Scopes:</li> <li>methods to check whether a scope is a sub-scope of another</li> <li>method to check whether a type variable is bound in a given context</li> <li>method for shallow copying of AccessModifiers</li> <li>added initializeString to BasicSymbolsMill</li> <li>PrettyPrinter:</li> <li>OCLExpressions</li> <li>SetExpressions</li> <li>TypeCheck:</li> <li>Added SymTypeOfRegEx</li> <li>Added TypeVisitor classes which calculate the type of ASTNodes</li> <li>Added NameExpressionTypeCalculator to calculate the type given a Name<ul> <li>Added OONameExpressionCalculator to filter out constructors</li> </ul> </li> <li>Added OOWithinTypeBasicSymbolsResolver to filter out constructors</li> <li>Added Type4Ast map to TypeVisitors to store type results</li> <li>Added MCCollectionTypeRelations to check relations on collection types</li> <li>Added MCCollectionSymTypeFactory convenience methods to create collections</li> <li>upper and lower bound for type variables</li> <li>Added ILValueRelations to check if an expression is a l-value<ul> <li>Added CommonExpressionsLValueRelations as implementation</li> </ul> </li> <li>Added NominalSuperTypeCalculator to calculate nominal supertypes<ul> <li>can calculate them for object types,   as well as structural types and variables</li> </ul> </li> <li>Added Wrapper to support the legacy interface using TypeCheck 3</li> <li>Added method to clone SymTypeArray with different dimension</li> <li>Added the possibility to use the type identifier as constructor</li> <li>Added methods asX for SymTypeX to avoid casting</li> <li>Added TypeSystem3 markdown documentation</li> <li>Expressions:</li> <li>ASTRule: LambdaBodys have a return type</li> <li>Model Interpreters:</li> <li>General runtime infrastructure</li> <li>Generative support for compositional interpreters</li> <li>Interpreter library for:<ul> <li>Assignment expressions</li> <li>Common expressions</li> <li>Common Literals</li> </ul> </li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_1","title":"Changes","text":"<ul> <li>Findings of parse errors now contain additional context</li> <li>attribute isAbstract was moved from JavaMethodSymbol to MethodSymbol</li> <li>delete class MapUtil (replaced by Guava)</li> <li>delete deprecated class CoreTemplates</li> <li>report templates with qualified name</li> <li>severely refactored fieldAccessExpression TypeCalculation</li> <li>renamed TypeCheck 2 to 3</li> <li>updated ecj dependency</li> <li>removed ExtType extension points in grammars</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_1","title":"Fixes","text":"<ul> <li>generated pretty printer behavior for end of lines with single line comments</li> <li>cache misses during resolution of fully qualified named in MCPath </li> <li>multiple alternatives in an expression are now supported by the DSTLGen (0xA5C05)</li> <li>improved groovy workflow script setup time</li> <li>fix code blocks for alternatives in interfaces (ANTLR)</li> <li>delegate accect-methods in SymbolSurrogate</li> <li>ForConditionHasBooleanType removed incorrect casting</li> <li>fix StreamType SymType-Library instantiation</li> <li>corrected TypeVarSymbol deepEquals</li> <li>replaced some error codes that were used more than once</li> <li>asserts the existence of String symbol if required by the TypeCheck</li> <li>subTyping of generics is now a recursive check</li> <li>in TypeCheck 3 added workarounds for faulty symbol resolving</li> <li>in TypeCheck 3 added workarounds for faulty TypeDispatcher</li> <li>added null-pointer checks</li> <li>Fix TypeVar deepclone</li> <li>Remove CoCo that forbid token modes in component grammars</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-750","title":"MontiCore 7.5.0","text":"<p>released: 02.05.2023</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_2","title":"Additions","text":"<ul> <li>type dispatcher for type-safe instance checks and casting</li> <li>pretty-printer generator</li> <li>parser generator produces code for the new rule \"replcaekeyword\"</li> <li>new coco NoForbiddenProdName</li> <li>TOP mechanism for generated ANTLr parser classes</li> <li>add class StreamType which can be used to add Stream symbol with corresponding functions to the global scope</li> <li>Additions to AccessModifiers</li> <li>add class StaticAccessModifier to filter whether a symbol is considered as static or not.</li> <li>add class WriteableAccessModifier to filter whether a symbol is considered as writable or not.</li> <li>add class CompoundAccessModifier to compose multiple access modifier, e.g. public + static</li> <li>Additions to the TypeCheck</li> <li>add new class TypeRelations to provide typecheck methods in a non static fashion. The TypeCheck class now delegates to the implementation</li> <li>add new class SymTypeOfUnion to store the type of a union of types</li> <li>add new class SymTypeOfIntersection to store the type of an intersection of types</li> <li>add new interface ISymTypeVisitor to traverse SymTypeExpressions</li> <li>add new class SymTypeDeepCloneVisitor to clone SymTypeExpressions</li> <li>add new class SymTypeBoxingVisitor to box SymTypeExpressions. This implemenation fixes issues over the methods within the SymTypeExpression classes</li> <li>add new class SymTypeUnboxingVisitor to unbox SymTypeExpressions. This implemenation fixes issues over the methods within the SymTypeExpression classes</li> <li>add new class SymTypeNormalizeVisitor to normalize SymTypeExpressions. This is required to check for compatibility between SymTypeExpressions, especially regarding union and intersection types</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_2","title":"Changes","text":"<ul> <li>Gradle projects containing multiple MCTasks can now use parallel builds</li> <li>The MontiCore Gradle Plugin ensures that MCTasks are not run in parallel, other tasks, like compile, are run in parallel</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_2","title":"Fixes","text":"<ul> <li>parser generation for optional keywords with usage name</li> <li>Overriding/Imlementing use of lexical productions</li> <li>in OOScopes, accessmodifier can be used to filter symbols</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-740","title":"MontiCore 7.4.0","text":"<p>released: 14.11.2022</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_3","title":"Additions","text":"<ul> <li>new grammar rule replacekeyword</li> <li>add attribute derived to FieldSymbol</li> <li>generate XParserInfo</li> <li>Used by generated language servers</li> <li>Can be queried for additional info about specific parser states of the generated ANTLR parser</li> <li>Contains methods stateHasUsageNameY to check the usage name of the nonterminal associated with a parser state</li> <li>Contains methods stateReferencesZSymbol to check the referenced symbol kind of <code>Name</code> nonterminal associated with a parser state</li> <li>Additions to the TypeCheck</li> <li>add new abstract classes AbstractDerive and AbstractSynthesize with basic functionality for FullDerivers and FullSynthesizers</li> <li>add new class TypeCalculator that can be used to derive SymTypeExpressions from Expressions and synthesize them from types</li> <li>add SymTypeObscure: new SymTypeExpression that is used when the SymTypeExpression for an expression could not be derived</li> <li>add SymTypeFunction to store the type of a function</li> <li>add the functionality for Function chaining, allowing to call functions returned by other functions</li> <li>add varargs support for CallExpressions</li> <li>add deriver for LambdaExpressions</li> <li>Add grammar MCFunctionTypes to write the type of a function in a model</li> <li>Add ExpressionStatementIsValid CoCo</li> <li>Add grammars LambdaExpressions and StreamExpressions</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_3","title":"Changes","text":"<ul> <li>Java 11</li> <li>Gradle 7 compatibility</li> <li>delete deprecated method deepClone in ASTNodes</li> <li>use CDGenerator (cdanalysis)</li> <li>Visitor Pattern: Introduce state-based traversal of symbol table</li> <li>Allows for combined AST and symbol table traversal from global and artifact scopes</li> <li>Comes with integrated stand-alone symbol table traversal</li> <li>TypeCheck Refactoring</li> <li>rename currentResult to result in TypeCheckResult</li> <li>split TypeCheck facade into TypeCalculator (used to derive SymTypeExpressions from Expressions and synthesize them from types) and TypeCheck (static functions that are useful when checking for type compatibility or for comparing SymTypeExpressions)</li> <li>rename SymTypeConstant to SymTypePrimitive</li> <li>Deriver now evaluate all subexpressions of an expression and do not stop at the first error</li> <li>do not log multiple errors for the same error: If an error occurs in the derivation of a subexpression and this error leads to another error in the derivation of the expression itself, do not log another error</li> <li>remove the name of CallExpression</li> <li>rework the calculation of CallExpression, NameExpression and FieldAccessExpression</li> <li>rework TypeCheck error messages to make them more clear</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_3","title":"Fixes","text":"<ul> <li>close all jars used to load models via MCPath</li> <li><code>gradle clean</code> should no longer fail because of dangling opened grammar jars</li> <li>TypeCheck</li> <li>fix an error in the WildCardTypeArgument where ? super and ? extends were swapped</li> <li>fix TypeCheck not logging an error for NameExpression and FieldAccessExpression in isolation</li> <li>make short compatible to byte</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-730","title":"MontiCore 7.3.0","text":"<p>released: 04.04.2022</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_4","title":"Additions","text":"<ul> <li>add cocos for lexical mode</li> <li>add coco for Expression</li> <li>add cocos for JavaLight</li> <li>new methods putSymbolDeSer, putXYSymbolDeSer and loadFileForModelNamed (GlobalScope Interface)</li> <li>new method getToken (MCParser)</li> <li>use CD4C in 02experiment.configTemplate</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_4","title":"Changes","text":"<ul> <li>rename generated classes <code>XYCLI</code> -&gt; <code>XYTool</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-720","title":"MontiCore 7.2.0","text":"<p>released: 13.09.2021</p>"},{"location":"00.org/Explanations/CHANGELOG/#changes_5","title":"Changes","text":"<ul> <li>Several modes can now be specified in a grammar (for further explanations see ANTLR). For the grammars, one file is now generated for lexer rules and one for the parser rules.</li> <li>delete deprecated classes:   <code>ModelPath</code>, <code>IterablePath</code>, <code>ModelCoordinate</code>, <code>ModelCoordinateImpl</code>, <code>ModelCoordinates</code>, and <code>FileFinder</code></li> <li>The symbol table now stores for productions whether a    production is left-recursive.</li> <li>In the log class the dependency to ch.qos.logback:logback-core was removed</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-710","title":"MontiCore 7.1.0","text":"<p>released: 05.07.2021</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_5","title":"Additions","text":"<ul> <li>introduced language-specific CLI generation</li> <li>New class <code>MCPath</code> that manages a set of path entries. The class is used, e.g., for realizing symbol paths, model paths, handcoded paths, and template paths. <code>MCPath</code> replaces the classes <code>IterablePath</code> and <code>ModelPath</code>.</li> <li>Different modes can now be defined for lexical tokens in grammar.   The corresponding generator will only be available in the next version.</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_6","title":"Changes","text":"<ul> <li>the methods <code>serialize</code> and <code>deserialize</code> of the class <code>XDeSer</code> were moved to the class <code>XSymbols2Json</code></li> <li>The following classes are marked as deprecated and will be removed in the near future:  <code>ModelPath</code>, <code>IterablePath</code>, <code>ModelCoordinate</code>, <code>ModelCoordinateImpl</code>, <code>ModelCoordinates</code>, and <code>FileFinder</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_4","title":"Fixes","text":""},{"location":"00.org/Explanations/CHANGELOG/#monticore-700","title":"MontiCore 7.0.0","text":"<p>released: 08.04.2021 </p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_6","title":"Additions","text":"<ul> <li>resolveXSubKinds(..) resolves for local symbols of all subkinds of a symbol kind X. This method is used   by the implementation of the resolveXLocally(..) method. It enables proper handling of symbol kind hierarchies   during symbol resolution beyond the borders of a language.</li> <li>new annotation @NonConservative for productions</li> <li>add configTemplate (-cf) mechanism to add a freemarker template for customizing the generation processed</li> <li>add two predefined groovy hook points (-gh1 and -gh2) in the monticore_standard.groovy for injecting    custom groovy scripts into the workflow</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_7","title":"Changes","text":"<ul> <li>move grammars OCLExpressions and SetExpressions into OCL-project for further development</li> <li>DefsTypeBasic was moved to test. There are now only methods for creating symbols.   Use the BasicSymbolsMill to create the basic data types like int, ...</li> <li><code>deserialize(String)</code> method of scope DeSer classes is realized as default implementation in <code>IDeSer</code> interface</li> <li><code>deserialize(String)</code> method of symbol DeSer classes is realized as default implementation in <code>ISymbolDeSer</code> interface</li> <li><code>deserializeAddons()</code> and <code>serializeAddons()</code> methods  of scopes are realized as empty default implementation in <code>IDeSer</code> interface</li> <li>If deserialization encounters a symbol kind for which no DeSer is contained in the symbol Deser map in global scopes, a warning is produced instead of an error</li> <li>Boolean <code>isShadowing</code> property of scopes is only serialized if its value is \"true\". Deserialization assumes a default value of \"false\" if the property is not contained in a serialized scope</li> <li><code>deserialize(String)</code> method of symbol DeSers do not produce errors if the serialized kind deviates from the symbol kind that the DeSer is originally engineered for</li> <li>The TypeCheck was reworked</li> <li>The interface <code>ITypesCalculator</code> was renamed to <code>IDerive</code> and can now be used similar to the <code>ISynthesize</code> interface</li> <li>no SymbolSurrogates are created anymore by the TypeCheck. The Synthesize-Classes will now log an error if a type cannot be resolved</li> <li>SymTypeExpressions now have the method printFullName to print their full name</li> <li>The class <code>TypeCheck</code> now needs one <code>IDerive</code> and one <code>ISynthesize</code> for its constructor instead of only one of them</li> <li>The class <code>DeriveSymTypeOfBSCommonExpressions</code>, which does not pay attention to modifiers like <code>static</code> or <code>private</code>, can now be used as an alternative for the class <code>DeriveSymTypeOfCommonExpressions</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_5","title":"Fixes","text":"<ul> <li>Symbols with hierarchical symbol kinds are not serialized multiple times anymore.</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-670","title":"MontiCore 6.7.0","text":"<p>released: 26.01.2021</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_7","title":"Additions","text":"<ul> <li>Add new CLI for the MontiCore generator engine</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_8","title":"Changes","text":"<ul> <li>The context conditions use the new traverser infrastructure. This leads to small changes in the api.   The return value of the method addCoCo is void.</li> <li>Attribute fileExt in GlobalScopes now refers to a regular expression for file extensions of    symbol table files. The default value of the attribute is \"*sym\", which usually includes symbol    files of all MontiCore languages. Attention: If your language used the \"setFileExt\" method in   previous versions of MontiCore to set the file extension of the model file (e.g., to \"aut\"), this    will cause problems now as the symbol files of the language have differen file extensions    (e.g., \"autsym). To fix this, it is sufficient to remove all invocations of \"setFileExt\" from the    handwritten source code.</li> <li>For scopes, artifact scopes, and global scopes: Moved abstract methods that do not have a language-   specific name or (argument, return) type from language-specific interface to MontiCore-runtime interfaces</li> <li>new experiment \"strules\" demonstrating the use of symbolrules and scoperules</li> <li><code>deserialize</code> methods in SymTypeExpressionDeSers do not have an <code>enclosingScope</code> argument anymore.   Internally, it uses the singleton global scope instead. </li> <li>renamed <code>serializeAdditionalSSymbolAttributes</code> in <code>Symbols2Json</code> class to <code>serializeAddons</code> and moved   to scope and symbol DeSers.</li> <li><code>XScopeDeSer</code> is renamed to <code>XDeSer</code></li> <li>In Symbols2Json classes:</li> <li>now implementss Visitor2 </li> <li>new attribute \"XTraverser traverser\" with getter and setter</li> <li>Removed attribute \"realThis\" with getter and setter</li> <li>New constructor with two arguments <code>XTraverser</code> and <code>JsonPrinter</code></li> <li>New zero args constructor</li> <li>Removed constructor with single <code>JsonPrinter</code> argument</li> <li>New attributes of all known symbol DeSers and current scope DeSers</li> <li>New method \"protected void init()\", initializing the DeSer attributes with the GlobalScope     and the traverser with symbols2json of inherited languages</li> <li>adjusted store method to use traverser</li> <li>visit methods for symbols delegate to serialize method of the symbol DeSer</li> <li>visit and endVisit methods for scope interface and artifact scope interface print object stub       and delegate serialization to scope DeSers</li> <li>DeSers do not have an attribute of Symbols2Json class anymore, instead it is passed as argument    in the <code>serialize</code> methods </li> <li>Default values of built-in types that occur in attributes of symbolrules or scoperules are    omitted during serialization and deserialization. The defaults are as follows:</li> <li>Boolean : false</li> <li>String : \"\"</li> <li>Numeric types: 0 (and 0L and 0.0 and 0.0f)</li> <li>For symbolrule and scoperule attributes with non-built-in data type, no Log.error is thrown   at execution time of the serialize method call anymore. Instead, these methods (and then, their    classes as well) are generated abstract to yield compilation errors instead.</li> <li>New interface <code>IDeSer</code> that all symbol and scope DeSers implement.</li> <li>GlobalScopes manage a map with all relevant DeSers. The map maps the serialized (symbol or scope)   kind to the DeSer that (de)serialized this kind. This mechanism can be used to exchange the DeSer   for a specific kind of symbol or scope.</li> <li>Scope DeSers have new <code>serialize</code> methods without <code>Symbols2Json</code> argment that can be used for   for serializing (artifact) scopes for, e.g., unit tests </li> <li>removed the generation of <code>XPhasedSymbolTableCreatorDelegator</code> classes</li> <li>Experiments now use ScopesGenitor-infrastructure instead of SymbolTableCreator-infrastructure</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_6","title":"Fixes","text":"<ul> <li> <p>The <code>initMe</code> and <code>reset</code> methods of the mill now initialize and reset all attributes properly</p> </li> <li> <p>The CD4Analysis keywords <code>ordered</code>, <code>composition</code>, <code>association</code>, <code>targetimport</code> and <code>classdiagram</code>    can be used in grammars again</p> </li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-660","title":"MontiCore 6.6.0","text":"<p>released: 03.12.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_8","title":"Additions","text":"<ul> <li>The mill of a language now provides a method <code>parser()</code> to get the parser of the language <ul> <li>mill initialization allows to reconfigure the mill to provide a parser for a sublanguage</li> <li>parser delegator <code>XForYParser</code> are generated that extend a parser of a super language and delegate to the parser of the current language</li> <li>Due to multiple inheritance, delegation and subclasses are used in combination </li> </ul> </li> <li>experiments now showcase the use of traversers   </li> <li>add coco (checks if additional attributes are declared twice)</li> <li>added built-in primitive types to the mills of grammars that extend the grammar BasicSymbols. Add to Mill by executing <code>BasicSymbolsMill.initializePrimitives()</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_9","title":"Changes","text":"<ul> <li>The generated parser uses the builder instead of the factory. This means that in grammars the variable <code>_aNode</code> is no longer available. Use instead <code>_builder</code>. </li> <li>Multiple renamings and signature changes regarding the deser infrastructure</li> <li>renamed <code>XSymbolTablePrinter</code> to <code>XSymbols2Json</code></li> <li>moved load and store methods form <code>XScopeDeSer</code> to <code>XSymbols2Json</code></li> <li>removed enclosing scope as method argument of symbol deser methods, as global scope shall be used instead</li> <li>renamed <code>deserializeAdditionalSSymbolAttributes</code> to <code>deserializeAddons</code></li> <li>renamed <code>deserializeAdditionalXScopeAttributes</code> and <code>deserializeAdditionalXScopeAttributes</code> to <code>deserializeAddons</code></li> <li>added the JSON printer as a parameter to the methods of <code>XScopeDeSer</code>, <code>SSymbolDeSer</code> und <code>XSymbols2Json</code></li> <li><code>XScopeDeSer</code>, <code>SSymbolDeSer</code> und <code>XSymbols2Json</code> are no longer available via the mill. The constructors can be used instead.</li> <li>Scope builder have been removed as they did not support multiple inheritance, scope creation methods of the mill should be used instead</li> <li>Shortened the name of the scope creation methods in the mill from <code>xScope</code>, <code>xGlobalScope</code> and <code>xArtifactScope</code> to <code>scope</code>, <code>globalScope</code> and <code>artifactScope</code></li> <li>Shortened the name of the <code>modelFileExtension</code> attribute in the <code>XGlobalScope</code> class to <code>fileExt</code></li> <li>renamed <code>XScopeSkeletonCreator</code> and <code>XScopeSkeletonCreatorDelegator</code> to <code>XScopesGenitor</code> and <code>XScopesGenitorDelegator</code></li> <li>Deprecated the <code>XPhasedSymbolTableCreatorDelegator</code>, will be removed without replacement in a future release</li> <li>PrettyPrinters and other visitors in monticore-grammar now use the new Traverser infrastructure instead of the old Visitor infrastructure</li> <li>generated <code>XScopeGenitor</code> and <code>XScopeGenitorDelegator</code> now use the new Traverser infrastructure instead of the old Visitor infrastructure</li> <li>Changes to resolving</li> <li>if name of a topLevelSymbol in ArtifactScope = name of ArtifactScope: qualify symbols in spanned scopes of the topLevelSymbol like before with <code>&lt;topLevelSymbolName&gt;.&lt;symbolName&gt;</code></li> <li>if name of a topLevelSymbol in ArtifactScope != name of ArtifactScope: qualify symbols in spanned scope of the topLevelSymbol with <code>&lt;ArtifactScopeName&gt;.&lt;topLevelSymbolName&gt;.&lt;symbolName&gt;</code> </li> <li>Traverser now support lists of <code>Visitor2</code> interfaces instead of only one instance</li> <li>Rename accessor of Traverser from <code>addXVisitor</code> to <code>add4X</code> </li> <li>Methods returning referenced symbols save the symbols instead of the surroogates</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_7","title":"Fixes","text":"<ul> <li>Traverser now properly delegate to handlers as intended</li> <li>ScopeSkeletonCreator now properly use the mill to create scope instances to ensure substitution via the mill pattern</li> <li>Fixed a bug where the SymbolSurrogates wrongly qualified their fullName</li> <li>The clear method of the GlobalScope now deletes all symbols stored in the GlobalScope</li> <li>Serializing symbolrule attributes of Strings now works properly</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-660_1","title":"MontiCore 6.6.0","text":"<p>released: 11.11.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_9","title":"Additions","text":"<ul> <li>added an experiment <code>hwDeSers</code> showcasing serialization and deserialization</li> <li>added an experiment <code>hooks</code> showcasing hook point usage</li> <li>IncCheck provided by the MontiCore Gradle Plugin now considers local super grammar changes to trigger new generation</li> <li>Added new Traverser generation to replace the visitor infrastructure in a future release<ul> <li><code>XTraverser</code></li> <li><code>XTraverserImplementation</code></li> <li><code>XVisitor2</code></li> <li><code>XHandler</code></li> </ul> </li> <li>Added new ScopeSkeletonCreator generation to replace the SymbolTableCreator in a future release and to enable a phased symboltable creation<ul> <li><code>XScopeSkeletonCreator</code></li> <li><code>XScopeSkeletonCreatorDelegator</code></li> <li><code>XPhasedSymbolTableCreatorDelegator</code></li> </ul> </li> <li>Added methods to directly obtain instances of the following classes in the mill (instead of their builders)<ul> <li><code>XSymbolTableCreator</code> </li> <li><code>XSymbolTableCreatorDelegator</code> </li> <li><code>XScopeSkeletonCreator</code></li> <li><code>XScopeSkeletonCreatorDelegator</code></li> <li><code>XPhasedSymbolTableCreatorDelegator</code></li> <li><code>XScopeDeSer</code></li> <li><code>XSymbolDeSer</code> </li> <li><code>XSymbolTablePrinter</code></li> <li><code>IXScope</code></li> <li><code>IXArtifactScope</code></li> </ul> </li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_10","title":"Changes","text":"<ul> <li>MontiCore now uses Gradle as build tool</li> <li>some tasks have been introduced for the comfortable control of frequent activities, e.g., <code>buildMC</code>, <code>assembleMC</code> that can be found in the <code>build.gradle</code></li> <li>relocated the EMF related subprojects:<ul> <li><code>monticore-emf-grammar</code> to <code>monticore-grammar-emf</code></li> <li><code>monticore-emf-runtime</code> to <code>monticore-runtime-emf</code></li> </ul> </li> <li>relocated integration tests and experiments:<ul> <li><code>monticore-generator/it</code> to <code>monticore-test/it</code></li> <li><code>monticore-generator/it/experiments</code> to <code>monticore-test/01.experiments</code></li> <li><code>monticore-generator/it/02.experiments</code> to <code>monticore-test/02.experiments</code></li> <li><code>monticore-grammar/monticore-grammar-it</code> to <code>monticore-test/monticore-grammar-it</code></li> </ul> </li> <li>Remove the generation of <code>XModelloader</code>. Languages should now use <code>XScopeDeSer</code> to load symbol tables instead.</li> <li>Removed the generation of the following builder classes (also from the Mill; alternative solutions described below)<ul> <li><code>XSymbolTableCreatorBuilder</code> </li> <li><code>XSymbolTableCreatorDelegatorBuilder</code> </li> <li><code>XScopeDeSerBuilder</code></li> <li><code>XSymbolDeSerBuilder</code> </li> <li><code>XSymbolTablePrinterBuilder</code></li> </ul> </li> <li>renamed <code>IXResolvingDelegate</code> to <code>IXResolver</code></li> <li>outsourced Type expressions for arrays to a separate grammar</li> <li>was <code>FullGenericTypes</code>, is now <code>MCArrayTypes</code></li> <li>outsourced initialization for arrays to a separate grammar</li> <li>was <code>MCVarDeclarationStatements</code>, is now <code>MCArrayStatements</code></li> <li>In a composed language, mills of super languages now provide scope instances (scope, global scope and artifact scope) for the composed language</li> <li>non-existing template paths now result in an error instead of a warning</li> <li>Set current visitor infrastructure to deprecated</li> <li>Integrate new visitor infrastructure (i.e., traverser) into <code>XMill</code> to enable re-usability of visitors via language inheritance</li> <li>Set SymbolTableCreator, SymbolTableCreatorDelegator and their builder to deprecated</li> <li>Integrate new ScopeSkeletonCreator, ScopeSkeletonCreatorDelegator and PhasedSymbolTableCreatorDelegator into Mill</li> <li>Added a method <code>clear</code> to the GlobalScope that clears its cache and its resolvers and empties its ModelPath</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_8","title":"Fixes","text":"<ul> <li>Fixed that global variable changes in child templates were not changed in parents</li> <li>Fixed handling of optional names of symbols in symbol table creator </li> <li>Fixed an issue where surrogates hide symbol attributes</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-640","title":"MontiCore 6.4.0","text":"<p>released: 12.10.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_10","title":"Additions","text":"<ul> <li>extended the generated incCheck files to contain information about local super grammars<ul> <li>the sh-file is now able to trigger generation if local super grammars are changed</li> <li>the incCheck method provided by the plugin will support this behavior as well</li> <li>will only be available in the next release</li> </ul> </li> <li>extended the mill to manage the global scope instance centrally </li> <li>added comfort methods for creating modifiers to the <code>ModifierBuilder</code><ul> <li><code>ModifierBuilder().PUBLIC()</code> short for <code>ModifierBuilder().setPublic(true)</code></li> </ul> </li> <li>added <code>MCShadowingJavaBlock</code> to <code>MCCommonStatements</code><ul> <li>standard <code>MCJavaBlock</code> is no longer shadowing</li> </ul> </li> <li>added a class diagram to the reports that represents the generated data structure for the given grammar  (ast, symbol table visitors, etc.)</li> <li>added simple <code>BreakStatement</code> to <code>MCCommonStatements</code></li> <li>added an <code>include2</code> alias for the template controller method for including templates in conjunction with templates arguments</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_11","title":"Changes","text":"<ul> <li>CLI does no longer check whether a generation is needed (this should be handled by the build tool)</li> <li>rephrased messages for non-conservative extension (added super grammar name)</li> <li>added a context condition to prevent list of names in nonterminal production marked as symbols</li> <li>might be supported in a future version of MontiCore</li> <li>moved XForYMills to a subpackage to reduce noise (subpackage: _auxiliary)</li> <li>deprecated the generated enum f\u00fcr constants <ul> <li>will be removed without replacement in a future release</li> </ul> </li> <li>moved <code>EnhancedForControl</code> production from <code>JavaLight</code> to <code>MCCommonStatements</code> as it is commonly used </li> <li>standard <code>MCJavaBlock</code> is no longer shadowing</li> <li>renamed <code>BreakStatement</code> in <code>MCLowLevelStatements</code> to <code>LabelledBreakStatement</code></li> <li><code>ForStatement</code> now spans a non-exporting, ordered scope </li> <li>shortened generated error codes to have 5 digits only</li> <li>renamed <code>MethOrConstr</code> to <code>JavaMethod</code> in <code>JavaLight</code></li> <li>MontiCore Gradle plugin is no longer shipped as a fat jar</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_9","title":"Fixes","text":"<ul> <li>Fixed error code calculation for generated error messages to no longer be random</li> <li>Fixed the report for involved files to contain handwritten files that were considered <ul> <li>will only be available in the next release</li> </ul> </li> <li>Fixed an issue where reports did not contain meaningful names for elements such as class diagram classes or interfaces</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-630","title":"MontiCore 6.3.0","text":"<p>released: 16.09.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_11","title":"Additions","text":"<ul> <li>added <code>@Override</code> annotation for nonterminal production to state that this production overrides a super grammars' production</li> <li>overriding without annotation leads to a warning</li> <li>using the annotation for a production that does not override an existing nonterminal results in an error</li> <li>added a context condition to ensure that external production do not have ast rules </li> <li>added <code>DiagramSymbol</code> in <code>BasicSymbols</code></li> <li>introduced generated interfaces for <code>GlobalScope</code> and <code>ArtifactScope</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_12","title":"Changes","text":"<ul> <li>serialization of symtype expression now serializes full name of symtype instead of simple name</li> <li>class <code>ASTNodes</code> is now deprecated and its usages in the generator are removed</li> <li>visitors no longer provide visit methods for concrete scope classes but their interfaces instead</li> <li><code>SymTypeExpression</code> no longer use surrogates but <code>TypeSymbol</code>s instead</li> <li>reverted changes to appended <code>s</code> for list attributes made in previous release</li> <li>moved initialization of symbols to the <code>endVisit</code> method of the <code>SymbolTableCreator</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_10","title":"Fixes","text":"<ul> <li>Fixed missing sourcecode position for overriding warning</li> <li>Fixed an issue where the inheritance hierarchy was no considered correctly when overriding a nonterminal</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-620","title":"MontiCore 6.2.0","text":"<p>released: 21.07.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#additions_12","title":"Additions","text":"<ul> <li>added <code>isFinal</code> to <code>OOType</code> in <code>OOSymbols</code></li> <li>extended the mill such that builder for DeSer related classes are provided by the mill</li> <li>added support for symbol usages in <code>NonterminalSeperator</code><ul> <li>example: <code>Bar = (bla:Name@Foo || \",\" )+;</code></li> </ul> </li> <li>added reports for the symbol table structure of the processed grammar</li> <li>added <code>isReadOnly</code> to <code>Variable</code> in <code>BasicSymbols</code></li> <li>added <code>isElliptic</code> to <code>Method</code> in <code>TypeSymbols</code></li> <li>added a context condition to warn if keywords consist of numbers only <ul> <li>these numbers will be tokenized as keywords instead of numbers</li> </ul> </li> <li>added <code>splittoken</code> to express that the listed tokens should be split and not handled as a single token<ul> <li>example: <code>splittoken \":::\";</code> results in three token <code>:</code></li> </ul> </li> <li>added <code>nokeyword</code> to express that the listed keywords should not be handled as tokens</li> <li>example: <code>nokeyword \"automaton\", \"state\";</code> means that <code>automaton</code> and <code>state</code> should not be handled as keywords</li> <li>introduced symbol inheritance</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#changes_13","title":"Changes","text":"<ul> <li>renamed <code>de.monticore.type.TypeSymbols</code> to <code>de.monticore.symbols.OOSymbols</code></li> <li>renamed <code>de.monticore.type.BasicTypeSymbols</code> <code>to de.monticore.symbols.BasicSymbols</code></li> <li>reworked appended <code>s</code> for list attributes</li> <li>renamed SymbolLoader to SymbolSurrogate</li> <li>Surrogates are now subclasses of their corresponding symbols</li> <li><code>MCJavaBlock</code> in <code>MCCommonStatements</code> now spans a shadowing, non-exporting, ordered scope</li> <li><code>MethodDeclaration</code> and <code>ConstructorDeclaration</code> in <code>JavaLight</code> use <code>MCJavaBlock</code> instead of <code>MCBlockStatement</code></li> <li><code>Label</code> in <code>MCLowLevelStatement</code> now is a symbol</li> <li><code>VarDecl</code> in <code>MCVarDeclarationStatements</code> no longer exists<ul> <li><code>DeclaratorId</code> now produces <code>FieldSymbol</code>s</li> </ul> </li> <li>removed <code>isParameter</code> and <code>isVariable</code> from <code>Field</code> in <code>TypeSymbols</code></li> <li>the language class is no longer generated</li> <li>moved creator expressions to <code>JavaClassExpression</code> </li> <li>moved <code>PlusExpression</code> and <code>MinusExpression</code> from <code>AssignmentExpressions</code> to <code>CommonExpressions</code></li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#fixes_11","title":"Fixes","text":"<p>Fixed an issue where super and subtype comparison was wrong in type check Fixed handling of capital letters in grammar package   * using capital letters now produces a warning * Fixed an issue were <code>setAbsent</code> methods in the generated SymbolBuilder where not properly overridden * Fixed that non-shadowing scopes where not handled as intended</p>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-610","title":"MontiCore 6.1.0","text":"<p>released: 07.05.2020</p>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-600","title":"MontiCore 6.0.0","text":"<ul> <li>Uses CD4Analysis 1.5.0</li> <li>replace get*opt methods with get*</li> <li>bugfixing</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-5401","title":"MontiCore 5.4.0.1","text":"<ul> <li>Uses CD4Analysis 1.4.0</li> <li>add generation of serializers for grammars</li> <li>add SymbolLoader</li> <li>remove SymbolReferences</li> <li>add DeSers for TypeSymbols</li> <li>improved TypeCheck</li> <li>replace getName methods with printType methods</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-530","title":"MontiCore 5.3.0","text":"<ul> <li>Uses CD4Analysis 1.3.20.2</li> <li>new Generator based on Decorator-Pattern</li> <li>add Translation classes</li> <li>add grammar it-tests</li> <li>move TypesCalculator to TypeCheck, create derive classes and synthesize classes</li> <li>add TypeSymbols and SymTypeExpression structure</li> <li>added DeSers for SymTypeExpressions</li> <li>added keyword \"key\" for KeyTerminals </li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-520","title":"MontiCore 5.2.0","text":"<ul> <li>add \"List\"-Suffix to attribute name</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-510","title":"MontiCore 5.1.0","text":"<ul> <li>Remove the dependency to JavaDSL, add JavaLight</li> <li>Uses CD4Analysis 1.3.19</li> <li>added grammar TypeSymbols</li> <li>renamed SymbolDelegateList to SymbolResolvingDelegateList</li> <li>add methods for scoperule-attributes in interfaces</li> <li>add MCTypeVisitor to transform ASTTypes to TypeExpressions</li> <li>add Groovy Plugin</li> <li>add MontiCore Statements at de.monticore.statements</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-506","title":"MontiCore 5.0.6","text":"<ul> <li>The IncGen-reports are stored in the source code directory</li> <li>Removed MutableScope</li> <li>IncGen-Reports are stored </li> <li>Removed deprecated keyword ast (use astrule) in *.mc4</li> <li>Add visitors for symbol table</li> <li>Enable TOP mechanism for visitors</li> <li>add SymbolRules and ScopeRules</li> <li>renamed MCBasicLiterals to MCCommonLiterals, add MCLiteralsBasis</li> <li>move literals to package de.monticore.literals</li> <li>renamed ShiftExpressions to BitExpressions</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-503","title":"MontiCore 5.0.3","text":"<ul> <li>Use the following emf coordinates (MB):</li> <li>group: org.eclipse.emf</li> <li>version: 2.15.0</li> <li>artifact: org.eclipse.emf.ecore | org.eclipse.emf.ecore.xmi | org.eclipse.emf.common</li> <li>The runtime environment may need the following dependency (group: org.eclipse.platform; artifacitId: org.eclipse.equinox.common; version: 3.10.0)</li> <li>splitted Types.mc4 in MCBasicTypes, MCCollectionTypes, MCSimpleGenericTypes and MCFullGenericTypes</li> <li>moved expressions to de.monticore.expressions and added expressions</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-502","title":"MontiCore 5.0.2","text":"<ul> <li>Generated by the MontiCore version 5.0.1</li> <li>Uses JavaDSL 4.3.13, Cd4Analysis 1.3.16, se-commons 1.7.9</li> <li>Introduce deprecated annotation in grammars (#2215)</li> <li>Serialization of symobls</li> <li>Add reporter IncGenCheckReporter</li> <li>Configuration of the report path</li> <li>Specific resolving methods in generated scope classes</li> <li>Bugfixes</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-501","title":"MontiCore 5.0.1","text":"<ul> <li>Generated by the MontiCore version 5.0.0</li> <li>Uses JavaDSL 4.3.12, Cd4Analysis 1.3.13, se-commons 1.7.9</li> <li>Bugfixes</li> <li>New methods defineHookPointWithDefault in GlobalExtensionManagement (MB)</li> <li>new method cmpToken in MCParser (MB)</li> <li>every (non-)terminal defined in an interface must be present in the implementing production (including Name and Usage Name) (CoCo) (BS)</li> <li>to ensure that any terminal (with a specific name) has to be implemented, use an empty string, e.g. interface Expression = operator=\"\";</li> <li>new methods are generated for the referenced symbol and definition and the definition is saved in an attribute (generated wenn you write sth. like \"Name@Symbol\") (NP)</li> <li>coco that gives a warning if you do not extend conservative (NP)</li> <li>coco that attributes with the same usage Name have to reference the same symbol (NP)</li> <li>SpannedScope and Symbol Methods in ASTNode set to deprecated (NP)</li> </ul>"},{"location":"00.org/Explanations/CHANGELOG/#monticore-500","title":"MontiCore 5.0.0","text":"<ul> <li>Generated by the MontiCore version 4.5.5.1</li> <li>Uses JavaDSL 4.3.11, Cd4Analysis 1.3.13, se-commons 1.7.8</li> <li>Changed name building for list attributes in grammars (x:Name* -&gt; getXList)</li> <li>Changed api for GlobalExtensionMangament and TemplateController (see reference manual)</li> <li>New api for AST nodes (constructor, getter and setter for lists and optional attributes, ...)</li> <li>Builder classes for AST nodes are external now. Signatures are similar to those in the corresponding AST node, except those methods which set or add something, these return the Builder itself (which allows method chaining)</li> <li>Changed default script to noemf for the generation of MontiCore. If you want to use emf you can generate monticore-grammar and Java-DSL with the profile \"emf\". This profile also creates the emf jars. You are also able to test the integration-tests with the profile \u201cemf-it-tests\u201d, which contains extra tests for the generation with emf.</li> <li>Parsed grammars are not stored as class diagram anymore. CD is only stored as report.</li> <li>Removed deprecated method filter(ResolvingInfo resolvingInfo, List symbols) use filter(ResolvingInfo, Collection) instead <li>Removed deprecated method filter(ResolvingInfo resolvingInfo, String name, List symbols) use filter(ResolvingInfo, String, Map) instead <li>Removed deprecated method create(Class symbolClass, SymbolKind symbolKind) use create(SymbolKind) instead</li> <li>Removed deprecated method getSymbols use getLocalSymbols instead</li> <li>Removed deprecated method resolve(SymbolPredicate predicate) use resolveMany(String, SymbolKind, Predicate) instead</li> <li>Removed deprecated method define use add instead</li> <li>Removed deprecated method resolve(ResolvingInfo resolvingInfo, String name, SymbolKind kind, AccessModifier modifier)</li> <li>Removed deprecated method checkIfContinueWithEnclosing use checkIfContinueWithEnclosingScope instead</li> <li>Removed deprecated method addResolver use addFilter(String, ResolvingFilter) instead</li> <li>Removed deprecated method addTopScopeResolver use addDefaultFilter instead</li> <li>Removed deprecated method addTopScopeResolvers use addDefaultFilters instead</li> <li>Removed deprecated method getTopScopeResolvingFilters use getDefaultFilters instead</li> <li>Removed deprecated constructer CommonResolvingFilter(Class symbolClass, SymbolKind targetKind) use CommonResolvingFilter(SymbolKind) instead</li> <li>Removed deprecated method continueWithScope and continueWithEnclosingScope</li> <li>Removed class FaildLoadingSymbol</li> <li>Removed deprecated method putInScopeAndLinkWithAst use addToScopeAndLinkWithNode instead</li> <li>Removed deprecated constructer CommonModelingLanguage(String, String, SymbolKind) use CommonModelingLanguage(String, String) instead</li> <li>Removed deprecated method addResolver use addResolvingFilter instead</li> <li>Removed deprecated method addResolver use addResolvingFilter instead</li> <li>Removed deprecated method getResolvers use getResolvingFilters instead</li> <li>Removed deprecated method loadAmbiguousModelAndCreateSymbolTable use loadModelsIntoScope instead</li> <li>Removed deprecated method loadAmbiguousModels use loadModels instead</li> <li>Removed deprecated method defineHookPoint(String) use glex.defineHookPoint instead</li> <li>Removed deprecated enum ParserExecution</li> <li>Removed deprecated method getParserTarget</li> <li>Removed deprecated method setParserTarget</li>"},{"location":"00.org/Explanations/CHANGELOG/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"00.org/Explanations/FAQ/","title":"FAQ","text":""},{"location":"00.org/Explanations/FAQ/#faq-for-monticore","title":"FAQ for MontiCore","text":""},{"location":"00.org/Explanations/FAQ/#using-maven","title":"Using Maven","text":"<ol> <li>Eclipse shows me an error stating that my project configuration is not up-to-date.</li> <li>I get an error saying something about Lifecycle Mappings.</li> <li>Maven build fails because of a missing JDK path.</li> <li>Maven build for de.monticore.parent project fails in eclipse</li> <li>I have a very weird problem, seriously, very weird ...</li> <li>My .m2 folder does not exist.</li> <li>I get a strange error telling me that something is wrong with the UTF8 encoding.</li> <li>Changes I made on one module are not reflected in another module.</li> </ol> <ol> <li> <p>Eclipse shows me an error stating that my project configuration is not up-to-date. Right-click that project and select Maven -&gt; Update Project Configuration.</p> </li> <li> <p>I get an error saying something about Lifecycle Mappings. Install the m2e extensions mentioned in the developer tutorial.</p> </li> <li> <p>Maven build fails because of a missing JDK path. Change the installed runtime JREs to the installed JDK. Go to Window -&gt; Preferences -&gt; Installed JREs. Add the JDK path and select it to be the default one.</p> </li> <li> <p>Maven build for de.monticore.parent project fails in eclipse. Go to Window -&gt; Preferences -&gt; General -&gt; Workspace. Disable \"Build automatically\" preference.</p> </li> <li> <p>I have a very weird problem, seriously, very weird ... Right-click that project and select Maven -&gt; Update Project Configuration.</p> </li> <li> <p>My .m2 folder does not exist. Folders in Windows with a leading \".\" can only be created using the command line. Start the command line and type in \"mkdir .m2\" in your home folder.</p> </li> <li> <p>I get a strange error telling me that something is wrong with the UTF8 encoding. Change the UTF8 encoding by clicking on Window -&gt; Preferences. Then, select the item as shown below and change the values accordingly.</p> </li> <li> <p>Changes I made on one module are not reflected in another module. Remember that all Maven modules are independent units. By default, they are not directly imported into each other. Instead, Maven resolves dependencies between projects by selecting packages (e.g.jar files) produced by these modules from your local Maven dependency repository. To make the latest version of a module available through this repository, you have to explicitly install it. If you execute an install on an aggregating POM-project, all child modules will be built with the current state of their depending projects as Maven always builds a hierarchy of modules in order of their mutual dependencies. However, if you are working in Eclipse, the workbench can import modules live. This feature is called \"Workspace resolution\" and is enabled by default for Eclipse automatic project builders. Nevertheless, if you build a module using a Run Configuration you have to explicitly activate \"Resolve Workspaces artifacts\".</p> </li> </ol>"},{"location":"00.org/Explanations/FAQ/#further-information","title":"Further Information","text":"<ul> <li>MontiCore project - MontiCore</li> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"00.org/Explanations/StatusOfGrammars/","title":"StatusOfGrammars","text":""},{"location":"00.org/Explanations/StatusOfGrammars/#monticore-grammar-status-plans-an-overview","title":"MontiCore Grammar Status Plans - an Overview","text":"<p>MontiCore uses grammars as primary mechanism  to describe DSLs and DSL components. The extended  grammar format allows to compose language components by (1) inheriting, (2) extending, (3) embedding  and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable, can be extended with handwrittten code and most imprtandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse.</p> <p>To improve understanding, what will happen with a grammar, we define the  following set of stati and mention the status of each grammar, both in the explanation and in the grammar itself:</p>"},{"location":"00.org/Explanations/StatusOfGrammars/#status-of-a-grammar","title":"Status of a Grammar","text":"<ol> <li> <p>MontiCore stable: Such a grammar is meant to be stable in the further development of  MontiCore. The grammar is tested and assumed to be of high quality. It may rarely happen that smaller extensions are made in a conservative  form, which means that (1) composition with any other grammars, (2) extensions and adaptations and (3) handwritten extensions will  still work.</p> </li> <li> <p>Beta: In Stabilization: Such a grammar is in the process of becoming stable. One might already  include the grammar, but some changes may still appear. (See task list for potential changes.)</p> </li> <li> <p>Alpha: Intention to become stable: Such a grammar is relatively fresh, but intended to become stable  and useful. Changes may occur, e.g. when restructuring or bug fixing. Or it may be taken out of the process and become one of the following:</p> </li> <li> <p>Example: The grammar serves as working example, but will not have high priority on keeping the grammar up to date. One might use it as inspiration for their own developments.</p> </li> <li> <p>Deprecated: The grammar should not be used anymore, it is deprecated, and only  there for compatibility. Normally a newer version of the content  exists in other, often decomposed grammars, allowing to configure which part of the grammar to be used. Deprecated grammars are not listed in any overview.</p> </li> </ol>"},{"location":"00.org/Explanations/StatusOfGrammars/#marking-the-status-of-grammars","title":"Marking the Status of Grammars","text":"<p>A comment of the following form within the grammar defines this status:</p> <ol> <li><code>/* This is a MontiCore stable grammar.</code> <code>* Adaptations -- if any -- are conservative. */</code></li> <li><code>/* Beta-version: This is intended to become a MontiCore stable grammar. */</code></li> <li><code>/* Alpha-version: This is intended to become a MontiCore stable grammar. */</code>    (but sometimes also omitted)</li> </ol>"},{"location":"00.org/Explanations/StatusOfGrammars/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"00.org/Licenses/LICENSE-BSD3CLAUSE/","title":"LICENSE BSD3CLAUSE","text":"<p>Copyright (c) MontiCore*, All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> <p>* belongs to RWTH and RIDT</p>"},{"location":"00.org/Licenses/LICENSE-LGPL/","title":"LICENSE LGPL","text":""},{"location":"00.org/Licenses/LICENSE-LGPL/#gnu-lesser-general-public-license","title":"GNU LESSER GENERAL PUBLIC LICENSE","text":"<p>Version 3, 29 June 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this  license document, but changing it is not allowed.</p> <p>This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below.</p> <ol> <li>Additional Definitions.</li> </ol> <p>As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License.</p> <p>\"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below.</p> <p>An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library.</p> <p>A \"Combined Work\" is a work produced by combining or linking an Application with the Library.  The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\".</p> <p>The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version.</p> <p>The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work.</p> <ol> <li>Exception to Section 3 of the GNU GPL.</li> </ol> <p>You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL.</p> <ol> <li>Conveying Modified Versions.</li> </ol> <p>If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version:</p> <p>a) under this License, provided that you make a good faith effort to    ensure that, in the event an Application does not supply the    function or data, the facility still operates, and performs    whatever part of its purpose remains meaningful, or</p> <p>b) under the GNU GPL, with none of the additional permissions of    this License applicable to that copy.</p> <ol> <li>Object Code Incorporating Material from Library Header Files.</li> </ol> <p>The object code form of an Application may incorporate material from a header file that is part of the Library.  You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following:</p> <p>a) Give prominent notice with each copy of the object code that the    Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the object code with a copy of the GNU GPL and this license    document.</p> <ol> <li>Combined Works.</li> </ol> <p>You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following:</p> <p>a) Give prominent notice with each copy of the Combined Work that    the Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the Combined Work with a copy of the GNU GPL and this license    document.</p> <p>c) For a Combined Work that displays copyright notices during    execution, include the copyright notice for the Library among    these notices, as well as a reference directing the user to the    copies of the GNU GPL and this license document.</p> <p>d) Do one of the following:</p> <pre><code>   0. Convey the Minimal Corresponding Source under the terms of this\n   License, and the Corresponding Application Code in a form\n   suitable for, and under terms that permit, the user to\n   recombine or relink the Application with a modified version of\n   the Linked Version to produce a modified Combined Work, in the\n   manner specified by section 6 of the GNU GPL for conveying\n   Corresponding Source.\n\n   1. Use a suitable shared library mechanism for linking with the\n   Library.  A suitable mechanism is one that (a) uses at run time\n   a copy of the Library already present on the user's computer\n   system, and (b) will operate properly with a modified version\n   of the Library that is interface-compatible with the Linked\n   Version.\n</code></pre> <p>e) Provide Installation Information, but only if you would otherwise    be required to provide such information under section 6 of the    GNU GPL, and only to the extent that such information is    necessary to install and execute a modified version of the    Combined Work produced by recombining or relinking the    Application with a modified version of the Linked Version. (If    you use option 5d0, the Installation Information must accompany    the Minimal Corresponding Source and Corresponding Application    Code. If you use option 5d1, you must provide the Installation    Information in the manner specified by section 6 of the GNU GPL    for conveying Corresponding Source.)</p> <ol> <li>Combined Libraries.</li> </ol> <p>You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following:</p> <p>a) Accompany the combined library with a copy of the same work based    on the Library, uncombined with any other library facilities,    conveyed under the terms of this License.</p> <p>b) Give prominent notice with the combined library that part of it    is a work based on the Library, and explaining where to find the    accompanying uncombined form of the same work.</p> <ol> <li>Revised Versions of the GNU Lesser General Public License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation.</p> <p>If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.</p>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/","title":"License","text":""},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-model","title":"MontiCore 3-Level License Model","text":"<p>MontiCore is a language workbench for an efficient  development of domain-specific languages (DSLs). All the code available in these GitHub MontiCore projects is published under three levels of licenses as discussed below.</p> <p>For a full use of generated code in commercial and any other forms of  projects, the finally generated code is, completely freely available, even though the main workbench itself has restrictions. </p>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#license-overview","title":"License Overview","text":"<p>The MontiCore Language Workbench deals with three levels of code:</p> <ul> <li> <p>(Level 3) MontiCore: the main library constituting the LWB,</p> </li> <li> <p>(Level 2) tool derivates that are to a large extent generated      by the MontiCore LWB, and</p> </li> <li> <p>(Level 1) product code that is finally generated by tool derivates.     This also includes analytical results, thus as results of consistency      checks, code smells, test infrastructures, etc.</p> </li> </ul> <p>Each level has its own and more relaxing license: </p> <ul> <li> <p>(Level 1) Product code: the generated product code is absolutely  free for each form of use including commercial use without any  mentioning and thus without any restriction from MontiCore.  Developers may even put their own License label on it.</p> </li> <li> <p>(Level 2) Tool derivate: when a tool is derived using the MontiCore  language workbench, then the result falls under the pretty liberal  BSD 3 Clause license  (see BSD-3-Clause).</p> </li> <li> <p>(Level 3) MontiCore: the main LWB components are published in  GitHub under the LGPL license (see  LGPL V3.0).</p> </li> </ul> <p>As a consequence using MontiCore during development is rather liberal  and the final products do not have any restriction. </p> <p>Please note that this license level model holds for the MontiCore LWB and all related projects published in GitHub. For artefacts available  from other sources, different licenses may apply. E.g. developers of tools may impose their own form of  restrictions i.e. licenses on their tools respectively the results generated by these tools.  Artefacts directly made available from RWTH Aachen and not published in  GitHub are for the concretely granted purpose only and are  not do be made public at all. </p> <p>As usual in software development: For statistics, scientific reasons,  quality and performance improvement, the tools occasionally send the  fully anonymous statistics report (see file) to the developers. </p>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-on-files","title":"MontiCore 3-Level License on Files","text":"<p>This repository for the MontiCore language workbench contains three  kinds of artifacts: </p> <ul> <li> <p>Java-files that are executed in the MontiCore LWB. They are under  LGPL licence.</p> </li> <li> <p>Java-files that belong to the runtime environment (RTE) and are thus  copied to the generated code. They are under BSD 3 Clause license.</p> </li> <li> <p>Templates executed during generation of tool code.  They are also only under BSD 3 Clause license,  because parts of them are copied to the generated code. </p> </li> </ul>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-on-tool-and-language-repositories","title":"MontiCore 3-Level License on Tool and Language Repositories","text":"<p>Other MontiCore repositories contain complete or incomplete tools as well as MontiCore language components. They contain again three  kinds of artifacts: </p> <ul> <li> <p>Grammars that are used to define language components in the MontiCore LWB.  They are under LGPL licence, but these can be extended by own grammars freely.</p> </li> <li> <p>Java-files that are executed in the tool (belonging to the tool RTE).  They are under BSD 3 Clause license.</p> </li> <li> <p>Java-files that belong to the product runtime environment (RTE) are  completely free without restriction.</p> </li> <li> <p>Templates executed by the tool during generation of product code.  They also are completely free without restriction, because parts of them are copied to the generated code. </p> </li> </ul> <p>As a result, a tool derivate (level 2) does not contain any LGPL code,  but only BSD 3 Clause code. Executing the tool derivate then  produces completely free code (level 1).</p> <p>If questions appear e.g. on using MontiCore itself in a product or building an interpreter, please contact monticore@se-rwth.de. </p>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#underlying-licenses","title":"Underlying Licenses","text":"<p>The MontiCore 3 Level license is built on:</p> <ul> <li> <p>LGPL V3.0 </p> </li> <li> <p>BSD-3-Clause </p> </li> </ul> <p>Please also note the general disclaimer from the BSD 3 Clause license on  liability, etc. </p>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#included-software","title":"Included Software","text":"<p>This product includes the following software, both having their own licenses, compatible with MontiCores licenses:</p> <ul> <li>AntLR</li> <li>FreeMarker</li> </ul>"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#further-information","title":"Further Information","text":"<ul> <li> <p>see also MontiCore Reference Manual</p> </li> <li> <p>MontiCore project - MontiCore</p> </li> </ul>"},{"location":"docs/BestPractices-CLI/","title":"BestPractices CLI","text":""},{"location":"docs/BestPractices-CLI/#monticore-best-practices-designing-tools-for-command-line-interfaces","title":"MontiCore Best Practices - Designing Tools for Command Line Interfaces","text":"<p>Some DSLs require a tool to enable general accessibility via the command line interface (CLI).  When designing a tool, we recommend some standard guidelines.</p>"},{"location":"docs/BestPractices-CLI/#designing-a-tool","title":"Designing a Tool","text":"<p>The tool provides a general interface for the functionalities developed for a language.  This includes all features such as parsing of models, saving and loading of symbol  tables, pretty printing, reporting, or export as object diagram.</p>"},{"location":"docs/BestPractices-CLI/#default-options","title":"Default Options","text":"<p>The available options are of course language-specific.  However, we suggest some default arguments for standardized access. </p> <pre><code>-h,--help                    Prints this help dialog\n-i,--input &lt;file&gt;            Reads the (mandatory) source file resp. the\n                             contents of the model\n-path &lt;dirlist&gt;              Sets the artifact path for imported symbols, space separated\n-modelpath &lt;dirlist&gt;         Sets the artifact path for imported models, space separated\n-pp,--prettyprint &lt;file&gt;     Prints the AST to stdout or the specified output \n                             file (optional)\n-s, --symboltable &lt;file&gt;     Serializes and prints the symbol table to stdout \n                             or the specified output file (optional) \n-r,--report &lt;dir&gt;            Prints reports of the parsed artifact to the\n                             specified directory (optional). Available reports\n                             are language-specific\n-o,--output &lt;dir&gt;            Path of generated files (optional)\n-so,--syntaxobjects &lt;file&gt;   Prints an object diagram of the AST to stdout or\n                             the specified file (optional)\n-sc,--script &lt;file&gt;          Advanced configuration 2: through a groovy script \n                             that allows to adapt and extend the tool workflow (optional) \n                             (only some tools provide groovy scripting)\n-ct, --configtemplate        Advanced configuration 1: through a Freemarker template\n                             that allows to adapt the generation process (optional)\n                             (only some tools provide a template configuration call)\n</code></pre> <p>An example of a complete yet relatively small tool example can be found in the  JSON project.</p> <p>Some explanation to the arguments: * The tool is meant for handling one individual model (<code>-i</code>) and store the   results appropriately in files.  * Typical results are    * (1) generated files (<code>-o</code>) that are used in the next step of      the build process (e.g. for compilation).   * (2) the symboltable (<code>-s</code>) that is then used by other tools to import symbols   * (3) reports (<code>-r</code>) and internal information (<code>-so</code>), like the AST of the      parsed model usable for developers to understand what happened   * (4) and potentially also internal information on used input and generated      output files     that allows the calling build script to understand whether a redo is      needed (as part of a     larger incremental and efficient development process). * Directories in <code>-path</code> are separated via spaces, i.e. each path is an argument on its own.    Example: <code>-path a/b x/y</code>. * Directories in the above options <code>-path</code>, <code>-o</code> describe the root   structure that is further refined  by packages (like in Java).    That means with <code>-path a/b x/y</code>   the actual symboltable for a Statechart <code>de.mine.Door</code> is found in    <code>a/b/de/mine/Door.scsym</code> or <code>x/y/de/mine/Door.scsym</code> (in that order) * Languages typically only load other symbols rather than other models. Therefore, the argument    <code>-path</code> that identifies only paths containing symbols should be implemented by most languages, whereas    the argument <code>-modelpath</code> for identifying paths containing models is typically not required. * Groovy-scripting (<code>-sc</code>, <code>--script</code>): A Groovy Script is meant to describe the tool internal    workflow. It controls parsing, symbol construction, reporting, code generation etc.   This kind of scripting should only become necessary when various alternative   configurations are possible. Thus, not every tool provides Groovy scripting. * Template-scripting (<code>-ct</code>, <code>--configtemplate</code>):    It is possible to add a custom template script right before   the full generation process starts. This template is useful to customize the    generation process e.g. by defining hook points and thus injection more templates   or switching verbosity on/off.</p>"},{"location":"docs/BestPractices-CLI/#usage-of-the-tool-jar","title":"Usage of the Tool-JAR","text":"<p>A note to the tool usage:  Tools do not organize the correct order of their calls. If embedded in a larger build process, an appropriate gradle (preferred) or make it is useful for  incremental efficiency.</p> <p>This organisation is above the tool, due to the efficiency of the  (grade or make) buildscript itself, which must be able to decide, whether a redo is needed. If the tool was called to decide that, too much time was already wasted.</p> <p>For a build script to decide whether to call the tool or not, a tool call should (and actually MontiCore does) provide among others a list of files it used for input. </p>"},{"location":"docs/BestPractices-CLI/#automatically-generating-a-tool-jar","title":"Automatically Generating a Tool-JAR","text":"<p>Note to the tool development: To automatically derive an executable JAR from the Gradle build process for the  corresponding tool, the following template can be used.</p> <p><pre><code>// all in one tool-jar\nshadowJar {\n    manifest {\n        attributes \"Main-Class\": \"de.monticore.${archiveBaseName.get().capitalize()}Tool\"\n    }\n    archiveFileName = \"MC${archiveBaseName.get()}.${archiveExtension.get()}\"\n    minimize()\n    archiveClassifier = \"mc-tool\"\n}\n\njar.dependsOn shadowJar\n</code></pre> This blueprint can be used in the <code>build.gradle</code> script to derive a JAR for the tool  class and its provided command line functionalities.  The packed JAR already contains all the necessary dependencies.  The template defines the main class and name of the JAR.  To foster automated reuse, the template has already been configured to generate  a suitable JAR for each language project without manual adjustments.  However, this requires adhering to the following conventions: * The name of the main class is equal to the language project name (usually defined    in the <code>settings.gradle</code>) with the suffix Tool.    Furthermore, the first letter of the main class is always capitalized to adhere    to the Java code conventions * The package of the main class is <code>de.monticore</code> * The generated JAR can be found in 'target/libs'</p> <p>Example: For a language project <code>MyLang</code> we have to implement the <code>MyLangTool.java</code> located  in the package <code>de.monticore</code>. This automatically generates the executable JAR <code>MCMyLang.jar</code></p> <p>In general, the template can be customized by specifying the corresponding main  class and JAR name definitions. However, we recommend to use the predefined automatic approach.</p>"},{"location":"docs/BestPractices-CLI/#functional-approach","title":"Functional Approach","text":"<p>When implementing the tool, we recommend a functional paradigm to provide the  desired functionalities, as the too class is not about data structures but only  exists to make functions available.  In this case it would be counterproductive to store the arguments of the available  functions as attributes. Instead, it makes more sense to pass these arguments as parameters when calling  the respective methods. This yields several advantages:</p> <ul> <li>Values that have not yet been set do not have to be displayed with Optionals </li> <li>As a result. tedious unwrapping of Optionals with corresponding error messages    is no longer necessary</li> <li>get/set methods for attributes are not required</li> <li>Facilitates reusability of modular functions</li> </ul> <p>Of course, there are always trade-offs, but a more explicit functional way of  thinking should be considered more intensively, especially when it is not about  data structures but about the functions. For instance, if intermediate results are stored  for efficiency reasons, this  might a good argument to do it differently.</p>"},{"location":"docs/BestPractices-CLI/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BestPractices-Errors/","title":"BestPractices Errors","text":""},{"location":"docs/BestPractices-Errors/#monticore-best-practices-understanding-errors-defining-errors","title":"MontiCore Best Practices - Understanding Errors, Defining Errors","text":"<p>Errors happen. Some happen because of faults in the code (we call that internal errors), some happen because we haven't explained well how to use MontiCore and  how to use the generated code.</p> <p>Here we try to add information how to handle occurring errors. We use the error code for an easier identification. Error codes start with  <code>0x</code>and use 5(!) hex characters and thus should be at the same time  memorizable (because not completely unknown, but still not so common that they could be taken for something else).</p>"},{"location":"docs/BestPractices-Errors/#handling-errors-0x","title":"Handling Errors 0x.....","text":""},{"location":"docs/BestPractices-Errors/#how-to-use-expressions-0xa0129","title":"How to use Expressions (0xA0129)","text":"<ul> <li><code>Expression</code> is a predefined nonterminal in the MontiCore basic grammars.    Because of the infix notation of some operators and similar challenges,   it is usually not possible to use a subset of the expressions only.    For example use of <code>ConditionalExpression</code> may lead to a parser generation    error (i.e. <code>0xA0129</code>).</li> <li>Solutions:</li> <li>Use nonterminal <code>Expression</code> and forbid all unwanted alternatives through       context conditions.</li> <li>Think of allowing more general expressions?</li> <li>If especially the syntax of <code>if . then . else .</code> shall be reused,       why not define this in a new nonterminal and ignore that the same      syntactic constructs were already available in another production.</li> <li>Defined by: CKi, BR.</li> </ul>"},{"location":"docs/BestPractices-Errors/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BestPractices-Language-Design/","title":"BestPractices Language Design","text":""},{"location":"docs/BestPractices-Language-Design/#monticore-best-practices-designing-languages","title":"MontiCore Best Practices - Designing Languages","text":"<p>MontiCore provides a number of options to design  languages, access and modify the abstract syntax tree, and produce output files.</p> <p>Some general questions on how to design a complete languages are addressed here. </p>"},{"location":"docs/BestPractices-Language-Design/#designing-a-language","title":"Designing A Language","text":""},{"location":"docs/BestPractices-Language-Design/#correct-language-vs-superset","title":"Correct language vs. superset?","text":"<ul> <li>When you know that the incoming model will be correct,    because they are generated   by algorithm or has been checked by a previous tool already,    you can decide to parse a (slight) superset of the language, but   should ensure the AST is usefully compatible/identical.</li> <li>This may simplify the development process for two reasons:    ** (a) you may derive a simpler grammar and    ** (b) you may omit defining the context conditions.</li> <li>But beware: (a) situations may change and manually changed models might come in,   (b) the model is adapted by an ill-behaving pre-processor or (c) the model   may belong to an old language version.</li> <li>This simplified approach applies e.g. for non-human-readable languages,    such as JSON or XML,   because their models (respectively data sets) are typically generated by   assumingly correct tools.</li> <li>Defined by: BR</li> </ul>"},{"location":"docs/BestPractices-Language-Design/#versioning-an-evolving-language","title":"Versioning an evolving language?","text":"<ul> <li>When languages evolve, models may become invalid, because    certain (now obligatory) parts are missing, or old keywords are used.</li> <li>We generally believe that a language that is made for long-lasting    models should not embody its version in the models (i.e. like Java, C++ and    other GPLs and unlike XML dialects).</li> <li>When evolving a language, you should only evolve it in conservative form, i.e.</li> <li>All new elements are optional by <code>.?</code>, <code>.*</code> or offer new alternatives <code>(old | new)</code></li> <li>Old elements or keywords are not simply removed, but      forbidden by coco warnings, marking them as deprecated for a while. </li> <li>Downward compatibility of newer models, however, is not useful.    We can safely enforce developers should normally use the newest    versions of their tools.</li> <li>Defined by: BR</li> </ul>"},{"location":"docs/BestPractices-Language-Design/#language-design-in-the-large","title":"Language Design in the Large","text":""},{"location":"docs/BestPractices-Language-Design/#making-transitively-inherited-grammars-explicit","title":"Making Transitively Inherited Grammars Explicit?","text":"<ul> <li>When the grammar inclusion hierarchy becomes larger, there will be redundancy.   In:   <pre><code>  grammar A { .. } ;\n  grammar B extends A { .. } ;\n  grammar C extends A,B { .. } ;\n  grammar D extends B { .. } ;\n</code></pre>   Grammars <code>C</code> and <code>D</code> actually include the same nonterminals.</li> <li>If <code>A</code> is made explicit, you have more information right at hand, but also   larger grammars. It is a matter of taste.</li> <li>A recommendation: when you use nonterminals from A explicitly, then also    make the extension explicit. However, be consistent.</li> </ul>"},{"location":"docs/BestPractices-Language-Design/#how-to-achieve-modularity-in-the-sense-of-decoupling","title":"How to Achieve Modularity (in the Sense of Decoupling)","text":"<ul> <li>Modularity in general is an important design principle.   In the case of model-based code generation, modularity involves the following    dimensions:<ol> <li>Modelling languages</li> <li>Models</li> <li>Generator</li> <li>Generated code</li> <li>Runtime-Environment (RTE) including imported standard libraries</li> <li>Software architecture (of the overall system), software stack</li> </ol> </li> <li>These dimensions are not orthogonal, but also not completely interrelated.   The actual organisation will depend on the form of project.</li> <li>A weak form of modularity would be to organize things in   well understood substructures such as packages.    A deeper form of modularity deals with possibility for individual reuse    and thus an explicit decoupling of individual components. We aim for    decoupling (even if developed in the same git project).</li> <li>Modularity also deals with extensibility and adaptation.</li> <li>A principle for adaptation for the generator,    the generated code, and the RTE is to design each of them   like a framework with explicit extension points.   Extension points may be (empty) hook methods to be filled, Java interfaces   to be implemented and their objects injected to the code e.g., via    factories, builders or simply method parameters.</li> <li>A principle for modularity for the generator,    the generated code, and the RTE is to design parts of them as    independent library functions (or larger: components) that can be used if needed.</li> <li>We recommend to modularize whenever complexity overwhelms or extensibility and   adaptability are important:<ol> <li>MontiCore has powerful techniques for adaptation, extension and     composition of modelling languages (through their grammars). See the    handbook.</li> <li>MontiCore has powerful techniques for the aggregation of models --    using the same principles as programming languages, namely allowing to keep     the models independent (and thus storable, versionable, reusable) artifacts,    while they are semantically and through the generator technology well integrated.     The appropriate approach is based on using foreign models, e.g., through     <code>import</code> statements and sharing symbol infrastructures as described in the    handbook.</li> <li>The generator provides (a) many Java classes and methods that can be overridden    (b) Freemarker templates hook points to extend and replace templates, and (c)    can be customized using a groovy script.    The generator itself is often structured along the software architecture / stack,    e.g., in frontend, application backend, database, transport layer, etc.</li> <li>The generated code must be designed appropriately by the generator designer,     by generating builders, mills, etc. for each form of product - quite similar     to MontiCore itself.    The generated code is usually structured along the components or sub-systems    that the software architecture defines.</li> <li>The RTE is probably well-designed if it is usable in a normal framework.</li> </ol> </li> <li>Please note: it is not easy to design modularity and extensibility from beginning.   Framework design has shown that this is an iterative optimizing process.   It must be avoided to design too many extension elements into the system   from the beginning, because this adds a lot of complexity.</li> <li>Defined by: BR  </li> </ul>"},{"location":"docs/BestPractices-Language-Design/#realizing-embedding-through-an-interface-nonterminal-extension-point","title":"Realizing Embedding through an Interface Nonterminal Extension Point","text":"<p>Consider the following scenario:  A language <code>Host</code> defines an extension point through an interface nonterminal.</p> <pre><code>grammar Host { A = I*; interface I; }\n</code></pre> <p>Another language <code>Embedded</code>, that has no connection to the <code>Host</code> language,  defines a class nonterminal <code>E</code>.</p> <pre><code>grammar Embedded { E = \"something\"; }\n</code></pre> <p>MontiCore provides alternative solutions to embed the language <code>Embedded</code> into the language <code>Host</code> at the extension point <code>I</code>. All solutions presented here require to implement a new grammar <code>G</code> that extends the grammars <code>Embedded</code> and <code>Host</code>  reuses the start nonterminal of the <code>Host</code> grammar:</p> <pre><code>grammar G extends Host, Embedded { start A; }\n</code></pre> <p>The connection between extension point and extension is performed by an additional grammar rule in the grammar <code>G</code>. This can be realized in one of the following ways each one of which has its own advantages and disadvantages:</p> <ol> <li>Embedding through overriding of extension rule and implementing extension point:<ul> <li><code>E implements I;</code></li> <li>Advantage: simple embedding rule</li> <li>Disadvantage: does not work in combination with inheritance of extension rule</li> <li>Should therefore only be used, if <code>E</code> is not used anywhere else (= in not other language that is potentially used in combination with this language) </li> </ul> </li> <li>Embedding through extending extension rule and implementing extension point rule:<ul> <li><code>IE extends E implements I = \"something\";</code></li> <li>Advantage: does work in combination with inheritance of extension rule</li> <li>Disadvantage: cloning of RHS of the extension rule can produce inconsistencies if <code>E</code> is changed</li> <li>Can be used if it is assured that this rule is adjusted whenever <code>E</code> is changed, e.g., by assuming that <code>E</code> is not modified at all</li> </ul> </li> <li>Embedding through implementing extension point rule and providing extension on right-hand side:<ul> <li><code>IE implements I = E;</code></li> <li>Advantage: does work in combination with inheritance of extension rule</li> <li>Disadvantage: introduces new level of indirection in the AST that invalidates the check whether the required abstract syntax (RHS of interface nonterminal) is present</li> <li>Should therefore not be used, if the interface has a right-hand side</li> </ul> </li> <li>Defined by: AB</li> </ol>"},{"location":"docs/BestPractices-Language-Design/#recurring-language-components","title":"Recurring Language Components","text":""},{"location":"docs/BestPractices-Language-Design/#the-import-statements","title":"The import statements","text":"<ul> <li>Many models depend on other models from which they receive symbols they can rely on.   To define this kind of dependencies using import statements is convenient and well    known (e.g., from Java). We thus suggest to use the import statement in the spirit of Java.</li> <li><code>import aName</code> at the first sight means that a specific class with the qualified   name <code>aName</code> is used. In reality, however, Java has a very convenient convention   that class <code>aName</code> is always defined in the artifact (i.e. file) with the same name    <code>aName.java</code> and the needed symbol table is part of <code>aName.class</code>. So an import    statement actually locates an artifact.</li> <li>As a consequence, we suggest:<ul> <li><code>import aModelName</code> refers to an artifact with name <code>aModelName</code> -- regardless   which kind of model is defined there.</li> <li>All the symbols exported by the artifact <code>aModelName</code> are imported when using    the import statement <code>import aModelName</code>. </li> <li>The imported artifact provides the desired symbols, typically stored through    an earlier tool execution in a symbol file <code>aModelName.sym</code>.</li> <li>The symbol file may have specific extensions, such as <code>autsym</code>or <code>cdsym</code>.</li> <li>Selective import (known from Java), such as <code>import aName.innerClass</code>    should be possible, but currently no such showcase has been made yet (beyond Java).</li> <li>The import statement is only used to make symbols available in their simple form.   It is usually    not intended to explicate a single dependency, e.g., a configuration model   that depends on exactly one base model. Like in Java, where you import an    artifact and then still explicitly extend the contained class.</li> </ul> </li> <li>It is methodically of interest to store at most one artifact with the same   qualified name (although it is not per se forbidden to have more).    Java then also uses the first occurring class in its classpath only.</li> <li>In a heterogeneous language setting, it may be necessary to map symbols   from a source to a target form (e.g., state symbols to Java enum constants or state    pattern classes). There are three main options for this task:<ol> <li>Store in the desired target symbol form upon creating the symbol file.    Has some problems: (1) increases dependencies between tools,     (2) potentially several files need to be stored.</li> <li>Adapt the imported symbols upon loading (recommended).</li> <li>Use an explicit transformation tool between the two model processing tools    to map the initially stored symbol file to the desired format.</li> </ol> </li> </ul>"},{"location":"docs/BestPractices-Language-Design/#version-number-in-language-variants","title":"Version number in language variants","text":"<ul> <li>As an important rule:<ul> <li>Do not include version numbers in the DSL explicitly.</li> </ul> </li> <li>The reason is that whenever you do a tooling update, all the models that have    been defined before are suddenly not valid anymore and have to be adapted.   Java has very carefully ensured that updates in the language are extensions only    and thus all old Java files are still validated with new Java compilers    (with the one exception: new keyword <code>assert</code>).</li> <li>If your language is still very volatile against disruptive changes,    it may be an option at the beginning, but should be avoided with the first real release.</li> <li>It is a burden to manage version numbers and downward compatibility through    all the versioning, especially if language components evolve with their own    versioning.</li> <li>MontiCore provides a theory of conservative extension to avoid   explicit version controlling within the language.</li> <li>And if needed: MontiCore and their tools provide extensive checks of    wellformedness (i.e.   context conditions), on each update a fully automated consistency check    of all existing models   should be easily establishable.</li> </ul>"},{"location":"docs/BestPractices-Language-Design/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BestPractices-Symbols-Scopes/","title":"BestPractices Symbols Scopes","text":""},{"location":"docs/BestPractices-Symbols-Scopes/#monticore-best-practices-symbols-scopes-symboltables","title":"MontiCore Best Practices - Symbols, Scopes, Symboltables","text":"<p>MontiCore provides a number of options to design  languages, access and modify the abstract syntax tree, and produce output files.</p> <p>The newest MontiCore release gives powerful capabilities to define and  use symbols. Symbols, scopes, and symboltables are somewhat complex  to design, but powerful in their use.</p>"},{"location":"docs/BestPractices-Symbols-Scopes/#designing-symbols-scopes-and-symboltables","title":"Designing Symbols, Scopes and SymbolTables","text":""},{"location":"docs/BestPractices-Symbols-Scopes/#how-to-define-a-symbol-usage-without-a-given-symbol-definition","title":"How to define a Symbol Usage without a given Symbol Definition","text":"<pre><code>grammar E { \n  A = Name@S; \n  symbol S = Name; \n}\n</code></pre> <ul> <li>If you want to use a special form of symbol that shall neither be defined    inside the grammar of a language, nor shall it be imported.</li> <li>We can define symbols of kind <code>S</code> in the grammar in a grammar rule that    is never reached by the parser from the start production.   Through this, MontiCore generates:</li> <li>symbol table infrastructure for handling <code>S</code> symbols</li> <li>symbol table infrastructure for resolving these in <code>E</code> scopes, and </li> <li>integration of <code>S</code> symbols with the AST of <code>A</code>.</li> <li>However, <code>S</code> symbols are not automatically instantiated.    This has to be described manually, e.g., by extending the symbol table    creator or via providing an adapter translating a foreign symbol into an <code>S</code> symbol.</li> <li>This can be used, e.g., in these scenarios: </li> <li>A name of a certain kind is introduced automatically the first time it occurs      in a model. If it occurs more than once, all other occurrences of the name      do not introduce new symbols. (e.g., this happens with features in FDs,     and works because features do not have a body.)</li> <li>A name in a language <code>E</code> refers to a named element of another language,      but the language shall be decoupled from <code>E</code>.      Therefore, <code>E</code> introduces a symbol <code>S</code> and an adapter maps other, foreign      symbols to <code>S</code> symbols.</li> <li>Defined by: AB, BR</li> </ul>"},{"location":"docs/BestPractices-Symbols-Scopes/#symbol-definition-prepared-for-reuse","title":"Symbol Definition prepared for Reuse","text":"<p><pre><code>grammar E { \n  symbol Bla = \"bla\" Name AnotherNT; \n}\n</code></pre> * has the effect that three things are defined: (a) concrete syntax,    abstract syntax with (b) AST element <code>ASTBla</code>   and (c) a symbol <code>BlaSymbol</code>. * Reuse of the symbol <code>BlaSymbol</code> currently only works together with a reuse   of the syntax too, i.e.</p> <p><pre><code>grammar F extends E { \n  Blubb extends Bla = \"blubb\" Name; \n}\n</code></pre>   would for example be illegal, because the conservative extension paradigm    enforces <code>AnotherNT</code> to be included in <code>Blubb</code> as well.  * To allow individual reuse of symbol <code>BlaSymbol</code> we recommend to   restructure its definition into an interface that does not preclude   create syntax and only a minimal constraint on the abstract syntax:</p> <pre><code>grammar E { \n  symbol interface Bla = Name; \n  Bla2 implements Bla = \"bla\" Name AnotherNT; \n}\ngrammar F extends E { \n  Blubb implements Bla = \"blubb\" Name; \n}\n</code></pre> <ul> <li>Please note that MontiCore allows that a nonterminal implements   multiple interfaces. However, only one of them may carry the <code>symbol</code>    keyboard property, because the newly defined symbol then is also    a subclass of the inherited symbol (in Java).</li> </ul>"},{"location":"docs/BestPractices-Symbols-Scopes/#loading-deserializing-symbols-of-unknown-symbol-kinds","title":"Loading (DeSerializing) Symbols of Unknown Symbol Kinds","text":"<p>Specific languages (e.g., <code>CD</code>) may provide specific symbols, of specific kinds. A symbol import of these symbols into another language <code>L1</code> has to cope with  potentially unknown kinds of symbols, even though the super kind could be known.  E.g., <code>TypeSymbol</code> is extended by <code>CDTypeSymbol</code> providing e.g., additional  visibility information. Upon loading an <code>CD</code>-symboltable into an <code>L1</code>-tool it may be that neither AST-class <code>CDTypeSymbol</code> nor superclass information about  it is available. But, the symbols of the unknown kind should (and can) be loaded as symbols of a more abstract kind. </p> <p>Loading the symbols of the unknown kind as symbols of the specific known kind is possible in multiple ways. Options would be    1. adapt the <code>L1</code>-tool to know about the new symbols, or    2. the <code>L1</code>-tool has been written in such a way that new classes can be added       through appropriate class loading, or    3. the <code>L1</code>-tool is configurable in handling unknown symbol kinds as explained below.</p>"},{"location":"docs/BestPractices-Symbols-Scopes/#loading-symbols-as-symbols-of-another-kind","title":"Loading Symbols as Symbols of Another Kind","text":"<p>Symbols of an unknown source kind (e.g., <code>CDTypeSymbol</code>) may easily be loaded as  symbols of a known kind (e.g., <code>TypeSymbol</code>) when the source kind provides all mandatory attributes (i.e. those without defaults) of the symbol class. This is especially the case if the source kind is a subclass of the known  kind.</p> <p>This behavior can be configured in the global scope by calling the method <code>putSymbolDeser(String, ISymbolDeser)</code>, where the unknown source kind is encoded as string (here: <code>CDTypeSymbol</code>) and is mapped to an appropriate DeSer (here for <code>TypeSymbol</code>).  For instance the call would be  <code>putSymbolDeSer(\"de.monticore.cdbasis._symboltable.CDTypeSymbol\", new TypeSymbolDeSer())</code>.</p> <p>Because the global scope is a singleton, this configuration can be e.g., called in or shortly  after constructing the global scope. However, this would still encode the name of the unknown symbol kind in the <code>L1</code>-tool, although it prevents any actual dependency to the imported tools.</p> <p>The method can also be called from a CLI to dynamically configure the deserialization, e.g., the information be fed to the <code>L1</code>-tool via parameters, e.g., like <pre><code>  java L2Tool --typeSymbol=de.monticore.cdbasis._symboltable.CDTypeSymbol\n              --functionSymbol=de.monticore.cdbasis._symboltable.CDMethodSymbol\n</code></pre></p>"},{"location":"docs/BestPractices-Symbols-Scopes/#converting-stored-symbol-tables","title":"Converting Stored Symbol Tables","text":"<p>If the unknown symbol kinds do have different attributes or some extra information needs to be calculated in the new symbols, then either the <code>L1</code>-tool needs to be adapted or the serialized symbol table can be transformed to another  serialized symbol table where the kind information is transformed as required as an intermediate step between the tools providing and reading the symbol tables.</p>"},{"location":"docs/BestPractices-Symbols-Scopes/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/","title":"BestPractices Syntax Design","text":""},{"location":"docs/BestPractices-Syntax-Design/#monticore-best-practices-concrete-and-abstract-syntax","title":"MontiCore Best Practices - Concrete and Abstract Syntax","text":"<p>MontiCore provides a number of options to design  languages, access and modify the abstract syntax tree, and produce output files.</p> <p>This (currently unsorted and evolving) list of practices discusses solutions  that we identified and applied as well as alternatives and their specific  advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first.</p> <p>This file is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the  MontiCore handbook. Some of the best practices here will also be incorporated in the next version of the reference manual.</p>"},{"location":"docs/BestPractices-Syntax-Design/#designing-concrete-and-abstract-syntax","title":"Designing Concrete and Abstract Syntax","text":""},{"location":"docs/BestPractices-Syntax-Design/#specific-keywords-that-shall-be-used-as-normal-names-elsewhere","title":"Specific keywords that shall be used as normal names elsewhere","text":"<ul> <li><code>A = \"foo\" B</code> introduces <code>foo</code> as a keyword that cannot be used as an ordinary    (variable) name anymore. To prevent that we may use:</li> <li><code>A = key(\"foo\") B</code> instead, which introduces <code>foo</code> only at that specific point.</li> <li>In general, we use all Java keywords as permanent, but abstain from other   permanent keywords, especially if they are only used for a specific purpose in a composable   sublanguage, like <code>in</code> in the OCL.</li> <li>Defined by: BR</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#complex-token-clashing-with-other-uses-of-sub-tokens","title":"Complex Token clashing with other uses of sub-tokens","text":"<ul> <li>For example <code>&lt;-</code> is supposed to be used as arrow, but in an expression   <code>3&lt;-10</code> is also syntactically allowed.</li> <li>The problem: as soon as <code>\"&lt;-\"</code> is defined as a token in any part of the   current or any extended grammars, the expression <code>3&lt;-10</code> would not be   parsed as <code>3 &lt; -10</code> anymore.</li> <li>Solutions:  <ol> <li>We might decompose the token to <code>\"&lt;\" \"-\"</code> which in its consequence   means that we put more burden to the context-free parser and less to the   regular scanner. (\"scannerless parsing\")  <ul> <li>Drawback: spaces would now be allowed inbetween.</li> </ul> </li> <li>Decompose the token to <code>{noSpace(2)}? \"&lt;\" \"-\"</code>. This (slightly  hacking approach) prevents spaces between two tokens.  </li> </ol> </li> <li>The challenge: when designing a language component, we don't know yet   what further uses will bring. This may include sub-tokens to come up   with new interactions. This would require an (already defined) grammar    with the complex token to be adapted afterwards (and thus conflict    with the library idea). </li> <li>Remark: A forthcoming enhancement will provide an improved solution,   keeping parsing efficiency and compositionality of grammars.</li> <li>Defined by: BR</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#extension-forms-in-a-component-grammar","title":"Extension forms in a  component grammar","text":"<p>A component grammar is meant for extension. MontiCore therefore provides five(!)  mechanisms that can be used when a sub-grammar shall extend a super-grammar.  The solutions are briefly discussed here:  </p>"},{"location":"docs/BestPractices-Syntax-Design/#1-interface-in-the-super-grammar","title":"1. Interface in the super-grammar","text":"<ul> <li>Introduce an interface and allow building of sub-nonterminals in sub-grammars. <pre><code>component grammar A {  \n  interface X;\n  N = \"bla\" X \"blubb\";\n}\ngrammar B extends A {\n  Y implements X = \"specific\" \"thing\"\n}\n</code></pre></li> <li>Advantage: Multiple extensions are possible at the same time.   An NT <code>Y</code> can also implement multiple interfaces (like in Java). </li> <li>Disadvantage: the designer of <code>A</code> explicitly has to design the hole   (extension point) <code>X</code> and add it into the production.  </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#2-overriding-empty-nonterminal-from-the-super-grammar","title":"2. Overriding (empty) nonterminal from the super-grammar","text":"<ul> <li>Use a normal nonterminal <code>X</code> and override it in a sub-grammar. <pre><code>component grammar A {  \n  X = \"\";\n  N = \"bla\" X \"blubb\";\n}\ngrammar B extends A {\n  @Override\n  X = \"my\" \"thing\";\n}\n</code></pre></li> <li>Advantage: Default implementation \"\" exists, no explicit filling needed.</li> <li>Disadvantage: <ol> <li>The designer of <code>A</code> explicitly has to design the hole (extension point) <code>X</code>     and inject it into other places. </li> <li>Only one overriding alternative possible (i.e. multiple overriding in      subgrammars are allowed, but only the most specific resides).  </li> </ol> </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#3-extending-nonterminal-from-the-super-grammar","title":"3. Extending nonterminal from the super-grammar.","text":"<ul> <li>Use an empty normal nonterminal <code>X</code> and extend it in a sub-grammar. <pre><code>component grammar A {  \n  X = ;\n  N = \"bla\" X \"blubb\";\n}\ngrammar B extends A {\n  Y extends X = \"this\";\n}\n</code></pre></li> <li>Advantage: Default implementation \"\" exists, no explicit filling needed.</li> <li>Disadvantage:          The designer of <code>A</code> explicitly has to design the hole (extension point) <code>X</code>          and inject it into other places. </li> <li>Care: Extension still allows the (empty) alternative <code>X</code>.  </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#4-using-external-nonterminals-in-the-super-grammar","title":"4. Using <code>external</code> nonterminals in the super-grammar.","text":"<ul> <li> <p>Mark nonterminal <code>X</code> as external. <pre><code>component grammar A {  \n  external X;\n  N = \"bla\" X \"blubb\";\n}\ngrammar B extends A {\n  X = \"your\";\n}\n</code></pre></p> </li> <li> <p>Advantage: Explicitely marks a nonterminal as hole (extension point) in the grammar. </p> <ul> <li>Please observe that interface terminals may or not may be meant to be   extended in sub-grammars. <code>external</code> is clearer here.</li> </ul> </li> <li>Disadvantage: <ol> <li>Leads to more objects in the AST. Both classes <code>a.X</code> and <code>b.X</code> are     instantiated and <code>a.X</code> only links to <code>b.X</code>.</li> <li>Only one filling of the <code>hole</code> is possible.</li> </ol> </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#5-overriding-the-whole-production","title":"5. Overriding the whole production.","text":"<ul> <li>If you don't want to add a hole at any possible place of extension: <pre><code>component grammar A {  \n  N = \"bla\" \"blubb\";\n}\ngrammar B extends A {\n  @Override\n  N = \"bla\" \"my\" \"blubb\" \"now\";\n}\n</code></pre></li> <li>Advantage: Compact definition. No \"framework thinking\" needed (no need   to forecast all potential extension points)</li> <li>Disadvantage:  <ol> <li>The entire production is overriden (some redundancy). </li> <li>Only one overriding alternative possible.  </li> </ol> </li> <li>Combinations are possible. Dependent on the anticipated forms of    adaptations option 1, 2, 3 and 5 are in use.</li> <li>Defined by: BR</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#avoid-empty-nonterminals-if-body-is-known","title":"Avoid empty nonterminals (if body is known)","text":"<ul> <li> <p>From the two variants: <pre><code>A = \"bla\" B? C*;\nB = \"B's body\" ;\nC = \"C's body\" ;\n</code></pre>   and <pre><code>A = \"bla\" B C;\nB = (\"B's body\")? ;\nC = (\"C's body\")* ;\n</code></pre>   we generally prefer the first one, i.e. add multiplicities when    using a nonterminal.   </p> </li> <li> <p>This is a matter of taste, but useful to keep this consistent.  </p> </li> <li>Sometimes exceptions are useful.  </li> <li>Defined by: SVa, BR  </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-1","title":"Avoid complex tokens (1)","text":"<ul> <li>The token definitions can only define regular expressions.   Furthermore, the token parser (i.e. the lexer) does not consider backtracking.</li> <li>If combinations of characters may be split into several token sequences   this leads to problems. E.g. in <code>3-2</code> and <code>(-2)</code> the <code>-</code> has different roles.   Unfortunately these problems also occur when composing languages   that make excessive use of (conflicting) token definitions.</li> <li>Solution: instead of defining a complex token like <pre><code>  token NegativeNat = \"-\" Digits;\n</code></pre>   we split the token and allow individual parsing into nonterminals: <pre><code>  NegativeNat = negative:[\"-\"] Digits {noSpace()}? \n</code></pre>   (where we assume <code>Digits</code> is a given token).</li> <li> <p>As a workaround, we use the semantic predicate <code>{noSpace()}?</code> that ensures    that between the two last processed token there is no space inbetween.    If one of the tokens is optional we have to split the alternatives: <pre><code>SignedNatLiteral = \n        (negative:[\"-\"]) Digits {noSpace()}? |\n                         Digits;  \n</code></pre></p> </li> <li> <p>Adding a handcoded function like <code>getValue()</code> via <code>astrule</code> or the   TOP-mechanism allows to use <code>SignedNatLiteral</code> like a token.</p> </li> <li>Scannerless parsing is a principle where the tokens are reduced to simple   characters (or character classes, such as <code>[a-z]</code>). Scannerless parsing   generally avoids this kinds of problems, but is way slower.   This kind of solution tries to mediate between the two extremes benefitting    from both approaches.</li> <li>Defined by: MB, in: <code>MCCommonLiterals.mc4</code> and other literals grammars.</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-2","title":"Avoid complex tokens (2)","text":"<ul> <li>Same general problem. In language composition conflicting tokens may lead to issues.  </li> <li>For example Java allows <code>42.</code> as a literal of type float.    UML allows to define cardinalities like <code>[42..44]</code>. Composition clashes.</li> <li> <p>Solution: In a Java sublanguage we split the token: <pre><code>SignedBasicFloatLiteral =\n   ... \n   | Digits \".\" {noSpace()}? ... ;\n</code></pre></p> </li> <li> <p>This will ensure that <code>[42..44]</code> will be parsed like <code>[ 42 .. 44 ]</code>    in a language composition as well.</p> </li> <li>It generally seems that overly complex composed tokens may lead to issues    especially if the language allows compact models. Suboptimal tokens may be e.g.   <code>\"[[\"</code> (vs. nested lists), or   <code>\"&lt;-\"</code> (vs. <code>3 &lt; -2</code>).</li> <li>Defined by: MC team.</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#how-to-define-keyword-enumerations","title":"How to define keyword enumerations","text":"<ul> <li>A finite set of keyword-based alternatives can be defined in several forms:  </li> <li>Standard three keywords act as alternative: <pre><code>N = ([\"public\"] | [\"protected\"] | [\"private\"]) ;\n</code></pre></li> <li>Effects: <ol> <li>not extensible without overriding and repetition</li> <li>introduces boolean flags, where only one can be true at a time</li> </ol> </li> <li>Use an enumeration nonterminal <pre><code>enumeration E = \"public\" | \"protected\" | \"private\" ;\nN = E ;\n</code></pre></li> <li>Effects: <ol> <li>not extensible </li> </ol> </li> <li>Use an interface and subclasses with almost empty body: <pre><code>interface E ;\nP1 implements E = \"public\"    ;\nP2 implements E = \"protected\" ;\nP3 implements E = \"private\"   ;\nN = E ;\n</code></pre></li> <li>Effects: <ol> <li>very extensible in various ways (even beyond mere keywords) </li> <li>visitor can easily address the keywords (i.e. by <code>visit(P1)</code> ...)</li> <li>Disadvantage: Clumsy notation and visitors are always needed.</li> </ol> </li> <li>Defined by: SVa, BR.</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#common-ast-access-to-syntactically-similar-nonterminals","title":"Common AST-Access to Syntactically Similar Nonterminals","text":"<ul> <li> <p>Sometimes the following occurs (e.g. in associations of CDs or    interactions of SD): <pre><code>A = X Y Z;\nB = Z Y X;\n</code></pre></p> </li> <li> <p>The concrete syntax differs (in order), but the syntactic concepts are      the same. </p> </li> <li> <p>To allow common access, a common interface nonterminal is introduced   that is not used in the grammar directly.    This doesn't change the concrete syntax but allows common AST access: <pre><code>interface F = X Y Z;      // order is irrelevant\nA implements F = X Y Z;\nB implements F = Z Y X;\n</code></pre></p> </li> <li> <p>Defined by: BR.</p> </li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#how-and-when-to-use-names-for-nonterminals","title":"How and when to use Names for Nonterminals","text":"<ul> <li>Normally names like <code>expr:Expr</code>can be avoided which makes a grammar easier to read   and more concise, i.e. <code>Expr</code> alone has the same effect.</li> <li>There may be two reasons to use a name:<ol> <li>Nonterminal <code>X</code> occurs several times and we want to distinguish:   <code>left:Expr \"*\" right:Expr</code></li> <li>We can also use the name to describe the purpose of the nonterminal, i.e. <pre><code> MyVariable implements Variable = Name \"=\" initial:Expression;\n</code></pre> vs: <pre><code> MyParameter implements Variable = Name \"=\" default:Expression;\n</code></pre></li> </ol> </li> <li>Defined by: BR.</li> </ul>"},{"location":"docs/BestPractices-Syntax-Design/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BestPractices/","title":"Best Practices","text":""},{"location":"docs/BestPractices/#monticore-best-practices-a-guide-for-small-solutions","title":"MontiCore Best Practices - A Guide For Small Solutions","text":"<p>MontiCore provides a number of options to design  languages, access and modify the abstract syntax tree, and produce output files.</p> <p>This (currently unsorted and evolving) list of practices discusses solutions  that we identified and applied as well as alternatives and their specific  advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first.</p> <p>The list is subdivided into several files tackling the different  language design areas.</p> <p>The list is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the  MontiCore handbook. Some of the best practices here will also be incorporated in the next version of the handbook.</p> <ul> <li> <p>Designing A Language     includes: Language Design in the Large</p> </li> <li> <p>Designing Concrete and Abstract Syntax</p> </li> <li> <p>Handling Errors 0x..... </p> </li> <li> <p>Designing Symbols, Scopes and SymbolTables </p> </li> <li> <p>Designing Tools for Command Line Interfaces </p> </li> <li> <p>Generating Code with Templates (no practice defined here yet) </p> </li> </ul>"},{"location":"docs/BestPractices/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/BuildMontiCore/","title":"BuildMontiCore","text":"<p> <p></p>"},{"location":"docs/BuildMontiCore/#monticore-language-workbench-and-development-tool-framework","title":"MontiCore - Language Workbench And Development Tool Framework","text":"<ul> <li>MontiCore Handbook.</li> </ul>"},{"location":"docs/BuildMontiCore/#general-disclaimer","title":"General disclaimer","text":"<p>(Repeated from the BSD 3 Clause license): </p> <p>This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services, loss of use, data, or profits, or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.</p>"},{"location":"docs/BuildMontiCore/#included-software","title":"Included Software","text":"<p>This product includes the following software: * AntLR * FreeMarker</p>"},{"location":"docs/BuildMontiCore/#contribution","title":"Contribution","text":"<p>When you want to contribute: Please make sure that your complete workspace only  uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows, you should  configure git to not automatically replace LF with CRLF during checkout  by executing the following configuration: </p> <pre><code>git config --global core.autocrlf input\n</code></pre>"},{"location":"docs/BuildMontiCore/#build-monticore","title":"Build MontiCore","text":"<p>MontiCore is currently built using Gradle. </p> <p>Please note that from the top level build script, not everything is built and  all tests executed. It is a deliberate decision, to exclude some of the longer  lasting tasks.</p> <ul> <li>build the productive code (including the unit tests, ~8 min)</li> <li><code>gradle buildMC</code></li> <li>skipping the unit tests: <code>gradle assembleMC</code></li> <li>run integration tests (which are not included in the unit tests, ~30 min)   </li> <li>all integration tests<ul> <li><code>gradle testIT</code></li> </ul> </li> <li>Integration tests of the generator: <ul> <li><code>gradle -p monticore-test/it build</code></li> </ul> </li> <li>EMF Integration tests of the generator (only test collection not included in <code>testIt</code>): <ul> <li><code>gradle -p monticore-test/it build -PbuildProfile=emf</code></li> </ul> </li> <li>Experiments (from the Handbook) as integration tests:<ul> <li><code>gradle -p monticore-test/01.experiments build</code> and </li> <li><code>gradle -p monticore-test/02.experiments build</code></li> </ul> </li> <li>Grammar integration tests:<ul> <li><code>gradle -p monticore-test/monticore-grammar-it build</code></li> </ul> </li> <li>clean:</li> <li>call <code>gradle clean</code></li> <li>cleaning integration tests:<ul> <li>using gradle <code>gradle clean</code> within the corresponding subproject (see above)</li> </ul> </li> </ul>"},{"location":"docs/BuildMontiCore/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/CI/","title":"CI","text":"<p>The CI is (as of 2024) partially run via GitHub actions and for private projects, on the RWTH GitLab.</p>"},{"location":"docs/CI/#workflow-gradle_mcyml","title":"Workflow gradle_mc.yml","text":"<p>Uses Gradle to test &amp; build the project.</p>"},{"location":"docs/CI/#trigger-montiverse-trigger_montiverseyml","title":"Trigger MontiVerse trigger_montiverse.yml","text":"<p>The MontiVerse is a collection of (internal) language projects. Builds the projects within the MontiVerse against the changes.</p>"},{"location":"docs/CI/#deploy-snapshot-deploy_snapshot_mcyml","title":"Deploy Snapshot deploy_snapshot_mc.yml","text":"<p>Publishes the snapshot to GitHub packages (using <code>$GITHUB_REPOSITORY</code>) and the se-nexus.</p>"},{"location":"docs/CI/#deploy-release-deploy_release_mcyml","title":"Deploy Release deploy_release_mc.yml","text":"<p>Publishes the release to GitHub packages (using <code>$GITHUB_REPOSITORY</code>) and the se-nexus. In addition, the tutorial tar.gz is packaged and added as an artifact (TODO).</p>"},{"location":"docs/CI/#secrets","title":"Secrets","text":"Name Description Workflows SE_NEXUS_USER deploy_snapshot_mc, deploy_release_mc SE_NEXUS_PASSWORD deploy_snapshot_mc, deploy_release_mc DOWNSTREAM_PAT Personal access token to trigger downstream projects on GitHub (fine grained: content: write, actions: write) deploy_snapshot_mc DOWNSTREAM_GITLAB_PAT Personal access token to trigger downstream projects on GitLab (not required for now) deploy_snapshot_mc GITLAB_TOKEN Checks out the monticore-pygments-highlighting project from GitLab prepare_pages MONTIVERSE_TRIGGER_TOKEN Triggers the MontiVerse IT-Pipeline on GitLab more gradle_mc MONTIVERSE_ACCESS_TOKEN Reads the MontiVerse IT-Pipeline status from GitLab more gradle_mc"},{"location":"docs/DevelopedLanguages/","title":"Languages and Language Components","text":""},{"location":"docs/DevelopedLanguages/#languages-and-language-components-developed-with-monticore","title":"Languages and Language Components Developed with MontiCore","text":"<p>The MontiCore language workbench has been under development for a while  already and of course has been used by our group to develop  many languages. Not all of those languages are publicly  available and some of these languages are equipped with tools based  on MontiCore 5. </p> <p>Many of these languages are composed of sublanguages and  thus potentially build on each other. The available languages can be used as is, but  also be adapted, extended and further composed. </p> <p>Please also have a look at our literature references for further  information on many of the languages. </p>"},{"location":"docs/DevelopedLanguages/#information-about-languages-and-language-components","title":"Information about Languages and Language Components","text":"<ul> <li> <p>MontiCore Handbook.    The handbook describes how to use MontiCore as an out-of-the-box     language workbench), but also as a grey box tooling framework.    It thus also gives an overview over a number of core mechanisms of MontiCore.</p> </li> <li> <p>List of MontiCore core Language Components.    MontiCore concentrates on reuse. It therefore offers a set of    predefined language components where the main artifact is usually a    component grammar. Reusing these language components allows     language developers to define their own language as a    composition of reusable assets efficiently. Reusable assets describe among others     several sets of literals, expressions and types, which are relatively     freely composable.</p> </li> <li> <p>List of languages.    This is a another list of newer MontiCore    languages that can be used out of the box or also composed.     Many of them already are rather stable, but some of them also undergo a    lively development and enhancement.     These complete languages are usually composed of a number of language    components.</p> </li> <li> <p>MontiCore topic list     Describes various research topics which MontiCore builds on or    where MontiCore has been used as foundation.</p> </li> </ul>"},{"location":"docs/DevelopedLanguages/#github-available-languages","title":"Github Available Languages","text":"<ul> <li>Class Diagrams</li> <li>Sequence Diagrams</li> <li>JSON</li> <li>Feature Diagrams</li> <li>SI Units</li> <li>automaton</li> <li>EmbeddedMontiArc</li> <li>Object Diagrams</li> </ul>"},{"location":"docs/DevelopedLanguages/#further-languages-eg-used-in-scientific-and-industrial-projects","title":"Further Languages (e.g. used in scientific and industrial projects)","text":"<ul> <li> <p>MontiArc ADL is an architectural definition language for      component and connector models with enhanced connection facilities,      hierarchical decomposition etc. and provides a simulator      [HRR12,BHH+17,Wor16,Hab16].</p> </li> <li> <p>MontiArcAutomaton ADL is an extension of the      architectural definition language MontiArc using automata to describe     behavior.      Some applications e.g. are of robotics, production, or InternetOfThings.     [BKRW17a,HKR+16,BRW16a,Wor16].</p> </li> <li> <p>UML/P is a derivation from UML, especially suited for agile  development. See language definition and usage method in  [Rum17,Rum16,Sch12]. </p> <ul> <li>UML/P Class Diagrams for data structures</li> <li>UML/P Object Diagrams for exemplaric situations: usable for     constructive development as well as testing</li> <li>OCL/P as Java-variant of the OCL with a nice logic,      set-comprehension etc.</li> <li>UML/P Statecharts for behavior</li> <li>UML/P Sequence Diagrams for interaction</li> <li>Activity Diagrams for workflows and requirements      (an extension to the books)</li> </ul> </li> <li> <p>Delta-MontiArc [HRRS12,HKR+11,HRRS11]   is a DSL for expressing deltas on MontiArc component definitions  which allows to model software product lines in a bottom up way.</p> </li> <li> <p>MontiArcHV [HRR+11]   allows specifying component variability fully integrated within the   component hierarchy located at variation points in component definitions.</p> </li> <li> <p>Java as full language as well as source for Java expressions,   statements, attribute or method definitions.</p> </li> <li> <p>FeatureDSL is a DSL for feature diagrams in software product line   approaches.</p> </li> <li> <p>DeltaCD is a DSL for expressing deltas on class diagrams  which allows to model software product lines in a bottom up way</p> </li> <li> <p>Aerospace Constraint Specification Language is a DSL used to   specify critical situations in an airspace including airplanes,   weather, flight conditions and much more. [ZPK+11]</p> </li> <li> <p>clArc DSL Family: [PR13]</p> <ul> <li>Cloud Architecture Description Language: used to model of          architectures of cloud-based systems; based on MontiArc.</li> <li>Target Description Language: used to model the infrastructure          architecture of cloud-based systems.</li> <li>Mapping Description Language: used to model deployments          between software and infrastructure architectures.</li> <li>Architecture Scenario Description Language: used to model          scenario-based test cases for software architectures.</li> </ul> </li> <li> <p>I/O-TestDSL         for the definition of stream-based, input-output          related black-box tests for architecture definition languages          like MontiArc.</p> </li> <li> <p>LightRocks, a modelling language for robotic assembly processes.</p> </li> <li> <p>cdViews is a DSL used to model partial views on class diagrams</p> </li> <li> <p>RBAC for Role-Based Access Control in enterprise information systems.</p> </li> <li> <p>MontiWis [[RR13,Rei16]]     is a family of DSLs for the model-based, generative      development of web information systems among others based on      class diagrams, activity diagrams and views.</p> </li> <li> <p>HQL: Hibernate Query Language that maps to hibernate based      executions.</p> </li> <li> <p>SQL the well known DB query language; used for embedding      e.g. into other languages.</p> </li> <li> <p>XML the basic infrastructure for all XML dialects</p> </li> <li> <p>CarOLO DSLs for autonomic driving. This among others      contains a DSL for defining road scenarios with moving vehicles      as well a obstacles suited for laser, lidar, radar and camera      sensors. This languages are part of the Darpa Urban Challenge 2007.     [BR12b,BR12,Ber10,BR09].</p> </li> <li> <p>ProcEd a Web-based Editing Solution for Domain-Specific      Process-Engineering     [BGR09].</p> </li> <li> <p>MontiWeb a modular development approach for      Web Information Systems (which was later succeeded by MontiWIS)     [DRRS09].</p> </li> <li> <p>C++ and its sublanguages for expressions, statements and      definitions (but no generic types, no defines).</p> </li> <li> <p>MontiCore itself uses a family of DSLs for the definition of      DSLs, i.e., their grammars. [HR17]</p> </li> </ul>"},{"location":"docs/DevelopedLanguages/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/Download/","title":"Downloads","text":"<p>The following tools for MontiCore can be used from the command line and  thus e.g. well be embedded in scripting. Their languages as well as  related tooling are currently available for download:</p> Artifact Description Download MontiCore Language Workbench Meta-tool for processing grammars and producing tool code: model-loading, model-management, AST, AST-building, AST-traversal, ccontext condition check, type check, symbol management, scope management, generator workflows, template engine, etc. Download JAR MontiCore Runtime MontiCore's runtime library. Download JAR Automaton Example Project Example language definition project that can be used with MontiCore. Download JAR Automaton Example Project in Gradle Example language definition project that can be used with MontiCore's Gradle integration. Download JAR CD Tool Parser, well-formedness checker, pretty printer, semantic and syntactic differencing, merging for the MontiCore Class Diagrams. Download JAR FACT Tool Finds valid configurations for MontiCore Feature Diagrams, completes incomplete feature configurations and checks validity of complete feature configurations. Download JAR MLC Tool Modelling and maintaining architectural drift in language components (especially usable in MontiCore language definitions). Download JAR OCL Tool Parser, well-formedness checker, pretty printer for the MontiCore Object Constraint Language. Download JAR OD4Data Tool Parser, well-formedness checker, pretty printer for the MontiCore Object Diagram language describing data. Download JAR OD4Report Tool Parser, well-formedness checker, pretty printer for the extended MontiCore Object Diagram language, in the version which focuses on generated reports and artifact-based analyses. Download JAR SD4Development Tool Parser, well-formedness checker, pretty printer, semantic differencing for the MontiCore Sequence Diagram language. Download JAR Statecharts Tool Parser, well-formedness checker, pretty printer for MontiCore Statechart Models, which are a rich variant of automata. Download JAR SysML v2 Tool Parser and well-formedness checker for SysML v2 models. Download JAR JSON Tool Parser, well-formedness checker, pretty printer, object diagram exporter for the MontiCore JSON language using the command line. Download JAR XML Tool Parser and pretty printer for the MontiCore XML language. Download JAR <p>Please note the MontiCore 3-Level License of these tools.</p>"},{"location":"docs/Download/#further-information","title":"Further Information","text":"<ul> <li>see also MontiCore handbook</li> <li>MontiCore Reference Languages - Languages Built Using MontiCore</li> <li>Build MontiCore - How to Build MontiCore</li> <li>Getting Started - How to start using MontiCore</li> <li>Changelog - Release Notes</li> <li>FAQ - FAQ </li> <li>Licenses - MontiCore 3-Level License</li> <li>Project root: MontiCore @github</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> </ul>"},{"location":"docs/GettingStarted/","title":"Getting Started","text":""},{"location":"docs/GettingStarted/#getting-started-with-monticore","title":"Getting Started with MontiCore","text":"<p>This page describes the technical installation and usage of MontiCore for language developers. This page further inspects a simple example grammar and the Java classes and other artifacts generated from this grammar. After installing MontiCore as described on this page, it can be used to develop new modeling languages and generators as described in subsequent chapters.</p> <p>MontiCore provides a command line interface (CLI) tool and can easily be used with Gradle. The Gradle integration enables developers to easily employ MontiCore in commonly used integrated development environments (IDEs), such as Eclipse and IntelliJ IDEA. This page contains information about an example MontiCore project and the files generated by MontiCore. It also shortly explains some key features of MontiCore.</p> <p>Detailed information about all configuration options that can be used in the MontiCore CLI tool and in MontiCore Gradle projects are explained in Chapter 16 of the handbook. More information about the example <code>Automata</code> language are available in  Chapter 21 of the handbook.</p>"},{"location":"docs/GettingStarted/#prerequisites-installing-the-java-development-kit","title":"Prerequisites: Installing the Java Development Kit","text":"<p>We start with the JDK: Please perform the following steps to install the Java Development Kit (JDK) and validate that the installation was successful:</p> <ul> <li>Install a JDK with at least version 11 provided by Oracle or OpenJDK.</li> <li>Make sure the environment variable <code>JAVA_HOME</code> points to the installed JDK, and     not to the JRE, e.g., the following would be good:<ul> <li><code>/user/lib/jvm/java-11-openjdk</code> on UNIX or</li> <li><code>C:\\Program Files\\Java\\jdk-11.*</code> on Windows. You will need this in order to run the Java compiler for compiling the generated Java source files.</li> </ul> </li> <li>Also make sure that the system variable is set such that the Java     compiler can be used from any directory. JDK installations on UNIX     systems do this automatically. On Windows systems, the <code>bin</code>     directory of the JDK installation needs to be appended to the <code>PATH</code>     variable, e.g. <code>%PATH%;%JAVA_HOME%</code>.</li> <li>Test whether the setup was successful. Open a command line shell in     any directory. Execute the command <code>javac -version</code>. If this command     is recognized and the shell displays the version of the installed     JDK (e.g., <code>javac 11.0.5</code>), then the setup was successful.</li> <li>(Optional) Install Gradle version 7.6. </li> </ul> <p>Now we have the prerequisites to run MontiCore from the command line (CLI) or alternatively using Gradle.</p>"},{"location":"docs/GettingStarted/#use-the-monticore-command-line-interface","title":"Use the MontiCore Command Line Interface","text":"<p>This section describes instructions to perform the following first steps to use MontiCore, either as a CLI tool or with Gradle:</p> <ul> <li>Installation of the MontiCore distribution file.</li> <li>Grammar inspection</li> <li>Running the MontiCore generator</li> <li>Compiling the product</li> <li>Running the product, i.e. the <code>Automata</code> tool with an example model     <code>example/PingPong.aut</code>.</li> </ul>"},{"location":"docs/GettingStarted/#installation","title":"Installation","text":"<p>For installing MontiCore for either CLI or Gradle usage, select the suitable tab below, and perform the following steps:</p> CLIGradle <ul> <li>Download the example <code>Automata</code> MontiCore project: <pre><code>// MontiCore zip distribution source\nhttps://www.monticore.de/download/monticore.tar.gz\n</code></pre></li> <li>Unzip the archive. The unzipped files include a directory called     <code>mc-workspace</code> containing the executable MontiCore tool     <code>monticore.jar</code> along with a directory <code>src</code> containing     handwritten <code>Automata</code> DSL infrastructure, a directory <code>hwc</code>     containing handwritten code that is incorporated into the generated     code, and a directory <code>example</code> containing an example model of the     <code>Automata</code> DSL. <pre><code>// MontiCore zip distribution content in directory mc-workspace\nAutomata.mc4\nmonticore.jar\nmonticore-rt.jar\nsrc/automata/AutomataTool.java\nsrc/automata/visitors/CountStates.java\nsrc/automata/prettyprint/PrettyPrinter.java\nsrc/automata/cocos/AtLeastOneInitialAndFinalState.java\nsrc/automata/cocos/StateNameStartsWithCapitalLetter.java\nsrc/automata/cocos/TransitionSourceExists.java\nhwc/automata/_ast/ASTState.java\nhwc/automata/_symboltable/AutomatonSymbol.java\nhwc/automata/_symboltable/AutomataSymbols2Json.java\nhwc/automata/_symboltable/AutomatonSymbolDeSer.java\nhwc/automata/_symboltable/AutomataGlobalScope.java\nexample/PingPong.aut\n</code></pre></li> </ul> <ul> <li>Download the example <code>Automata</code> MontiCore project for Gradle: <pre><code>// MontiCore-Automaton zip distribution source\nhttp://www.monticore.de/download/Automaton.zip\n</code></pre></li> <li>Unzip the archive. The unzipped files include a directory called <code>automaton-master</code> containing the Gradle build script  along with the directories <code>src/main/grammars</code> containing the <code>Automata.mc4</code> grammar, <code>src/main/java</code> containing both handwritten <code>Automata</code> DSL infrastructure  and handwritten code that is incorporated into the generated code, and <code>src/test/resources</code> containing an example model of the <code>Automata</code> DSL. <pre><code>// Automaton zip distribution content\nbuild.gradle\ngradle.properties\nsettings.gradle\nsrc/main/grammars/Automata.mc4\nsrc/main/java/automata/AutomataTool.java\nsrc/main/java/automata/visitors/CountStates.java\nsrc/main/java/automata/cocos/AtLeastOneInitialAndFinalState.java\nsrc/main/java/automata/cocos/StateNameStartsWithCapitalLetter.java\nsrc/main/java/automata/cocos/TransitionSourceExists.java\nsrc/main/java/automata/_ast/ASTState.java\nsrc/main/java/automata/_symboltable/AutomatonSymbol.java\nsrc/main/java/automata/_symboltable/AutomatonSymbolDeser.java\nsrc/main/java/automata/_symboltable/AutomataGlobalScope.java\nsrc/test/resources/automata/parser/PingPong.aut\n</code></pre></li> </ul> <p>Note: When mentioned, this document will specify file locations based on the CLI project setup. The CLI directories <code>src</code> and <code>hwc</code> are both represented by the same  <code>src/main/java</code> directory using Gradle.</p> <p>The CLI and Gradle setups both work on the same project,  albeit with a different directory structure.</p>"},{"location":"docs/GettingStarted/#inspect-the-example-grammar","title":"Inspect the Example Grammar","text":"<p>MontiCore is a language workbench. It supports developers in developing modular modelling languages. The core of MontiCore is its grammar modelling language (cf.\u00a0Chapter 4 of the MontiCore handbook),  which is used by developers for modelling context-free grammars. A MontiCore grammar defines (parts of) the abstract and concrete syntax of a language. Each grammar contains nonterminals, production rules, and may extend other grammars. At most one rule is marked as the start rule.</p> <p>It is a key feature of MontiCore that it allows a grammar to reuse and extend other grammars.  In an extension all the nonterminals defined in the extended grammars can be reused or even overridden. This form of extension allows to achieve several effects:</p> <ul> <li>Language (i.e. grammar) components can be reused and integrated in     larger languages, composed of several components.</li> <li>Individual nonterminals can be reused (like classes) from a library.</li> <li>A given language can be extended, allowing to add additional     alternatives inside a language.</li> </ul> <p>Component grammars and grammar extensions are detailedly discussed in  Chapter 4 of the MontiCore handbook.</p> <pre><code>grammar Automata extends de.monticore.MCBasics {\n\n  symbol scope Automaton =\n    \"automaton\" Name \"{\" (State | Transition)* \"}\" ;\n\n  symbol State =\n    \"state\" Name\n    ((\"&lt;&lt;\" [\"initial\"] \"&gt;&gt;\" ) | (\"&lt;&lt;\" [\"final\"] \"&gt;&gt;\" ))*\n    ( (\"{\" (State | Transition)* \"}\") | \";\") ;\n\n  Transition =\n    from:Name \"-\" input:Name \"&gt;\" to:Name \";\" ;\n}\n</code></pre> Listing 2.3: The <code>Automata</code> grammar. <p>In the following, we inspect the MontiCore grammar of the <code>Automata</code> language. Navigate your file explorer to the unzipped <code>mc-workspace</code> directory. The directory contains the file <code>Automata.mc4</code>. This file contains the MontiCore grammar depicted in Listing 2.3. MontiCore grammars end with <code>.mc4</code>.</p> <p>The definition of a MontiCore grammar starts with the keyword <code>grammar</code>, followed by the grammar's name. In this example, the grammar is called <code>Automata</code>. The grammar's name is optionally followed by the keyword <code>extends</code> and a list of grammars that are extended by the grammar. In this example, the <code>Automata</code> grammar extends the grammar <code>de.monticore.MCBasics</code>.</p>  Tip 2.4 MontiCore Key Feature: Composition  <p>The MontiCore language workbench allows to compose language components by composing grammars and also to reuse all infrastructure, such as context conditions, symbol table infrastructure, generator parts and handwritten extensions.</p> <p>In the example the <code>Automata</code> grammar extends the grammar <code>de.monticore.MCBasics</code> and thus reuses its functionality.</p> <p>MontiCore comes with an extensive library of predefined language components.</p> <p>Grammars can also have a package and import other grammars. If a grammar has a package, then the package declaration must be the first statement in the grammar and is of the form <code>package</code> QualifiedName where <code>package</code> is a keyword and QualifiedName is an arbitrary qualified name (e.g. <code>de.monticore</code>). The optional grammar imports follow the package definition. Every import is of the form <code>import</code> QualifiedName. The <code>Automata</code> example grammar file does neither contain a package declaration nor imports. The grammar extended by the <code>Automata</code> grammar is specified by its fully qualified name.</p> <p>As usual in context-free grammars, production rules have a left-hand side and a right-hand side. The left-hand side contains the possibly annotated name of a nonterminal. The left-hand side is followed by the terminal <code>=</code> and the right-hand side. Nonterminal names start with an upper-case letter. For instance, the <code>Automata</code> grammar contains the nonterminals <code>Automaton</code>, <code>State</code>, and <code>Transition</code>. A single nonterminal can be provided with the <code>start</code> keyword. Then, the nonterminal is the starting symbol of the grammar. If no nonterminal is marked with <code>start</code>, then the first nonterminal of the grammar becomes the starting symbol by default. In the <code>Automata</code> grammar, the <code>Automaton</code> nonterminal is the starting symbol.</p> <p>The other possible keywords for nonterminals influence the generated classes for the abstract syntax tree as well as the generated symbol table infrastructure. Details can be found in  Chapter 4 and Chapter 9 of the MontiCore handbook.  For example, the <code>Automaton</code> nonterminal is marked with <code>symbol</code> and <code>scope</code>. The keyword <code>symbol</code> makes the MontiCore generator generate a symbol class for the nonterminal. Intuitively stated, the keyword <code>scope</code> instructs the MontiCore generator to construct a symbol table infrastructure that opens a scope when the production is processed. The following sections explain the effects of specifying the <code>Automaton</code> nonterminal with the keywords <code>symbol</code> and <code>scope</code> in more detail. Terminals are surrounded by quotation marks. The <code>Automata</code> grammar, for example, inter alia contains the terminals <code>automaton</code>, <code>state</code>, <code>{</code>, <code>}</code>, and <code>;</code>.</p> <p>The right-hand sides of grammar productions consist of nonterminals, terminals, and semantic predicates, may use cardinalities (<code>*</code>, <code>+</code>, <code>?</code>), and introduce alternatives via the terminal <code>|</code> as known from regular expressions. Details can be found in  Chapter 4 of the MontiCore handbook.  The right-hand side of the production defining the nonterminal <code>Automaton</code>, for example, uses the terminal <code>automaton</code> and the nonterminals <code>Name</code>, <code>State</code>, and <code>Transition</code>. The nonterminal <code>Name</code> is not defined in the grammar <code>Automata</code>. Thus, it must be defined in one of the extended grammars. In this case, <code>Name</code> is defined in the grammar <code>MCBasics</code> and is reused by the grammar <code>Automata</code>. For distinguishing different usages of nonterminals on right-hand sides, they can be named. For example, the right-hand side of the production defining the nonterminal <code>Transition</code> uses the <code>Name</code> nonterminal twice. The first usage is named <code>input</code> and the second usage is named <code>to</code>. MontiCore also supports <code>interface</code> and <code>external</code> nonterminals for introducing extension points as detailedly described in Chapter 4 of the MontiCore handbook.  However, the example grammar does not use these concepts.</p> <pre><code>automaton PingPong {\n  state NoGame &lt;&lt;initial&gt;&gt;;\n  state Ping;\n  state Pong &lt;&lt;final&gt;&gt;;\n\n  NoGame - startGame &gt; Ping;\n\n  Ping - stopGame &gt; NoGame;\n  Pong - stopGame &gt; NoGame;\n\n  Ping - returnBall &gt; Pong;\n  Pong - returnBall &gt; Ping;\n}\n</code></pre> Listing 2.5: A model conforming to the Automata grammar. <p>Listing 2.5 depicts an example model conforming to the <code>Automata</code> grammar in its concrete syntax.  It depicts a simple game of Ping Pong. The automaton consists of three states:  the initial state <code>NoGame</code>, such as the states <code>Ping</code> and <code>Pong</code>, for  identifying on which side the ball is located.  Initially, the automaton starts in the state <code>NoGame</code>.  The game starts at the corresponding event.  During a run, the automaton switches states by returning the ball from one  side to the other.  Additionally, it can be stopped at each stage of the game, resulting in the  initial configuration. You can find the model in the file <code>PingPong.aut</code> contained in the <code>example</code> directory of the unzipped <code>mc-workspace</code> directory.</p>"},{"location":"docs/GettingStarted/#run-monticore","title":"Run MontiCore","text":"<p>The MontiCore generator takes a MontiCore grammar as input and generates an infrastructure for processing models conforming to the grammar. When a grammar <code>E</code> extends another grammar <code>G</code>, then all the infrastructure generated for the grammar <code>G</code> is reused and only the extending part from <code>E</code> is generated.</p>  Tip 2.6 Infrastructure Generated by MontiCore  MontiCore itself as well as the infrastructure generated by the MontiCore generator are implemented in Java. This infrastructure includes:  <ul> <li> a parser for parsing models conforming to the grammar and     transforming textual models into abstract syntax tree instances     abstracting from the concrete syntax.</li> <li> a symbol table infrastructure to handle the symbols introduced or     used by models conforming to the grammar. The symbol table     infrastructure is used for resolving dependencies between model     elements that are possibly defined in different files.</li> <li> a context-condition checking framework for checking     well-formedness rules that cannot be captured by context-free     languages.</li> <li> a visitor infrastructure for traversing models respectively their     abstract syntax instances. The abstract syntax of a model consists     of its internal representation as an abstract syntax tree     abstracting from the concrete syntax of the model (the instance of     the data structure obtained from parsing) and the symbol table of     the model.</li> <li> a mill infrastructure for retrieving objects for language     processing, such as parsers, builders for abstract syntax trees,     visitors and objects for the symbol tables of the language.      A mill serves as a dynamic factory, adapting to the current      modeling language. The     possibility to configure the mills is crucial for reusing the     functionality implemented for a sublanguage (cf. Section 5.9,      Section 5.10.2, and Section 11.5 for details).</li> <li> a code generating framework that extends the      FreeMarker template     engine by various modularity enhancing features.</li> </ul> <p>For executing MontiCore using the <code>Automata</code> grammar as input, perform the following steps:</p> CLIGradle <ol> <li>Open a command line shell and change the working directory to the     unzipped directory (<code>mc-workspace</code>).</li> <li>Execute the following command in order to generate the language     infrastructure of the <code>Automata</code> DSL: <pre><code>java -jar monticore.jar -g Automata.mc4 -hcp hwc/ src/ -mp monticore-rt.jar\n</code></pre> The only required argument <code>Automata.mc4</code> denotes the input grammar that shall be processed by MontiCore. The processing includes the generation of the language infrastructure. Using the option <code>-hcp</code> enables specifying the path to a directory containing the handwritten code that is to be incorporated into the generated infrastructure. In this case, passing the argument <code>hwc/</code> to the option <code>-hcp</code> makes MontiCore consider the handwritten code located in the directory <code>hwc/</code>. Providing handwritten code enables to easily incorporate additional functionality into the generated code. For example, this enables developers to extend generated abstract syntax classes as detailedly described in  (cf. Section 5.10 of the MontiCore handbook). Passing the argument <code>-mp</code> enables specifying the paths to directories  or archives  containing paths to grammars and Java classes that are imported by the  processed grammar and the related tooling. In this case, the archive  <code>monticore-rt.jar</code> contains the grammars and handwritten extensions of the monticore standard library. More information about the standard library can be found in  Chapters 17- 20 of the handbook.</li> </ol> <ol> <li>Open a command line shell and change the working directory to the     unzipped directory.</li> <li>Execute the following command in order to generate the language     infrastructure of the <code>Automata</code> DSL: <pre><code>gradle generateMCGrammars\n</code></pre> By default, the MontiCore Gradle plugin shall process all input grammars in  <code>src/main/grammars</code>. The processing includes the generation of the language infrastructure. Handwritten code in <code>src/main/grammar</code> is going to be incorporated into the generated infrastructure. Providing handwritten code enables to easily incorporate additional functionality into the generated code. For example, this enables developers to extend generated abstract syntax classes as detailedly described in (cf. Section 5.10 of the MontiCore handbook).</li> </ol> <p>The MontiCore standard library, containing grammars and Java classes, is imported via the <code>de.monticore:monticore-grammar</code> dependency. More information about the standard library can be found in Chapters 17- 20 of the handbook.</p> <p>A more detailed description of the MontiCore Gradle plugin is given  here.</p> <p>Executing the command launches MontiCore, which results in the executing of the following steps:</p> <ol> <li>The specified grammar is parsed and processed by MontiCore.</li> <li>Java source files for the corresponding DSL infrastructure are     generated into the default output directory <code>out</code>.  This infrastructure      consists of the directories<ul> <li><code>out/automata/</code> containing the mill (cf. Section 5.9, Section 5.10.2, Section 11.5).</li> <li><code>out/automata/_ast</code> containing the abstract syntax tree data     structure (cf. Chapter 5 of the MontiCore handbook).</li> <li><code>out/automata/_auxiliary</code> containing adapted mills of sublanguages,     which are required for configuring the mills of sublanguages     (cf. Chapter 11 of the MontiCore handbook).</li> <li><code>out/automata/_cocos</code> containing the infrastructure for context     conditions (cf. Chapter 10 of the MontiCore handbook).</li> <li><code>out/automata/_od</code> containing the infrastructure for printing     object diagrams for reports produced during processing the     models.</li> <li><code>out/automata/_parser</code> containing the generated parsers, which are     based on ANTLR (cf. Chapter 6 of the MontiCore handbook).</li> <li><code>out/automata/_symboltable</code> containing the infrastructure for the symbol     table (cf. Chapter 6 of the MontiCore handbook).</li> <li><code>out/automata/_utils</code> containing infrastructure for typecasting and  identifying subtypes of ast nodes, symbols, and scopes.</li> <li><code>out/automata/_visitor</code> containing the infrastructure for visitors   (cf. Chapter 9 of the MontiCore handbook).</li> <li><code>out/reports/automata</code> containing reports created during the   processing of the grammar.</li> </ul> </li> <li>The output directory also contains a log file of the executed     generation process with the generation time in its name.</li> </ol> <p>In the following, we review the classes and interfaces generated from the <code>Automata</code> grammar that are relevant for language engineers in more detail. We do not review the classes and interfaces that are only internally relevant for MontiCore and are usually not intended to be used by language engineers.</p>"},{"location":"docs/GettingStarted/#abstract-syntax-tree-data-structure","title":"Abstract Syntax Tree Data Structure","text":"<p>The tree data structure is generated into the directory <code>out/automata/_ast</code>. Details about the generation of AST classes can be found in  (cf. Chapter 5 of the MontiCore handbook). For each nonterminal contained in the grammar, the MontiCore generator produces AST and corresponding builder classes. The AST classes implement the abstract syntax tree data structure.</p> <p>The builder classes implement the builder pattern for constructing instances of the respective AST classes as usual. For example, the class <code>ASTAutomaton</code> is the AST class generated for the <code>Automaton</code> nonterminal (cf.\u00a0Listing 2.3) and the class <code>ASTAutomatonBuilder</code> is the corresponding generated builder class.</p> <p>Parts of the AST data structure generated for the <code>Automata</code> grammar.</p> <p></p> Figure 2.7: Parts of the AST data structure generated for the <code>Automata</code> grammar. <p>The contents of the AST and builder classes are generated systematically from the grammar. The attributes of each AST class resemble the right-hand side of the corresponding production rule. In the following, we mainly speak of attributes, but please be aware that all attributes come fully equipped with access and modification methods, which should normally be used.</p> <p>For instance, Figure 2.7 depicts parts of the generated <code>AST</code> infrastructure for the <code>Automata</code> grammar. The class <code>ASTAutomaton</code> contains the attributes <code>name</code>, <code>states</code>, and <code>transitions</code>. The <code>AST</code> class does not contain an attribute for the terminal <code>automaton</code> as it is part of every word conforming to the production of the <code>Automaton</code> nonterminal. The type of the attribute <code>name</code> is <code>String</code> whereas the attributes <code>states</code> and <code>transitions</code> are lists of the types of the <code>AST</code> classes corresponding to the used nonterminals. This is the case because exactly one <code>Name</code> is parsed with the right-hand side of the production of the nonterminal <code>Automaton</code>, whereas multiple states and transitions can be parsed.</p> <p>The <code>ASTAutomaton</code> class further contains the attributes <code>symbol</code>, <code>spannedScope</code>, and <code>enclosingScope</code>. These attributes are specific to the symbol table of <code>Automata</code> models and are used for linking the symbol table of a model with its abstract syntax tree. Details can be found in Chapter 9 of the MontiCore handbook.</p>  Tip 2.8 Generated Symbols and Scopes in the AST  <p>Each <code>AST</code> class contains access to the <code>enclosingScope</code>.</p> <p>When a production contains the keyword <code>symbol</code>, the generated AST class contains the attribute <code>symbol</code>  (see Chapter 9 of the MontiCore handbook).</p> <p>Keyword <code>scope</code> indicates that a nonterminal also defines a new local scope, stored in attribute <code>spannedScope</code>.</p> <p>The parser builds the abstract syntax tree of a model and the available scope genitor creates the symbol table of the model, consisting of symbols and scopes.</p> <p>The <code>ASTAutomaton</code> class further contains several straight-forward methods for checking different instances for equality and accessing the attributes. Similar to the <code>ASTAutomaton</code> class, the <code>ASTAutomatonBuilder</code> class contains attributes resembling the right-hand side of the corresponding production. It further contains methods for changing the values of the attributes (e.g., <code>addState</code>), checking whether the <code>AST</code> instance that would be constructed from the current builder state is valid (cf.\u00a0<code>isValid</code>), and for building the <code>AST</code> instance corresponding to the builder's state (cf.\u00a0<code>build</code>). The contents of the other <code>AST</code> and <code>Builder</code> classes are constructed analogously.</p>  Tip 2.9 Handwritten AST Class Extensions  <p>If the generator detects that an <code>AST</code> class for a nonterminal is already implemented in the handwritten code, then it produces a corresponding <code>TOP</code> <code>AST</code> class instead.</p> <p>This TOP mechanism allows developers to add handwritten extensions to any generated class, while reusing the generated <code>TOP</code> class via extension.</p> <p>This gives a very close integration between handwritten and generated code that even adapts builders accordingly, while preventing the very bad habit of performing manual changes to the generated code.</p> <p>Option <code>-hcp</code> tells the generator where to look for handwritten integrations.</p> <p>The following section presents the methods of the classes for parsing textual models (possibly stored in files) into <code>AST</code> class instances at runtime. For now, it suffices for you to understand that (1) MontiCore generates an extensible <code>AST</code> data structure that resembles the nonterminals and productions of the grammar in a straight-forward way and (2) that all models of a grammar have an <code>AST</code> data structure representation for internal processing.</p>"},{"location":"docs/GettingStarted/#parser","title":"Parser","text":"<p>The infrastructure is generated into the directory <code>out/automata/_parser</code>. Details about the generated parsers and their uses are described in  Chapter 6 of the MontiCore handbook.</p> <p>Parts of the class <code>AutomataParser</code> generated from the <code>Automata</code> grammar.</p> <p></p> Figure 2.10: Parts of the class <code>AutomataParser</code> generated from the <code>Automata</code> grammar. <p>Parts of the generated class <code>AutomataParser</code> are depicted in Figure 2.10. The class implements the generated parser for the <code>Automata</code> grammar. Usually, developers are solely concerned with the methods <code>parse(String)</code> and <code>parse_String(String)</code>. For now, it suffices if you remember that parsing textual <code>Automata</code> models stored in files is possible by calling the method <code>parse(String)</code> of an <code>AutomataParser</code> object with the fully qualified name of the file as input.</p>  Tip 2.11 Methods for Parsing  <p>The class <code>AutomataParser</code> contains the methods</p> <ul> <li><code>parse(Reader r)</code>,</li> <li><code>parse(String filename)</code>, and</li> <li><code>parse_String(String content)</code>.</li> </ul> <p>All of the methods return an object of type <code>Optional&lt;ASTAutomaton&gt;</code>, where absence means failure of parsing and errors have been issued.</p> <p>For each nonterminal in the grammar, the class further contains methods for parsing a sub-model described by this nonterminal.</p>"},{"location":"docs/GettingStarted/#symbol-table","title":"Symbol Table","text":"<p>The infrastructure is generated into the directory <code>out/automata/_symboltable</code>. Details about the generated symbol table infrastructure and its use are described in Chapter 9 of the MontiCore handbook.  The symbol table infrastructure is used for resolving cross-references concerning information defined in different model elements that are potentially defined in different models stored in different files.</p> <p></p> Figure 2.12: The scope classes generated from the `Automata` grammar.  Tip 2.13 Scope Classes  <p>For the <code>Automata</code> grammar, the generator produces the classes</p> <ul> <li><code>AutomataScope</code>,</li> <li><code>AutomataArtifactScope</code>, and</li> <li><code>AutomataGlobalScope</code></li> </ul> <p>as well as respective interfaces. The relationships between these classes and interfaces are depicted in Figure 2.12.</p> <p>The singleton <code>AutomataGlobalScope</code> contains all <code>AutomataArtifactScopes</code> of all loaded <code>Automata</code> artifacts. <code>AutomataScope</code>s represent scopes spanned inside of models.</p> <p></p> Figure 2.14: Parts of the symbol classes generated from the <code>Automata</code> grammar. <p>Figure 2.14 depicts parts of the symbol classes generated for the <code>Automata</code> grammar. As the nonterminal <code>State</code> is annotated with <code>symbol</code> in the <code>Automata</code> grammar, the generator produces the class <code>StateSymbol</code>. The <code>StateSymbol</code> class, inter alia, contains the attributes <code>name</code>, <code>enclosingScope</code>, and <code>spannedScope</code>. The attribute <code>name</code> stores the name of the symbol. The attributes <code>enclosingScope</code> and <code>spannedScope</code> store the enclosing and spanned scopes of the symbol. The class further contains methods for accessing and setting the attributes. For all symbol classes, the MontiCore generator also produces builder classes (e.g., <code>AutomataArtifactScopeBuilder</code> and <code>StateSymbolBuilder</code>).</p>  Tip 2.15 Extending Symbol Classes  <p>It is possible to add further methods and attributes in two ways:</p> <ul> <li>adding a symbol rule in the grammar    (described in Chapter 9 of the MontiCore handbook) or</li> <li>using the TOP mechanism applied to the generated symbols.</li> </ul> <p>The generated class <code>AutomataScopesGenitor</code> is responsible for creating the scope structure of <code>Automata</code> artifacts and linking the scope structure with the corresponding <code>AST</code> nodes. For this task, it provides the method <code>createFromAST</code> that takes an <code>ASTAutomaton</code> instance as input and returns an <code>IAutomataArtifactScope</code> instance. The returned <code>IAutomataArtifactScope</code> instance can be added as a subscope to the (during runtime unique and administrated by the mill) <code>AutomataGlobalScope</code> instance.</p> <p>Developers can create visitors for complementing the symbol table (creating symbols and filling the extensions introduced via symbol rules or the TOP mechanism) of an <code>Automata</code> artifact. After creating the scope structure, the visitor should be used to traverse the <code>AST</code> instance of the artifact for complementing the symbols and scopes. The following sections explain the generated visitor infrastructure in more detail.</p> <pre><code>Optional&lt;AutomatonSymbol&gt; resolveAutomaton(String name)\nList&lt;AutomatonSymbol&gt; resolveAutomatonMany(String name)\nOptional&lt;StateSymbol&gt; resolveState(String name)\nList&lt;StateSymbol&gt; resolveStateMany(String name)\n</code></pre> Listing 2.16: Different <code>resolve</code> methods. <p>For each nonterminal annotated with <code>symbol</code> in the grammar <code>Automata</code>, the scope interfaces contain a symbol-specific <code>resolve</code> method taking a string as input. The method can be called to resolve symbol instances by their names. The name given as input to a <code>resolve</code> method should be as qualified as needed to find the symbol. For instance, Listing 2.16 lists the signatures of four of the <code>resolve</code> methods provided by the interface <code>IAutomataScope</code>.</p> <p>For now, it suffices for you to understand that (1) MontiCore generates an extensible symbol table data structure that resembles the scope and symbol structure as specified in the grammar in a straight-forward way and (2) that all models of a grammar have a symbol table data structure representation for internal processing and (3) that symbols can be resolved from scopes via calling the <code>resolve</code> methods.</p>"},{"location":"docs/GettingStarted/#deserialization-of-symbol-tables","title":"(De)Serialization of Symbol Tables","text":"<p>MontiCore also supports the serialization and deserialization of symbol tables. The (de)serialization is crucial for incremental code generation and efficient language composition via aggregation. Details about this are explained in Chapter 7 and Chapter 9 of the MontiCore handbook.</p> <p>For the (de)serialization, the generator produces the class <code>AutomataSymbol2Json</code>. It provides the public methods <code>store</code> and <code>load</code>. The former can be used to serialize <code>IAutomataScope</code> instances into their string representations encoded in JSON and persisting these to a file at a location that is passed as method argument. The latter can be used to load a stored <code>IAutomataScope</code> into its objects representation. For now, it suffices that you understand which methods to call for the (de)serialization.</p>"},{"location":"docs/GettingStarted/#visitor","title":"Visitor","text":"Figure 2.17: Parts of the visitor infrastructure generated from the <code>Automata</code> grammar <p>The infrastructure is generated into the directory <code>out/automata/_visitor</code>. Details about the generated visitor infrastructure are described in  Chapter 8 of the MontiCore handbook. For each grammar, the generator systematically produces several classes and interfaces implementing the visitor infrastructure. For the <code>Automata</code> grammar, for example, the generator produces the interfaces <code>AutomataTraverser</code>, <code>AutomataVisitor2</code>, and <code>AutomataHandler</code> and the class <code>AutomataTraverserImplementation</code>. The relationships between these interfaces and classes are depicted in Figure 2.17.</p> <p>The interfaces <code>Traverser</code>, <code>Visitor2</code> and <code>Handler</code> together realize the Visitor pattern. Conceptually, the traverser is the entry point for traversing. The traverser manages visitors for the different sublanguages and realizes the default traversing strategy. Whenever an AST node is traversed, the traverser delegates the visit to the corresponding visitor implementation. If a special traversal is to be implemented that differs from the default, it is possible to add handlers to the traverser that realize the alternative traversal. For a more detailed explanation consider reading  Chapter 8 of the MontiCore handbook.</p>  Tip 2.18 Visitors  <p>MontiCore provides the visitor pattern in a detangled and thus flexible variant.</p> <p><code>AutomataTraverser</code> is traversing the AST. <code>AutomataVisitor2</code> contain the actual functionalities, added through subclassing. Many visitors can be added to the traverser for parallel execution via the method <code>add4Automata</code>.</p> <p>The visitors are compositional, allowing to maximize reuse of visitors from sublanguages, and they can be adapted through the TOP mechanism.</p> <p>For example, the handwritten class <code>PrettyPrinter</code>, which can be found in the directory <code>mc-workspace/src/automata/prettyprint</code>, implements functionality for pretty printing an <code>Automata</code> model, which is given by its abstract syntax tree. Listing 2.19 depicts the attributes and the constructor of the class. The <code>PrettyPrinter</code> class implements the <code>AutomataHandler</code> interface. Its constructor instantiates a printer (a helper for printing indented strings) and retrieves an <code>AutomataTraverser</code> object from the mill (which is explained later on). It sets the handler of the traverser to itself. This ensures that the pretty printer becomes the handler of the traverser. We will execute it in a following section.</p> <pre><code>public class PrettyPrinter implements AutomataHandler {\n  private final IndentPrinter printer;\n  private AutomataTraverser traverser;\n\n  public PrettyPrinter() {\n    this.printer = new IndentPrinter();\n    this.traverser = AutomataMill.traverser();\n    traverser.setAutomataHandler(this);\n  }\n  // further methods\n}\n</code></pre> Listing 2.19: Attributes and constructor of the <code>PrettyPrinter</code> for the <code>Automata</code> language. <p>For now, you should understand that (1) for implementing visitors it is often sufficient to implement the visitor interfaces and to add them to a traverser and (2) custom traversals can be realized by implementing handlers and adding those to the traverser.</p>"},{"location":"docs/GettingStarted/#context-conditions","title":"Context Conditions","text":"<p>The infrastructure is generated into the directory <code>out/automata/_cocos</code>. Details about the generated context condition infrastructure are described in Chapter 10 of the MontiCore handbook.</p> <p>For each nonterminal of a grammar, the generator produces a context condition interface for implementing context conditions for this nonterminal. For the <code>Automata</code> grammar, for example, the generator produced the interface <code>AutomataASTStateCoCo</code>. The interface solely contains the method <code>check(ASTState)</code>. Each class implementing the interface should represent a predicate over subtrees of abstract syntax trees starting at a node with the type corresponding to the nonterminal.</p> <p>The check method should be implemented such that it reports an error or a warning if the input node does not satisfy the predicate. Thus, context conditions implement well-formedness rules that cannot be captured by context-free grammars (or that are intentionally not captured by the grammar to achieve a specific <code>AST</code> data structure). For producing the error or warning, the static methods <code>error</code> and <code>warning</code> of the MontiCore runtime class <code>Log</code> should be used.</p> <p>For the <code>Automata</code> grammar, the generator also produced the class <code>AutomataCocoChecker</code>. For each nonterminal of the grammar, the class contains a method for adding context condition instances to an <code>AutomataCocoChecker</code> instance. For checking whether an <code>AST</code> node satisfies all registered context conditions, the method <code>checkAll</code> can be called with the <code>AST</code> node as input. Calling the method makes the checker traverse the abstract syntax tree and check whether each node satisfies the context conditions registered for the node. Thus, <code>AutomataCocoChecker</code> instances represent sets of context conditions that are required to be satisfied by abstract syntax tree instances.</p> <p>For now, you should understand that (1) implementing context conditions is possible via implementing the generated <code>CoCo</code> interfaces and (2) context conditions can be checked via instantiating the <code>Checker</code> class, adding the CoCos, and calling the <code>checkAll</code> method.</p>"},{"location":"docs/GettingStarted/#mill-as-factory-for-builders","title":"Mill as Factory for Builders","text":"<p>The for the <code>Automata</code> language is generated into the directory <code>out/automata/</code>. Details about the generated mill and the mill pattern in general are described in Section 11.5. The generated mill class <code>AutomataMill</code> is responsible for providing ready to use and correct parser, scope genitor, scope, and builder instances. The mill of each language is a singleton.</p>  Tip 2.20 Mill Use and Automatic Initialization  <p>A mill is a factory for builders and other commonly used functions, such as parsers or visitors. The mill was introduced to ensure compositionality of languages, while retaining reusability of functions developed for sublanguages.</p> <p>Only one mill instance exists, even though in composed languages it is available under several static signatures. Let language <code>G2</code> extend another language <code>G1</code>. Then <code>G2Mill</code> initializes the <code>G1Mill</code> appropriately, such that all the code of the sublanguage <code>G1</code> can be reused in the tools developed for the language <code>G2</code>, even when creating new AST nodes, symbols, etc.</p> <p>Cool mechanism and the developers don't have to bother.</p> <pre><code>public static IAutomataGlobalScope globalScope()\npublic static IAutomataArtifactScope artifactScope()\npublic static IAutomataScope scope()\npublic static AutomataScopesGenitor scopesGenitor ()\npublic static AutomataScopesGenitorDelegator scopesGenitorDelegator()\npublic static ASTAutomatonBuilder automatonBuilder()\npublic static AutomatonSymbolBuilder automatonSymbolBuilder()\npublic static AutomataParser parser()\npublic static AutomataTraverser traverser ()\n</code></pre> Listing 2.21: Some method of the <code>AutomataMill</code>. <p>Developers should retrieve all instances of the classes and interfaces provided by the mill by using the mill. Instances of the classes and interfaces that are provided by the mill should never be instantiated manually. Otherwise, it may be the case that not all of the code implemented for the language can be reused as expected in other languages extending the language. Listing 2.21 shows some signatures of the methods of the <code>AutomataMill</code>.</p>  Tip 2.22 Mill Methods  <p>A mill provides <code>public static</code> methods for retrieving the instances of the parsers, scope genitors, scopes, and builders. For that is acts like a factory. Because a mill is realized using the static delegator pattern (cf. Section 11.1), it still can be adapted at will.</p> <p>This combines the advantage of general availability with the advantage of being able to override the functions.</p> <p>For now, you should understand that (1) the methods of the mill should be used for creating ready to use and correct parser, scope genitor, scope, and builder instances and (2) how to call these methods.</p>"},{"location":"docs/GettingStarted/#compile-the-target","title":"Compile the Target","text":"<p>Section 2.2.3 of the MontiCore handbook  describes how to generate the desired Java code from a MontiCore grammar. For these Java classes, generated for the <code>Automata</code> DSL, execute the following command in the mc-workspace:</p> CLIGradle <p>With Powershell on Windows <pre><code>javac -cp monticore-rt.jar -sourcepath \"src/;out/;hwc/\" `\n                                  src/automata/AutomataTool.java\n</code></pre> With Bash on Unix <pre><code>javac -cp monticore-rt.jar -sourcepath \"src/:out/:hwc/\" \\\n                                  src/automata/AutomataTool.java\n</code></pre> With cmd on Windows <pre><code>javac -cp monticore-rt.jar -sourcepath \"src/;out/;hwc/\" ^\n                                  src/automata/AutomataTool.java\n</code></pre></p> <p>Please note, on Unix systems paths are separated using \":\" (colon) instead of semicolons.</p> <p>Providing the option <code>-cp</code> with the argument <code>monticore-cli.jar</code> makes the Java compiler consider the compiled MontiCore runtime classes contained in the file <code>monticore-cli.jar</code>.</p> <p>The option <code>-sourcepath</code> enables to specify paths to directories containing the source files that should be considered during the compilation.</p> <p>In this case, executing the command makes the Java compiler consider all generated classes located in and all handwritten classes located in <code>src</code> and <code>hwc</code>.  The last argument instructs the Java compiler to compile the class <code>src/automata/AutomataTool.java</code>.</p> <p><pre><code>gradle compileJava\n</code></pre> Gradle will take care of running the Java compiler.</p> <p>Please note that the structure of the handwritten classes follows the package layout of the generated code, i.e. there are the following sub directories (Java packages):</p> <ul> <li><code>src/automata</code> contains the top-level language realization for using     the generated DSL infrastructure. In this case the class     <code>src/automata/AutomataTool.java</code> constitutes a main class executable     for processing automata models with the automata DSL.</li> <li><code>src/automata/cocos</code> contains infrastructure for context condition     of the automata DSL.</li> <li><code>src/automata/prettyprint</code> contains an exemplary use of the     generated visitor infrastructure for processing parsed models for     pretty printing.</li> <li><code>src/automata/visitors</code> contains an exemplary analysis using the     visitor infrastructure. The exemplary analysis counts the states     contained in the parsed automata model.</li> <li><code>hwc/automata/_ast</code> contains an exemplary usage of the handwritten     code integration mechanism for modifying the AST for the automata     DSL. Details about the integration mechanism are described in Section 5.10.</li> <li><code>hwc/automata/_symboltable</code> contains handwritten extensions of the     generated symbol table infrastructure. Details about implementing     handwritten symbol table infrastructure extensions are described in      Chapter 9 of the MontiCore handbook.</li> </ul> <p>Please, also do not mix the code for the <code>Automata</code> tool vs. the code for the final product, generated from that tool, although both have a similar package structure.</p> <p>We already described the contents of the directories <code>hwc/automata/_ast</code> and <code>hwc/automata/_symboltable</code> in the previous section. They contain handwritten extensions of the abstract syntax of the <code>Automata</code> language.</p> <pre><code>public class CountStates implements AutomataVisitor2 {\n  private int count = 0;\n\n  @Override\n  public void visit(ASTState node) {\n    count++;\n  }\n\n  public int getCount() {\n    return count;\n  }\n}\n</code></pre> Listing 2.23: The <code>CountStates</code> visitor implementation <p>The directory <code>src/automata/visitors</code> contains the file <code>CountStates.java</code>. The class is depicted in Listing 2.23. It implements a simple visitor for counting the number of states contained in an <code>Automata</code> model. To this effect, it implements the <code>AutomataVisitor2</code> interface. It has an attribute <code>count</code> of type <code>int</code> for storing the current number of counted nodes. It overrides the <code>visit</code> method for <code>ASTState</code> to increase the counter whenever a state is visited.</p> <p>The directory <code>src/automata/cocos</code> contains the context-condition implementations for the <code>Automata</code> language.</p> <pre><code>public class AtLeastOneInitialAndFinalState\n       implements AutomataASTAutomatonCoCo {\n@Override\n  public void check(ASTAutomaton automaton) {\n    boolean initialState = false;\n    boolean finalState = false;\n\n    for (ASTState state : automaton.getStateList()) {\n      if (state.isInitial()) {\n        initialState = true;\n      }\n      if (state.isFinal()) {\n        finalState = true;\n      }\n    }\n\n    if (!initialState || !finalState) {\n      // Issue error...\n      Log.error(\"0xA0116 An automaton must have at least one initial \n                 and one final state.\",\n          automaton.get_SourcePositionStart());\n    }\n  }\n}\n</code></pre> Listing 2.24: Context condition implementation for checking that there exist at least one initial and at least one final state. <p>Listing 2.24 depicts the class <code>AtLeastOneInitialAndFinalState</code>. The class implements a context condition for checking whether an <code>Automata</code> model contains at least one initial and at least one final state. To this effect, the class implements the interface <code>AutomataASTAutomatonCoCo</code>. The class <code>StateNameStartsWithCapitalLetter</code> is implemented similarly.</p> <pre><code>public class TransitionSourceExists\n                 implements AutomataASTTransitionCoCo {\n\n  @Override\n  public void check(ASTTransition node) {\n\n    IAutomataScope enclosingScope = node.getEnclosingScope();\n    Optional&lt;StateSymbol&gt; sourceState =\n        enclosingScope.resolveState(node.getFrom());\n\n    if (!sourceState.isPresent()) {\n      // Issue error...\n      Log.error(\n        \"0xADD03 Source state of transition missing.\",\n         node.get_SourcePositionStart());\n    }\n  }\n}\n</code></pre> Listing 2.25: Context condition implementation for checking that states used in transitions exist. <p>Listing 2.25 presents the implementation of the class <code>TransitionSourceExists</code>. The class implements a context condition for checking whether the source states used in transitions are defined. To this effect, the class uses the resolving mechanisms of the symbol table. For each transition, the context conditions tries to resolve the state symbol corresponding to the source state of the transition. If the resolving fails for the state, then the context condition logs an error.</p> <p>The class <code>AutomataTool</code> is the main class of the <code>Automata</code> language. It is defined in the file <code>AutomataTool.java</code> contained in the directory <code>src/automata</code>.</p> <pre><code>public class AutomataTool extends AutomataToolTOP {\n  // main method missing in this listing\n\n  public ASTAutomaton parse(String model) {\n    try {\n      AutomataParser parser = new AutomataParser() ;\n      Optional&lt;ASTAutomaton&gt; optAutomaton = parser.parse(model);\n\n      if (!parser.hasErrors() &amp;&amp; optAutomaton.isPresent()) {\n        return optAutomaton.get();\n      }\n      Log.error(\"0xEE840 Model could not be parsed.\");\n    }\n    catch (RecognitionException | IOException e) {\n      Log.error(\"0xEE640 Failed to parse \" + model, e);\n    }\n    System.exit(1);\n    return null;\n  }\n}\n</code></pre> Listing 2.26: Methods for parsing and creating symbol tables. <p>Listing 2.26 presents the implementation of the method <code>parse</code> of the <code>AutomataTool</code>  class which can be used for parsing <code>Automata</code> models. The class extends the  generated abstract superclass <code>AutomataToolTOP</code> that provides methods to be used in the <code>run</code> method. One example is the method <code>createSymbolTable</code> that uses the global scope  and genitors available in the mill to create a symbol table for <code>Automata</code>. </p> <pre><code>public static void main(String[] args) {\n  // delegate main to instantiatable method for better integration,\n  // reuse, etc.\n  new AutomataTool().run(args);\n}\n\npublic void run(String[] args) {\n\n  // use normal logging (no DEBUG, TRACE)\n  AutomataMill.init();\n  Log.ensureInitialization();\n\n  Options options = initOptions();\n  try {\n    //create CLI Parser and parse input options from commandline\n    CommandLineParser cliparser = new org.apache.commons.cli.DefaultParser();\n    CommandLine cmd = cliparser.parse(options, args);\n\n    //help: when --help\n    if (cmd.hasOption(\"h\")) {\n      printHelp(options);\n      //do not continue, when help is printed.\n      return;\n    }\n    //version: when --version\n    else if (cmd.hasOption(\"v\")) {\n      printVersion();\n      //do not continue when help is printed\n      return;\n    }\n\n    Log.info(\"Automata DSL Tool\", \"AutomataTool\");\n\n    if (cmd.hasOption(\"i\")) {\n      String model = cmd.getOptionValue(\"i\");\n      final ASTAutomaton ast = parse(model);\n      Log.info(model + \" parsed successfully!\", \"AutomataTool\");\n\n      AutomataMill.globalScope().setFileExt(\"aut\");\n      IAutomataArtifactScope modelTopScope = createSymbolTable(ast);\n      // can be used for resolving things in the model\n      Optional&lt;StateSymbol&gt; aSymbol = modelTopScope.resolveState(\"Ping\");\n      if (aSymbol.isPresent()) {\n        Log.info(\"Resolved state symbol \\\"Ping\\\"; FQN = \"\n            + aSymbol.get().toString(),\n          \"AutomataTool\");\n      } else {\n        Log.info(\"This automaton does not contain a state called \\\"Ping\\\";\",\n          \"AutomataTool\");\n        }\n      runDefaultCoCos(ast);\n\n      if(cmd.hasOption(\"s\")){\n        String storeLocation = cmd.getOptionValue(\"s\");\n        storeSymbols(modelTopScope, storeLocation);\n      }\n\n      // analyze the model with a visitor\n      CountStates cs = new CountStates();\n      AutomataTraverser traverser = AutomataMill.traverser();\n      traverser.add4Automata(cs);\n      ast.accept(traverser);\n      Log.info(\"Automaton has \" + cs.getCount() + \" states.\", \"AutomataTool\");\n      prettyPrint(ast,\"\");\n    }else{\n      printHelp(options);\n    }\n  } catch (ParseException e) {\n    // e.getMessage displays the incorrect input-parameters\n    Log.error(\"0xEE752 Could not process AutomataTool parameters: \" + e.getMessage());\n  }\n}\n</code></pre> Listing 2.27: Main method of the <code>AutomataTool</code> class <p>The <code>AutomataTool</code> provides a <code>main</code> method, which can be called from the command line. The implementation of the method is depicted in Listing 2.27. It expects two inputs. The first is the name of a file containing an <code>Automata</code> model. The second input is the name of the file in which the tool should store the symbol table of the model given as first input.</p> <p>The method</p> <ul> <li>parses the input model,</li> <li>creates the symbol table,</li> <li>resolves a state,</li> <li>executes context conditions,</li> <li>stores the symbol table by using the serialization,</li> <li>executes the visitor for counting the states, and</li> <li>pretty prints the model to the standard output.</li> </ul> <p>Inspect the main method and try to understand the implementation for the executed tasks. Read the above descriptions again if necessary.</p>"},{"location":"docs/GettingStarted/#run-the-tool","title":"Run the Tool","text":"<p>The previous command compiles the handwritten and generated code including the <code>Automata</code> tool class <code>AutomataTool</code>. For running the <code>Automata</code> DSL tool, execute the following command:</p> CLIGradle <p>With Powershell on Windows <pre><code>java -cp \"src/;out/;hwc/;monticore-rt.jar\" `\n                    automata.AutomataTool -i example/PingPong.aut `\n                    -s st/PingPong.autsym\n</code></pre> With Bash on Unix <pre><code>java -cp \"src/:out/:hwc/:monticore-rt.jar\" \\\n                    automata.AutomataTool -i example/PingPong.aut \\\n                    -s st/PingPong.autsym\n</code></pre> With cmd on Windows <pre><code>java -cp \"src/;out/;hwc/;monticore-rt.jar\" ^\n                    automata.AutomataTool -i example/PingPong.aut ^\n                    -s st/PingPong.autsym\n</code></pre></p> <p>Please note again, on Unix systems paths are separated using \":\" (colon) instead of semicolons. Executing the command runs the <code>Automata</code> DSL tool.</p> <p>Using the option <code>-cp</code> makes the Java interpreter consider the compiled classes contained in the paths specified by the argument.</p> <p>The argument <code>automata.AutomataTool</code> makes the Java interpreter execute the main method of the class <code>automata.AutomataTool</code> contained in the directory <code>src</code>.</p> <p>With JUnit Run the <code>AutoamtaToolTest</code> JUnit test.</p> <p>With Powershell on Windows <pre><code>java -jar target/libs/automaton-7.7.0-tool.jar `\n                    -i src/test/resources/automata/parser/PingPong.aut `\n                    -s st/PingPong.autsym\n</code></pre> With Bash on Unix <pre><code>java -jar target/libs/automaton-7.7.0-tool.jar \\\n                    -i src/test/resources/automata/parser/PingPong.aut \\\n                    -s st/PingPong.autsym\n</code></pre> With cmd on Windows <pre><code>java -jar target/libs/automaton-7.7.0-tool.jar ^\n                    -i src/test/resources/automata/parser/PingPong.aut ^\n                    -s st/PingPong.autsym\n</code></pre></p> <p>You will have to run <code>gradle build</code> to create the tool.jar.</p> <p>Executing the command runs the <code>Automata</code> DSL tool. The automaton-...-tool.jar is a packaged jar file with the AutomataTool  as its entry point.</p> <p>The argument <code>example/PingPong.aut</code> is passed to the main method of the <code>Automata</code> DSL tool class as input. Inspect the output on the command line, which displays log messages concerning the processing of the example <code>Automata</code> model.</p> <p>The last argument <code>st/PingPong.autsym</code> is also passed to the main method. It makes the tool store the serialized symbol table of the input model into the file <code>example/PingPong.aut</code>.</p> <p>The shipped example <code>Automata</code> DSL (all sources contained in <code>mc-workspace/src</code> and <code>mc-workspace/hwc</code>) can be used as a starting point for creating your own language. It can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described above.</p>"},{"location":"docs/GettingStarted/#using-monticore-in-eclipse","title":"Using MontiCore in Eclipse","text":"<p>The MontiCore plugin can be used in Eclipse. Section 2.4.1 describes the process of setting up Eclipse. Section 2.4.2 presents how to import the example project in Eclipse. Finally, Section 2.4.3 explains how the MontiCore Gradle plugin can be executed in Eclipse.</p>"},{"location":"docs/GettingStarted/#setting-up-eclipse","title":"Setting up Eclipse","text":"<p>Before you import the example project and run MontiCore as a Gradle plugin, please make sure that a current version of the Gradle plugin is installed in Eclipse. When installing a new version of Eclipse, the Gradle plugin is installed by default. If the Gradle plugin is not yet integrated into your Eclipse installation, download the latest Eclipse version or perform the following steps to install the Eclipse plugin:</p> <ol> <li>Download and install Eclipse (or use an existing one).</li> <li>Open Eclipse.</li> <li>Install the needed Plugins.<ul> <li>Help &gt; Eclipse Marketplace...</li> <li>Type 'gradle' in the search box and click Enter.</li> <li>Install the 'Buildship Gradle Integration' plugin.</li> </ul> </li> <li>Make sure to configure Eclipse to use an JDK instead of an JRE.<ul> <li>Window &gt; Preferences &gt; Java &gt; Installed JREs.</li> </ul> </li> </ol>"},{"location":"docs/GettingStarted/#importing-the-example","title":"Importing the Example","text":"<p>The shipped example <code>Automata</code> DSL can be used as a starting point. Once imported into Eclipse, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.4.3. To import the example, perform the following steps:</p> <ol> <li>Download and unzip the <code>Automata</code> example: <pre><code>http://www.monticore.de/download/Automaton.zip\n</code></pre></li> <li>Open Eclipse and select<ul> <li>File &gt; Import &gt; Gradle (if you are required to choose a Gradle     version, then choose version 7.6.4) &gt; Existing Gradle     Projects &gt; Next.</li> <li>Click on the Browse.. button and import the directory that     contains the file <code>build.gradle</code> from the <code>Automata</code> example.</li> </ul> </li> </ol>"},{"location":"docs/GettingStarted/#running-monticore","title":"Running MontiCore","text":"<p>To execute the MontiCore Gradle plugin, perform the following steps:</p> <ul> <li>Select the Gradle Task menu (at the top or bottom, depending on     your installed Eclipse version).</li> <li>There select automaton &gt; build &gt; build (double click).</li> </ul> <p>This makes Eclipse execute the MontiCore Gradle plugin as described in  Section 2.3 of the MontiCore handbook . After installing and executing MontiCore in Eclipse, your workspace should look similar to Figure 2.28.</p> <p></p> Figure 2.28: Eclipse after importing the example project and executing MontiCore"},{"location":"docs/GettingStarted/#using-monticore-in-intellij-idea","title":"Using MontiCore in IntelliJ IDEA","text":"<p>The MontiCore plugin can be used in IDEA. Section 2.5.1 describes the process of setting up IntelliJ IDEA. Afterwards, Section 2.5.2 presents how to import the example project in Eclipse. Finally, Section 2.5.3 explains how the MontiCore Gradle plugin can be executed in IntelliJ IDEA.</p>"},{"location":"docs/GettingStarted/#setting-up-intellij-idea","title":"Setting up IntelliJ IDEA","text":"<p>For setting up IntelliJ IDEA, perform the following steps:</p> <ol> <li>Download and install IntelliJ IDEA (or use your existing installation).<ul> <li>Hint for Students: You get the Ultimate version of IntelliJ IDEA     for free.</li> </ul> </li> <li>Open IntelliJ IDEA.</li> </ol>"},{"location":"docs/GettingStarted/#importing-the-example_1","title":"Importing the Example","text":"<p>The shipped example <code>Automata</code> DSL can be used as a starting point. Once imported into IntelliJ IDEA, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.5.3. For importing the example, perform the following steps:</p> <ol> <li>Download and unzip the <code>Automata</code> example: <pre><code>http://www.monticore.de/download/Automaton.zip\n</code></pre></li> <li>In the IDE select: File &gt; Open.</li> <li>Select the directory containing the build.gradle (if you are     required to choose a Gradle version, then choose version 6.7.1).</li> </ol>"},{"location":"docs/GettingStarted/#running-monticore_1","title":"Running MontiCore","text":"<p>To execute the MontiCore Gradle plugin, perform the following steps:</p> <ul> <li>Select the Gradle Projects menu on the right.</li> <li>From there select automaton &gt; Tasks&gt; build &gt; build (double click).</li> </ul> <p>This makes IntelliJ IDEA execute the Gradle plugin as described in Section 2.3. If you do not see the Gradle Projects menu yet, right-click on the build.gradle file and select 'Import Gradle Project'. Now the Gradle Projects menu should occur on the right side and you can follow the above mentioned steps for the execution. After installing and executing MontiCore in IntelliJ IDEA, your workspace should look similar to Figure 2.29.</p> <p></p> Figure 2.29: IntelliJ IDEA after importing the example project and executing MontiCore"},{"location":"docs/GettingStarted/#using-monticore-with-gitpod","title":"Using MontiCore with GitPod","text":"<p>Installing all the prerequisites and an IDE can take some time. Alternatively to this, you can use Gitpod, an open-source Kubernetes application for ready-to-code developer environments. It already has all the prerequisites and an operational Web IDE similar to Microsoft's Visual Studio Code installed. You need to login with an existing GitHub account to use it. </p> <p>This link can be used to access the Gitpod project for the <code>Automata</code> language. First, an environment for the project with the proper Java and Gradle version will be prepared and initialized automatically. After that, you will be directed to the Web IDE. The project will be built with Gradle first, and after that it is ready-to-use. The Web IDE also has a  built-in terminal which can be used to build the project via <code>gradle build</code>  or execute other tasks. </p> <p>The Web IDE can be used to change existing project files, such as the <code>Automata</code> grammar or the handwritten classes for the language. Simply navigate to the grammars or classes in the file explorer on the left-hand side of the IDE and edit the files.  This makes experimenting with MontiCore possible. The changes will be compiled by the IDE immediately and compilation errors will be marked with red color. To run the project, execute the command <code>gradle build</code> in the terminal.</p> <p>You will notice that the link to the Gitpod project is generated and always has the same pattern. An example for a link is https://indigo-ostrich-8psdfoer.ws-eu18.gitpod.io. After 30 minutes of non-use, Gitpod will \"freeze\" the environment. It can be reactivated by using the same link to access it. The environment is reactivated, and you do not even need to rebuild the project with Gradle to use the project again.</p>"},{"location":"docs/GettingStarted/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/Gradle/","title":"Gradle","text":""},{"location":"docs/Gradle/#changes-to-the-gradle-build","title":"Changes to the Gradle build","text":"<p>With MontiCore version 7.6.0, the <code>monticore</code> gradle plugin has been replaced with the <code>de.monticore.generator</code> plugin. It supports the default use case for the MontiCore generator out of the box.</p>"},{"location":"docs/Gradle/#default-project-setup","title":"Default Project Setup","text":"<pre><code>plugins {\n    id \"java-library\"\n    id \"de.monticore.generator\" version \"$mc_version\"\n}\ndependencies {\n    grammar \"de.monticore:monticore-grammar:$mc_version\"\n}\n// And thats it - no further task definitions or dependencies required (except repositories)!\n</code></pre> <p>For every Gradle source set, such as main or test, a <code>MCGenTask</code> is automatically added which builds all grammars of the source set. For example, <code>generateMCGrammars</code> builds all grammars in the <code>src/main/grammars</code> folder. Unlike with the old <code>MCTask</code>, which required one task per grammar, the new <code>MCGenTask</code> task builds all grammars incrementally. The generated java files are automatically added to the source sets <code>java</code> sources.</p> <p>A work action is created for every grammar which is required to be worked on and thus, multiple grammars can be build in parallel.</p>"},{"location":"docs/Gradle/#example-project-setup","title":"Example Project Setup","text":"<p>The following project setup combines the default project setup  with the SE codestyle plugin and sets up jUnit tests:</p> <pre><code>plugins {\n    id \"java-library\" // Java, while providing specific knowledge about Java libraries\n    id \"de.monticore.generator\" version \"$mc_version\" // MontiCore plugin\n    id \"de.se_rwth.codestyle\" version \"$mc_version\" // Enforces &amp; Provides SE CodeStyle\n}\n\njava {\n  // Configure the java toolchain to use Java 11 (overriding the locally installed JDK)\n  // https://docs.gradle.org/current/userguide/toolchains.html\n  toolchain {\n    languageVersion = JavaLanguageVersion.of(11)\n  }\n}\n\ndependencies {\n  // Depend on the MontiCore language library (which in term depends on the runtime)\n  grammar \"de.monticore:monticore-grammar:$mc_version\"\n  // and depend on the junit dependencies\n  testImplementation \"org.junit.jupiter:junit-jupiter-api:$junit_version\"\n  testRuntimeOnly \"org.junit.jupiter:junit-jupiter-engine:$junit_version\"\n}\n\n// Where can we find the dependencies?\nrepositories {\n  if ((\"true\").equals(getProperty('useLocalRepo'))) {\n    mavenLocal() // in our local maven repository\n  }\n  maven { // in the se-nexus\n    credentials.username mavenUser\n    credentials.password mavenPassword\n    url repo\n  }\n}\n\ntest {\n  // Detect junit 5 tests\n  useJUnitPlatform()\n}\n</code></pre> <p>The following gradle.properties file can be used:</p> <pre><code>mavenUser=${user}\nmavenPassword=${pass}\nrepo=https://nexus.se.rwth-aachen.de/content/groups/public\nuseLocalRepo=false\nmc_version=REPLACE-ME\n</code></pre>"},{"location":"docs/Gradle/#configuration","title":"Configuration","text":"<p>The automatically added <code>generateMCGrammars</code> task is configured with some defaults, which can be modified via the build file. For example, the following build file snippet changes the output directory:</p> <pre><code>generateMCGrammars {\n    // manually change the output directory\n    outputDir = project.layout.buildDirectory.dir(\"mc\")\n}\n</code></pre> <p>The following table shows the main configuration options</p> Option (, alias) Description Type Default grammar (, input) The grammar files ConfigurableFileCollection <code>src/${sourceSet}/grammars</code> handWrittenCodeDir (, hwc, handcodedPath ) Directories for detecting hand-written code that needs to be integrated. ConfigurableFileCollection <code>src/${sourceSet}/java</code> handWrittenGrammarDir (, hwg) Directories for detecting hand-written grammar modifications that need to be integrated. ConfigurableFileCollection <code>src/${sourceSet}/grammarsHC</code> templatePath (, tmplDir) Directories for detecting hand-written templates to integrate. ConfigurableFileCollection <code>src/${sourceSet}/resources</code> configTemplate template to configure the integration of hand-written templates. Thus, it can only be used in conjunction with a valid templatePath. String absent script Groovy script to control the generation workflow. String <code>monticore_standard.groovy</code> modelPath Directories in which symbols or grammars are searched. ConfigurableFileCollection absent outputDir Directory to which the output should be written to Directory <code>$buildDir/generated-sources/monticore/${sourceSet}-sourcecode</code> reportDir Directory to which the reports should be written to Directory <code>$buildDir/mc_reports/task_$taskname</code> debug Enables developer logging and boolean <code>false</code> genDST Whether domain specific transformation infrastructure should be generated (only suitable for TR grammars) boolean <code>false</code> genTag Whether tagging infrastructure should be generated (only suitable for TagDefinition grammars) boolean <code>false</code> groovyHook1 Groovy script that is hooked into the workflow of the standard script at hook point one, which is called after initialization, before the actual workflow begins. File absent groovyHook2 Groovy script that is hooked into the workflow of the standard script at hook point two, which is called before the generation step. File absent moreArgs Additional arguments passed to the Tool. <code>List&lt;String&gt;</code> <code>[]</code>"},{"location":"docs/Gradle/#grammar-dependencies","title":"Grammar Dependencies","text":"<p>To depend on another language project, simply use the <code>grammar</code> configuration:</p> <pre><code>dependencies {\n  grammar \"de.monticore.lang:mydsl:$mc_version\"\n  testGrammar \"de.monticore.lang:mytestdsl:$mc_version\"\n}\n</code></pre> <p>This adds the java-library variant (aka implementation) to the java classpath, and the grammar files to the symbol path.</p> <p>Note: Grammar dependencies are transitive,  which includes the implementation/java dependencies as well (such as the monticore-runtime).</p>"},{"location":"docs/Gradle/#examples","title":"Examples","text":"<p>In most cases, adding the plugin should be enough. The following snippets show examples, in which the default configuration is modified:</p>"},{"location":"docs/Gradle/#different-modelpath","title":"Different ModelPath","text":"<pre><code>generateMCGrammars {\n    modelPath(\"$projectDir/src/main/grammars\", \"$projectDir/src/notquitemain/grammars\")\n}\n</code></pre> <p>Note: We have introduced a breaking change to the <code>modelPath()</code> behavior: It is no longer possible to specify multiple directories by calling <code>modelPath(...)</code> multiple times, instead a comma-seperated list is to be used. The legacy usage now aborts with a descriptive error.</p>"},{"location":"docs/Gradle/#different-workflow-script","title":"Different workflow script","text":"<pre><code>generateMCGrammars {\n    script = \"de/monticore/monticore_noreports.groovy\"\n}\n</code></pre>"},{"location":"docs/Gradle/#specify-groovy-hooks","title":"Specify Groovy Hooks","text":"<pre><code>generateMCGrammars {\n    groovyHook1 = file \"$projectDir/gs1.groovy\"\n    groovyHook2 = file \"$projectDir/gs2.groovy\"\n}\n</code></pre>"},{"location":"docs/Gradle/#configtemplate","title":"ConfigTemplate","text":"<pre><code>generateMCGrammars {\n  configTemplate = \"ct.ftl\"\n  templatePath \"$projectDir/src/main/tpl\"\n}\n</code></pre> <p>Note: Incremental building after changes to the templatePath directory contents is not supported. Instead, a full-rebuild is enforced.</p>"},{"location":"docs/Gradle/#transformation-grammars","title":"Transformation Grammars","text":"<p>Simply use the <code>de.monticore.generator-withtr</code> gradle plugin. You can set a <code>genTR</code> property to any value different than <code>true</code> to disable the trafo generation.</p> <p>To further exclude grammars, you can filter on the <code>extractTRGrammars</code> task:</p> <pre><code>if ((\"true\").equals(getProperty('genTR'))) {\n  // Further exclude the grammar and basic tf grammars from being included in the TR grammar input set\n  extractTRGrammars {\n    exclude([\"**/de/monticore/tf/*\", \"**/de/monticore/grammar/*\", \"**/de/monticore/siunit/*\"])\n  }\n}\n</code></pre>"},{"location":"docs/Gradle/#custom-mcgentask","title":"Custom MCGenTask","text":"<p>A <code>generateModifiedGrammars</code> task to generate all grammars generated by another task (and with an additional filter, only matching grammar files starting with a captital <code>A</code>.)</p> <pre><code>// register a new MCGenTask task\ntasks.register(\"generateModifiedGrammars\", MCGenTask) {\n    grammar.setFrom(tasks.named(\"modifyGrammars\").get()\n        .getOutputs().getFiles().getAsFileTree()\n        .matching(patternFilterable -&gt; patternFilterable.include( \"**/A*.mc4\")))\n    outputDir = file myModOutDir\n    modelPath.from(file modifyGrammarsOutD) // the directory hierarchy is required here\n    if (findProperty(\"ci\") != null) {\n      script = \"de/monticore/monticore_noreports.groovy\"\n    }\n}\n// Note: The output directory has to manually be added to the java sources, if desired\nsourceSets {\n  // we explicitly use the outputDir property instead of the myModOutDir variable\n  // to give Gradle further insights into the build setup\n  main.java.srcDirs += tasks.generateModifiedGrammars.getOutputDir()\n}\n</code></pre>"},{"location":"docs/Gradle/#custom-sourceset","title":"Custom SourceSet","text":"<p>Additional source sets for MontiCore grammars, such as trafos and tagging, can be defined and published. Note: Trafos and Tagging can be set up using a specific plugin.</p> <pre><code>sourceSets {\n  variantB {\n    grammars {\n      srcDir(\"src/main/variantBGrammars\")\n    }\n  }\n}\n\ndependencies {\n  // add grammar dependencies to variant B\n  variantBGrammar \"de.monticore:monticore-grammar:$mc_version\"\n}\n\nmonticoreGenerator {\n  // publish the MC artifacts of the \"variantB\" source set\n  publishSourceSet(project.sourceSets.variantB)\n}\n</code></pre>"},{"location":"docs/Gradle/#improvements-over-the-old-mctask","title":"Improvements over the old <code>MCTask</code>","text":"<ul> <li>Improved incremental build support</li> <li>Added Gradle build cache support</li> <li>Added parallel task execution support</li> <li>Using Gradle task definitions which can be used for Gradle plugins of MontiCore language tools</li> <li>Transitive grammar dependencies</li> <li>Handling of test grammars (and source sets)</li> </ul>"},{"location":"docs/Gradle/#added-build-elements","title":"Added build elements","text":"<ul> <li>For every source set, the MontiCore generator plugin adds:<ul> <li>A <code>grammar</code> SourceSetDirectory extension (e.g. <code>sourceSets.main.grammars</code>) to the source set</li> <li>A <code>generate${sourceSetName}MCGrammars</code> task building (by default) all grammars of the source set</li> <li>Two configurations:<ul> <li><code>grammar</code> (or <code>${sourceSetName}Grammar</code> for non-main source sets):   Used to declare dependencies to other MontiCore language projects.   This configuration will not be resolved, instead the <code>implementation</code> and <code>grammarSymbolDependencies</code> extend   this   configuration and resolve their respective variants as dependencies.</li> <li>(internal) <code>grammarSymbolDependencies</code> (or <code>${sourceSetName}GrammarSymbolDependencies</code>):   Dependencies (jars containing the .mc4 files) will be added to the ModelPath.   This configuration extends the previous dependency-defining grammar.   Do not declare dependencies using this configuration.</li> </ul> </li> <li>In case publishing is enabled (by default, only for the main source set):<ul> <li>A <code>grammarSymbolOutElements</code> (or <code>${sourceSetName}GrammarSymbolOutElements</code>) configuration &amp; variant:<ul> <li>Contains the grammars jar as an artifact.</li> </ul> </li> <li>Three <code>Jar</code> tasks (with publishing their artifacts):<ul> <li><code>${sourceSetName}GrammarsJar</code></li> <li><code>${sourceSetName}Jar</code> (only for non-main source sets)</li> <li><code>${sourceSetName}sourcesJar</code> (only for non-main source sets)</li> </ul> </li> <li>An ad-hoc component <code>grammars${sourceSetName}</code></li> <li>An   alias MavenPublication   named identical to the source set (only for non-main source sets)</li> </ul> </li> </ul> </li> <li>Grammars declared in the main source set are also available in the test source sets.</li> </ul>"},{"location":"docs/Gradle/#implementation-specifics","title":"Implementation specifics","text":"<p>MontiCore suffers from a memory leak caused by the GroovyInterpreter. The parallel, isolated execution of the generator intensifies this memory leak (which is why we limit it using <code>--max-workers=4</code>). This might be fixed by 8078641 in jdk 18+.</p>"},{"location":"docs/Gradle/#migration-guide-using-the-new-plugin","title":"Migration Guide: Using the new plugin","text":"<ul> <li>Replace plugins <code>id \"monticore\"</code> with <code>id \"de.monticore.generator\"</code></li> <li>Remove the creation of individual MCTasks</li> <li>Modelpath adding: see above using the source sets</li> <li>Ensure the generation target is NOT added to the java sources (otherwise the TOP mechanism will fail)</li> <li>Ensure no resources.srcDirs += grammarOutDir is used (otherwise your build will depend on itself)</li> </ul>"},{"location":"docs/Gradle/#using-legacy-dependencies-with-the-new-plugin","title":"Using legacy-dependencies with the new plugin","text":"<p>Due to the diverging capabilities/variants of the new plugin,  the resolution of legacy built grammars requires additional effort:</p> <pre><code>configurations {\n  legacyGrammar // configuration for legacy-MC-projects\n}\ndependencies {\n  // resolve the grammars of myolddsl\n  legacyGrammar \"de.monticore.languages:myolddsl:7.7.0:grammars\"\n  // we also have to add the implementation/java classes\n  implementation \"de.monticore.languages:myolddsl:7.7.0\"\n}\ntasks.generateMCGrammars.configure {\n  // Add the legacy-grammars to the symbol/model path of the generation\n  symbolPathConfiguration.from(configurations.legacyGrammar)\n}\n</code></pre>"},{"location":"docs/Languages/","title":"List of Languages","text":""},{"location":"docs/Languages/#monticore-languages-of-level-ii-an-overview","title":"MontiCore Languages of Level II - an Overview","text":"<p>MontiCore is a language workbench with an explicit notion of language components. It uses  grammars to describe textual DSLs.  MontiCore uses an extended grammar format that allows to compose  language components via inheritance, embedding and aggregation (see the  handbook for details).</p> <p>A language component is mainly represented through  (1) the grammar describing concrete and abstract syntax of the language,  (2) Java-classes implementing specific functionalities, and  (3) Freemarker-Templates helping to print a model to text. However, language components are often identified with their main  component grammar.</p> <p>Language components are currently organized in two levels: In this list you mainly find grammars for  complete (but also reusable and adaptable) languages (Level II). A list of grammar components with individual reusable nonterminals is also available in the MontiCore core project  (development status) (Level I).</p> <p>The following list contains the language grammars found in the <code>MontiCore</code> projects, such as <code>cd4analysis/cd4analysis</code>. They are usually contained in project folders like <code>src/main/grammars/</code>  and organized in packages like <code>de.monticore.cd</code>. Publicly available MontiCore projects are hosted at <code>https://github.com/MontiCore</code>.</p>"},{"location":"docs/Languages/#list-of-languages","title":"List of Languages","text":""},{"location":"docs/Languages/#class-diagram-for-analysis-cd4a-monticore-stable","title":"Class Diagram For Analysis (CD4A) (MontiCore stable)","text":"<ul> <li>CD4A is the textual representation to describe UML class diagrams    (it uses the UML/P variant).</li> <li>CD4A covers classes, interfaces, inheritance, attributes with types,   visibilities,   and all kinds of associations and composition, including qualified   and ordered associations. Classes can be placed in different packages.   An example: <pre><code>classdiagram MyLife { \n  abstract class Person {\n    int age;\n    Date birthday;\n    List&lt;String&gt; nickNames;\n  }\n  package com.universityLib {\n    &lt;&lt;myStereotype&gt;&gt; class Student extends Person {\n      StudentStatus status;\n    }\n    enum StudentStatus { ENROLLED, FINISHED; }\n  }\n\n  composition Person -&gt; Address [*]  {ordered};\n  association [0..2] Person (parent) &lt;-&gt; (child) Person [*];\n  association phonebook Person [String] -&gt; PhoneNumber ;\n}\n</code></pre></li> <li>CD4A focuses on the analysis phase in typical data-driven development    projects and is therefore mainly for data modelling.   Consequently, it omits method signatures and complex generics.   The primary use of the CD4A language is therefore data modelling. The   CD4A language opens various possibilities for the development of data   structures, database tables as well as data transport infrastructures in   cloud and distributed systems.</li> <li>Main grammar <code>de.monticore.cd.CD4Analysis</code>   and    detailed description</li> </ul>"},{"location":"docs/Languages/#class-diagram-for-code-cd4code-monticore-stable","title":"Class Diagram for Code (CD4Code) (MontiCore stable)","text":"<ul> <li>CD4Code describes UML class diagrams.</li> <li>CD4Code is a conservative extension of CD4A,    which includes method signatures. An example: <pre><code>classdiagram MyLife2 {\n  // like CD4A but also allows:\n  class Person {\n    protected List&lt;Person&gt; closestFriends(int n);\n    void addFriend(Person friends...);\n    &lt;&lt;myStereotype&gt;&gt; void relocate();\n  }\n}\n</code></pre></li> <li>CD4Code is often used as tool-internal AST that allows to   map any kind of source models to a class/attribute/method/association based   intermediate structure, before it is printed e.g. as Java code.    For example a transformation sequence could be: </li> <li>MontiCoreCLI:      Grammar -&gt;      Grammar AST encoded in CD4Code -&gt;     Decoration for custom behavior -&gt;      Java code</li> <li>Statechart -&gt; State pattern encoded in CD4Code    -&gt; Decoration by monitoring methods -&gt; Java code.</li> <li>Main grammar <code>de.monticore.cd.CD4Code</code>   and    detailed description    (see Section CD4Code)</li> </ul>"},{"location":"docs/Languages/#feature-diagrams-monticore-stable","title":"Feature Diagrams (MontiCore stable)","text":"<ul> <li>Language for feature models and feature configurations.</li> <li>Feature diagrams are used to model (software) product lines and their variants.</li> <li>Feature configurations select a subset of features of a feature model    to describe a product of the product line. An example: <pre><code>featurediagram MyPhones {\n  Phone -&gt; Memory &amp; OS &amp; Camera? &amp; Screen;\n  Memory -&gt; Internal &amp; External?;\n  Internal -&gt; [1..2] of {Small, Medium, Large};\n  OS -&gt; iOS ^ Android;\n  Screen -&gt; Flexible | FullHD;\n\n  Camera requires (iOS &amp;&amp; External) || Android ;\n}\n</code></pre>   Rules <code>F -&gt; ...</code> have a parent feature (left-hand side)    and its child features (right-hand side).    Operators are: optional feature <code>?</code>, and <code>&amp;</code>, or <code>|</code>, xor <code>^</code>,   and subset cardinality constraints, like <code>[1..2] of ...</code>.   Further, a feature model may define cross-tree constraints using logic    operators and <code>&amp;&amp;</code>, or <code>||</code>, implication <code>requires</code>, etc.</li> <li>Main grammar <code>FeatureDiagram</code>   and    detailed description</li> </ul>"},{"location":"docs/Languages/#gui-dsl-monticore-stable-not-publicly-available-links-are-private","title":"GUI DSL: (MontiCore stable) - not publicly available (links are private)","text":"<ul> <li>Language for textual definition of Graphical User Interfaces of Web Applications</li> <li>GUI DSL covers GUI elements and relevant configuration, which include layout elements, widgets, their style definition and references to data sources.</li> <li>Language is mainly used to describe GUI of Web Applications. The models of the language represents graphical views or their parts, omitting smaller details of style definition and simplifying connection between graphical elements and data sources.</li> <li>Currently, new version of the <code>GUIDSL</code> is being developed:</li> <li>Basis grammar <code>GUIBasis</code> includes constructs for general visualization component definitions, control statements and components for layout description.</li> <li>Example models can be found in the same repository.</li> <li>Main grammar <code>GUIDSL</code> includes basic concepts and more specific implementation of component configuration.</li> <li>In projects legacy version is currently used:</li> <li>Examples: MaCoCo,               Ford</li> <li>Main grammar <code>GUIDSL</code> includes definitions of MontiGem visualisation components, which are based on abstract concepts, described in core grammar <code>GUIDSLCore</code>. Detailed description and documentation.</li> </ul>"},{"location":"docs/Languages/#monticore-grammar-monticore-stable","title":"MontiCore Grammar (MontiCore Stable)","text":"<ul> <li>Language for MontiCore Grammars itself. It can be understood as    meta language, but also used as ordinary language.</li> <li>Its main use currently: A MontiCore grammar defines the    concrete syntax and the abstract syntax of a textual language.   Examples: All languages on this page are defined using MontiCore grammars   and thus conform to this Grammar.</li> <li>Main features: Define nonterminals and their productions in EBNF,    lexical token as regular expressions. </li> <li>Most important extensions to standard grammars:</li> <li>Abstract, interface and external productions allow to     define extensible component grammars (object-oriented grammar style).</li> <li>Inherited productions can be redefined (overwritten) as well     as conservatively extended.</li> <li>Symbol and scope infrastructure is defined by simple keywords.</li> <li>Symbols definition places can be introduced and      symbol referencing places defined, such that for standard cases     automatically symbol tables can be added.</li> <li>Additional attributes and methods can be added to the abstract syntax only.</li> <li>Various elements, such as semantic predicates and actions     can be defined in the same style as the underlying ANTLR.</li> <li>MontiCore grammars can be left recursive and even allow mutual recursion.      This is e.g. useful for expression hierarchies.</li> <li>Additional elements, such as enum productions and comfortable      operations for grammar definitions exist.</li> <li>Main grammars    <code>de.monticore.grammar.Grammar</code>   defines the language with some open parameters and   <code>de.monticore.grammar.Grammar_WithConcepts</code>   binds the external, imported expressions, method bodies, etc.</li> <li>Detailed description   in the MontiCore Handbook.</li> </ul>"},{"location":"docs/Languages/#json-monticore-stable","title":"JSON (MontiCore Stable)","text":"<ul> <li>The MontiCore language for parsing JSON artifacts. An example: <pre><code>{ \"Alice\": {\n    \"fullname\": \"Alice Anderson\",\n    \"address\": {\n      \"postal_code\": 10459, \n      \"street\": \"Beck Street\",\n      \"number\": 56              }  },\n  \"Bob\": { ... },\n  \"Caroll\": { ... }, ...\n}\n</code></pre></li> <li>The JSON grammar adheres to the common JSON standard and allows parsing    arbitrary JSON artifacts for further processing.</li> <li>Actually the grammar represents a slight superset to the official JSON standard.    It is intended for parsing JSON-compliant artifacts. Further well-formedness   checks are not included, because we assume to parse correctly produced JSON    documents only.</li> <li>Please note that JSON (like XML or ASCII) is primarily a carrier language.   The concrete JSON dialect and the question, how to recreate the   real objects / data structures, etc. behind the JSON tree structure   is beyond this grammar, but can be applied to the AST defined here.</li> <li>Main grammar    <code>de.monticore.lang.JSON</code>   and    detailed description</li> </ul>"},{"location":"docs/Languages/#montiarc-monticore-stable","title":"MontiArc (MontiCore Stable)","text":"<ul> <li>MontiArc is an architecture and behavior modeling language and framework      that provides a platform independent structure and behavior      modeling language with an extensible code generation framework.</li> <li>MontiArc covers components their ports, connectors between    components and   embedded statecharts for component behavior description. </li> <li>Statecharts define states and transitions with conditions on    the incoming messages as well as transition actions.    An example: <pre><code>component InteriorLight {                           // MontiArc language\n  port in Boolean lightSignal,          // ports\n       in Boolean doorSignal\n       out OnOff status;\n  ORGate or;                            // used subcomponents\n  lightSignal -&gt; or.a;                  // connectors\n  doorSignal -&gt; or.b;\n  or.c -&gt; cntr.signal;\n  component LightController cntr {      // freshly defined subcomponent \n    port in OnOff signal,\n         out OnOff status;\n    statechart {                        // with behavior by a Statechart\n      initial state Off / {status = OFF};\n      state On;\n      Off -&gt; On [ signal == true ] / {status = ON}\n      On -&gt; Off [ signal == false ] / {status = OFF}\n    }\n  }\n  cntr.status -&gt; status;\n}\n</code></pre></li> <li>MontiArc's main goal is to provide a textual notation for Component&amp;Connector    diagrams, which is used quite often in various variants in industry.   E.g. SysML's BDD, UML's component composition diagrams use the same    paradigm. </li> <li>MontiArc does not define data types for their signals, but assumes    that these types can be imported (e.g. from a class diagram).</li> <li>MontiArc itself also has no timing predefined, but for a complete    language a concrete timing, such as formally grounded by Focus,    should be added.</li> <li>Main grammar    <code>MontiArc.mc4</code>   and    detailed description</li> </ul>"},{"location":"docs/Languages/#oclp-monticore-stable","title":"OCL/P (MontiCore Stable)","text":"<ul> <li>OCL/P is the textual representation of the UML OCL standard, adapted    with Java-like syntax.   Its main goal is the usage in combination with other languages like    CD4A or Object Diagrams as an integrated part of that languages.</li> <li> <p>OCL/P allows to define invariants and pre-/post-conditions in    the known OCL style plus some extensions, such as    a generalized <code>let</code> construction.    Furthermore, it offers a large set expressions   to model constraints. These expressions include Java expressions,   set operations, list operations etc., completely covering the    OCL standard concepts, but extend it e.g. by set comprehensions    known from Haskell, a typesafe cast or a    transitive closure operator.   An example shows several of the above-mentioned syntactic features: <pre><code>ocl Bookshop {\n  context Shop s inv CustomerPaysBeforeNewOrder:      // invariant\n    forall Customer c in s.customers:                 // quantifiers available\n      c.allowedToOrder implies !exists Invoice i in s.invoices:\n        i.customer == c &amp;&amp; i.moneyPayed &lt; i.invoiceAmount ;\n\n  // Method specification for selling a book\n  context Invoice Stock.sellBook(String iban, int discountPercent, Customer c) \n    let availableBooks =                              // set comprehension\n          { book | Book book in booksInStock, book.iban == iban }\n    pre:  !availableBooks.isEmpty &amp;&amp;                  // precondition\n          c.allowedToOrder;\n    post: let discount = (100 - discountPercent)/100; // postcondition, let\n              b = result.soldBook                     // result variable \n          in                                        \n              !(b isin booksInStock) &amp;&amp;\n              booksInStock.size@pre == booksInStock.size + 1 &amp;&amp;  // @pre\n              result.invoiceAmount == b.price * discount;  // result variable \n}\n</code></pre></p> </li> <li> <p>The OCL language component contains four grammars:</p> </li> <li>OCL,</li> <li>OCLExpressions, </li> <li>OptionalOperators, and</li> <li>SetExpressions. </li> <li>The detailed description provides an in-depth guide for language engineers.</li> </ul>"},{"location":"docs/Languages/#object-diagrams-monticore-stable","title":"Object Diagrams (MontiCore Stable)","text":"<ul> <li>OD is a language for textual denotation of object diagrams. The OD language   has several purposes (when combined with appropriate language extensions):</li> <li>specification language for object structures (as part of the UML/P)</li> <li>store and transport of data sets (e.g. the artifact analysis toolchain), and</li> <li>report format for the MontiCore tool infrastructure. </li> <li>OD covers named and anonymous objects, object types, links, attributes, attribute values,    lists, maps, and   visibilities. Special data types, such as Date allow comfortable   definition and reading of ODs. For a comfortable definition, objects may be nested   into trees while easily retaining their full graph structure. An example: <pre><code>objectdiagram MyFamily {\n  alice:Person {\n    age = 29;\n    cars = [\n      :BMW {\n        color = BLUE;\n      },\n      tiger:Jaguar {\n        color = RED;\n        length = 5.3; \n      }\n    ];\n  };\n  bob:Person {\n    nicknames = [\"Bob\", \"Bobby\", \"Robert\"];\n    cars = [tiger];\n  };\n  link married alice &lt;-&gt; bob;\n}\n</code></pre></li> <li>If ODs are used as specification technique, e.g. for tests or forbidden    situations,   a more expressive version of expressions can be used for values    (e.g. by composing ODs with JavaExpressions). Furthermore, only    interesting attributes need to be defined (underspecification) and conformity   to a CD4A model can be checked.</li> <li>The ODs differ from JSON structures, e.g., in    the possibility to give the object a name as it is the case for <code>tiger</code>, or <code>alice</code>    enabling the definition real graph structures.</li> <li>Main grammars (directly usable):<ul> <li>OD4Data</li> <li>OD4Development</li> <li>OD4Report</li> </ul> </li> <li>Main grammar components:<ul> <li>DateLiterals</li> <li>ODBasis</li> <li>ODAttribute</li> <li>ODLink</li> </ul> </li> <li>Detailed description </li> </ul>"},{"location":"docs/Languages/#sequence-diagrams-monticore-stable","title":"Sequence Diagrams  (MontiCore stable)","text":"<ul> <li>A textual sequence diagram (SD) language.</li> <li>Detailed description</li> <li>The project includes grammars, a symbol table infrastructure, a PrettyPrinter,    and various CoCos for typechecking.</li> <li>The language is divided into the two grammars SDBasis and SD4Development.</li> <li>The grammar SDBasis is a component grammar providing basic SD language features.</li> <li>The grammar SD4Development extends the grammar SDBasis with concepts used in    UML/P SDs.</li> <li>SD4Development supports modeling objects, method calls, returns, exception    throws, dynamic object instantiation, various match modifiers for objects    (free, initial, visible, complete), lifelines with activation regions,   static method calls, intermediate    variable declarations by using OCL, and conditions by using OCL.</li> <li>The grammars can easily be extended by further interactions and object modifiers.</li> <li>The following depicts a simple SD in its textual syntax.  <pre><code>sequencediagram AuctionTest {\n  kupfer912: Auction;         // Interacting objects\n  bidPol: BiddingPolicy;\n  timePol: TimingPolicy;\n                              // Interaction sequence\n  kupfer912 -&gt; bidPol  : validateBid(bid)\n  bidPol -&gt; kupfer912  : return BiddingPolicy.OK;\n  kupfer912 -&gt; timePol : newCurrentClosingTime(kupfer912, bid) \n  timePol -&gt; kupfer912 : return t;\n  assert t.timeSec == bid.time.timeSec + extensionTime;\n}\n</code></pre></li> </ul>"},{"location":"docs/Languages/#si-units-monticore-stable","title":"SI Units (MontiCore Stable)","text":"<ul> <li>The international system of units (SI units) is a physical unit system    widely used in the entire world.    It is based on the basis units <code>s, m, kg, A, K, mol, cd</code>,    provides a variety of derived units, and can be refined using prefixes such    as <code>m</code>(milli), <code>k</code>(kilo), etc.</li> <li>The SI Unit project aims to deliver SI units to MontiCore-based    languages with expressions.    It provides a grammar for all types of SI units and prefixes usable for type    definition.</li> <li>Second, it provides the SI Unit literals, such as <code>5 km</code> as expression values   and a language for SI unit types, such as <code>km/h</code> or <code>km/h&lt;long&gt;</code>. Some examples: <pre><code>  km/h speed = 5 m / 27 s                         // variable definition using type km/h\n  speed = (3 * 4m  +  17km/h * 10h) / 3.5h        // values with SI unit types\n  \u00b0C/s&lt;float&gt; coolingSpeed;                       // types (\u00b0C/s) with precision (float)\n  g/mm^2&lt;int&gt; pressure; \n  Map&lt;Location,\u00b0C&gt; temperatures;                  // nesting of types \n</code></pre></li> <li>The SI unit literals integrate with MontiCore's expressions and the   SI Unit types integrate with MontiCore's type system.    The SI unit language remains fully type safe.</li> <li>The math version uses <code>km/h</code> as idealistic full precision real number, while the   computing version allows to contrain  the precision with <code>km/h&lt;long&gt;</code>. </li> <li>Main grammar components:<ul> <li>SI units</li> <li>SI unit literals</li> <li>SI unit types for math</li> <li>SI unit types for computations</li> <li>(other alternatives are possible; SI has not standardized anything here)</li> </ul> </li> <li>Example projects:<ul> <li>SI Java </li> </ul> </li> <li>detailed description </li> </ul>"},{"location":"docs/Languages/#statecharts-monticore-stable","title":"Statecharts (MontiCore stable)","text":"<ul> <li>A set of language variants for Statecharts (UML-like or also embedded SysML-like).</li> <li>It is possible to define syntactically simpler or more complex and comfortable   forms of statecharts using a subset of the eleven provided language components.   Two complete Statechart language variants are composed for direct usability.</li> <li>A compact teaser for one variant of the Statechart languages: <pre><code>statechart Door {\n  state Opened\n  initial state Closed\n  state Locked\n\n  Opened -&gt; Closed close() /\n  Closed -&gt; Opened open(1) / {ringTheDoorBell();}\n  Closed -&gt; Locked timeOut(n) / { lockDoor(); } [doorIsLocked]\n  Locked -&gt; Closed [isAuthorized() &amp;&amp; doorIsLocked] unlock() /\n}\n</code></pre></li> <li>This example models the different states of a door: <code>Opened</code>,    <code>Closed</code>, and <code>Locked</code>.   A transition is triggered e.g. by function/method call <code>close()</code> that    changes a from a state <code>Opened</code> to state <code>Closed</code>. </li> <li>Transitions can have actions, such as <code>{ringDoorBell();}</code> containing in    this case    Java statements, or preconditions, such  as <code>[ ... ]</code> containing a    Boolean expression.</li> <li>State invariants and transition preconditions are defined using    <code>Expressions</code>   and entry/exit/transition actions are defined using <code>Statements</code>.</li> <li>A Statechart may also have hierarchically decomposed states and    other forms of    events (not shown here).</li> <li>Detailed description </li> </ul>"},{"location":"docs/Languages/#sysml_2-alpha-intention-to-become-stable-public-version-in-preparation-links-are-private","title":"SysML_2 (Alpha: Intention to become stable) - public version in preparation (links are private)","text":"<ul> <li>MontiCore language components for parsing artifacts of the    SysML 2 language.    Example model: <pre><code>package 'Vehicles' {                      // a SysML block diagram\n  private import ScalarValues::*; \n  block Vehicle; \n  block Truck is Vehicle; \n  value type Torque is ISQ::TorqueValue; \n}\n</code></pre> <pre><code>package 'Coffee' {                      // a SysML activity diagram\n  activity BrewCoffee (in beans : CoffeeBeans, in, water : Water, out coffee : Coffee) { \n    bind grind::beans = beans;\n    action grind : Grind (in beans, out powder);\n    flow grind::powder to brew::powder;\n    bind brew::water = water;\n    action brew : Brew (in powder, in water, out coffee); \n    bind brew::coffee = coffee;\n  }\n}\n</code></pre></li> <li>The SysML v2 grammars adhere to the general upcoming SysML v2 specification </li> <li>Actually these grammars represents a slight superset to the official SysML v2   standard. It is intended for parsing SysML v2-compliant models.    Well-formedness checks are kept to a minimum, because we assume to parse   correctly produced SysML v2 models only.</li> <li>MontiCore's SysML v2 is a language that comes with a textual    representation to describe SysML v2 diagrams with respect to the standard. </li> <li>Main grammars   and    public documentation</li> </ul>"},{"location":"docs/Languages/#tagging-alpha-intention-to-become-stable-not-publicly-available-links-are-private","title":"Tagging (Alpha: Intention to become stable) - not publicly available (links are private)","text":"<ul> <li>Tags are known e.g. from the UML and SysML and mainly used to add   extra information to a model element.    Normally tags (and stereotypes) are inserted within the models,   which over time pollutes the models, especially when different sets of   tags are needed for different technical platforms.</li> <li>MontiCore offers a solution that separates a model and its tags into   distinct artifacts. Several independent tagging artifacts   can be added without any need to adapt the core model.   This allows fo reuse even of fixed library models.</li> <li>The tagging artifacts are dependent on two factors:</li> <li>First, tags can be added to named elements of the base model.     It is of great help that we have an elegant symbol mechanism included      in the MontiCore generator.</li> <li>Second, the set of allowed tags can be constrained, by an explicit     definition of allowed tag types and tag values and an explicit      declaration on which kinds of symbols a tag may be attached to.</li> <li>Consequently, tagging is not a single language, but a method to    automatically and schematically derive languages:<ul> <li>A tagging schema language TSL (dependent on the available symbol types   of the base grammar)</li> <li>a tagging language TL (dependent on the tag schema models written in TSL)</li> </ul> </li> <li>Because tagging models can e.g. be used as configuration techniques    in a code generator, appropriate infrastructure is generated as well.</li> <li>Some tagging language examples</li> <li>Although concrete languages (and their grammars) are themselves generated,   there is a    main grammar <code>ocl.monticore.lang.Tagging</code>,   where the tagging language is derived from.   See also detailed description</li> </ul>"},{"location":"docs/Languages/#use-case-diagrams-monticore-stable","title":"Use Case Diagrams  (MontiCore stable)","text":"<ul> <li>A textual use case diagram (UCD) language.</li> <li>Detailed description</li> <li>The project includes a grammar, a symbol table infrastructure,    and a semantic differencing operator.</li> <li>The language is defined by the grammar UCD.</li> <li>It supports modeling actors, use cases, preconditions,    associations between actors and use cases,   extend relations between use cases with guards,    include relations between use cases, and   specialization relations between actors and use cases.</li> <li>The grammars can easily be extended.</li> <li>The following depicts a simple UCD in its textual syntax.  <pre><code>usecasediagram Example {\n  @Player --\n    Play,\n    Pay,\n    ChangeProfilePicture;\n\n  @AndroidPlayer specializes Player;\n  @IOSPlayer specializes Player;\n\n  @Server --\n    ShowAd,\n    RegisterScore;\n\n  ShowAd extend Play [!isPremium];\n  RegisterScore extend Play;\n\n  abstract Pay include CheckPremium;\n  CreditCard specializes Pay;\n  Bank specializes Pay;\n  ChangeProfilePicture [isPremium];\n}\n</code></pre></li> </ul>"},{"location":"docs/Languages/#xml-monticore-stable","title":"XML (MontiCore Stable)","text":"<ul> <li>The MontiCore language for parsing XML artifacts. An example: <pre><code>&lt;Calendar&gt;\n  &lt;Appointment name=\"lunch\"&gt;\n    &lt;Date&gt;24.04.2020&lt;/Date&gt;\n    &lt;Time&gt;11:30&lt;/Time&gt;\n    &lt;Location&gt;cafeteria&lt;/Location&gt;\n  &lt;/Appointment&gt;\n&lt;/Calendar&gt;\n</code></pre></li> <li>The XML grammar adheres to the common XML standard and allows parsing    arbitrary XML artifacts for further processing.</li> <li>Actually the grammar represents a slight superset to the official XML standard.    It is intended for parsing XML-compliant artifacts. Further well-formedness   checks are not included, because we assume to parse correctly produced XML    documents only.</li> <li>Please note that XML (like JSON or ASCII) is mainly a carrier language.   The concrete XML dialect and the question, how to recreate the   real objects / data structures, etc. behind the XML structure   is beyond this grammar, but can be applied to the AST defined here.</li> <li>Main grammar    <code>de.monticore.lang.XML</code>   and    detailed description</li> </ul>"},{"location":"docs/Languages/#javalight-monticore-stable","title":"JavaLight (MontiCore Stable)","text":"<ul> <li>This is a reduced version of the Java language.   JavaLight is meant to be used to integrate simplified Java-like parts    in modeling languages but not to parse complete Java implementations.</li> <li>It provides Java's attribute and method definitions,    statements and expressions, but    does not provide class or interface definitions and   also no wildcards in the type system.</li> <li>One main usage of JavaLight is in the Grammar-language to model e.g.    Java methods. An example: <pre><code>public void print(String name) {\n  System.out.println(\"Hello \" + name);\n}\n</code></pre></li> <li>Main grammar <code>de.monticore.JavaLight</code>   and    detailed description.</li> </ul>"},{"location":"docs/Languages/#java-beta-in-stabilization-not-publicly-available-links-are-private","title":"Java (Beta: In Stabilization) - not publicly available (links are private)","text":"<ul> <li>This is the full Java' Language (as Opposed to JavaLight).</li> <li>Main Grammar <code>JavaDSL</code>   and   detailed description.</li> </ul>"},{"location":"docs/Languages/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"docs/MontiCoreSymposium/","title":"MontiCoreSymposium","text":""},{"location":"docs/MontiCoreSymposium/#third-monticore-symposium-23-march-26-march-2025","title":"Third MontiCore Symposium 23. March - 26. March 2025","text":"<p>MontiCore is a language workbench designed for the efficient  development of domain-specific languages (DSLs) along with their  corresponding tooling. It provides a robust infrastructure to define,  manipulate, and process languages, supporting features such as  model-to-model transformations and code generation, enhancing  productivity in software development projects.</p> <p>The goals of the MontiCore symposium are primarily to bring together  researchers, developers, and users of the MontiCore language workbench  to discuss advancements, share experiences, and explore new ideas in  the domain of domain-specific languages (DSLs). </p> <p>It aims to foster collaboration and exchange on topics such as language  design, model-driven software development, tool integration, and  practical applications of MontiCore in various fields, including SysML  v2 and UML. This symposium provides a platform for presenting  innovative research, networking, and discussing challenges and  solutions in the context of DSLs and model-based development. </p>"},{"location":"docs/MontiCoreSymposium/#location","title":"Location","text":"<p>The MontiCore symposium will be located in Gem\u00fcnd, Germany. </p>"},{"location":"docs/MontiCoreSymposium/#participation","title":"Participation","text":"<p>Participation is based on acceptance of an abstract or a full paper and  requires registration until 07th of March. </p> <p>Registration costs are tba and include accommodation,  conference fees, and meals during the symposium.  </p>"},{"location":"docs/MontiCoreSymposium/#submission","title":"Submission","text":"<p>Submissions must adhere to the ACM formatting instructions, which can  be found here. We ask for two types of contributions: </p> <p>[1] Research papers: 8 pages,  [2] Vision abstracts: 1 page.</p> <p>Submissions must be uploaded through EasyChair via this link. </p> <p>It is planned to produce post-proceedings with extended and improved  versions of the papers as result of the symposium. </p>"},{"location":"docs/MontiCoreSymposium/#important-dates-deadlines-extended","title":"Important Dates (deadlines extended)","text":"<ul> <li>10.01.2025: Paper Submission Deadline </li> <li>28.02.2025: Acceptance Notification </li> <li>07.03.2025: Registration Deadline </li> <li>23.03.2025-26.03.2025: MontiCore Symposium </li> </ul>"},{"location":"docs/MontiCoreSymposium/#call-for-papers","title":"Call for Papers","text":"<p>We solicit talk proposals concerning the application, development, and  innovation of language engineering or model-driven development around  the language workbench MontiCore. Topics of interest include, but are  not limited to:  </p> <ul> <li> <p>Novel meta-languages for language construction and composition  </p> </li> <li> <p>Holistic approaches to language engineering in MontiCore that  cross-cut multiple language aspects (e.g., abstract and concrete  syntax, semantics, transformations) and/or integrate with program  analysis, validation, testing, or other advanced techniques.  </p> </li> <li> <p>Industrial case studies: experience reports, large-scale evaluations,  best practices, and human factors to adoption.   </p> </li> <li>Model-Based DevOps</li> <li> <p>Domain-specific solutions in application domains, such as      Automotive, CPS, IOT, Production, Quantum Computing, Avionics,     HealthCare, Energy, Robotics. </p> </li> <li> <p>MontiCore for Research Software Engineering</p> </li> <li> <p>Low-Code / No-Code approaches based on MontiCore  </p> </li> <li>Languages for describing and deriving digital twins  </li> <li>Languages for non-engineering issues, such as science, legal,      social, or environmental sustainability issues  </li> <li> <p>DSLs engineered on the basis of GPMLs, like SysML and UML</p> </li> <li> <p>AI-based methods for language engineering and modeling within the  MontiCore ecosystem  </p> </li> <li> <p>MontiCore languages in action: Academic and industrial application of  MontiCore and its languages  </p> </li> <li>SysML v2 parser advancements</li> <li>UMLP tooling</li> <li>MontiArc architecture tools</li> <li>MontiGem webapp development </li> </ul> <p>Presenters are encouraged to accompany their presentations with a  demo or reproduction package that helps the participants to  (easily) run and comprehend the presented tools, experiment with them,  or tweak benchmark experiments. This helps to create a lasting  contribution.  </p>"},{"location":"docs/MontiCoreSymposium/#organization-program-committee","title":"Organization &amp; Program Committee","text":"<p>Organizers: - Andreas Wortman, Institut f\u00fcr Steuerungstechnik der Werkzeugmaschinen und Fertigungseinrichtungen - Universit\u00e4t Stuttgart - J\u00e9r\u00f4me Pfeiffer, Institut f\u00fcr Steuerungstechnik der Werkzeugmaschinen und Fertigungseinrichtungen - Universit\u00e4t Stuttgart  </p> <p>Program Committee: - Vincent Bertram, Software Engineering - RWTH Aachen - Nico Jansen, Software Engineering - RWTH Aachen - J\u00e9r\u00f4me Pfeiffer, Institut f\u00fcr Steuerungstechnik der Werkzeugmaschinen und Fertigungseinrichtungen - Universit\u00e4t Stuttgart - Andreas Wortman, Institut f\u00fcr Steuerungstechnik der Werkzeugmaschinen und Fertigungseinrichtungen - Universit\u00e4t Stuttgart  </p> <p>All proposals will undergo light reviewing by the program committee.  </p> <p>In case you have any further questions, please contact:  monticoresymposium@listserv.uni-stuttgart.de</p> <p>This instance of the MontiCore Symposium is organized by ISW Stuttgart</p>"},{"location":"docs/Publications/","title":"Publications","text":"<p> Redirecting to https://www.se-rwth.de/research/MontiCore/ </p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/","title":"Overview","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#monticore-grammars-for-expressions-literals-and-types-an-overview","title":"MontiCore Grammars for Expressions, Literals and Types - an Overview","text":"<p>MontiCore is a language workbench. It uses an extended grammar format as primary mechanism to describe DSLs. This format allows to compose language components by grammar (1) inheritance, (2) extension, (3) embedding and (4) aggregating. Please refer to the MontiCore handbook for more details.</p> <p>MontiCore bundles a generator that can produce lots of infrastructure from MontiCore grammars. Like grammars, this infrastructure is composable and can be extended with handwritten code. Most importantly, these extensions and the grammar composition are compatible which leads to flexible forms of reuse.</p> <p>This documentation presents a library of language components provided by the core of the MontiCore project together with short descriptions and status information (Status of Grammars). The components are mainly defined by a primary grammar plus associated Java and template files.</p> <p>The presented components are mainly based on the grammars in the <code>MontiCore/monticore</code> project. They are organized in the following packages under the <code>monticore-grammar/src/main/grammars/</code> folder hierarchy:</p> <ul> <li><code>de.monticore</code></li> <li><code>de.monticore.expressions</code></li> <li><code>de.monticore.literals</code></li> <li><code>de.monticore.regex</code></li> <li><code>de.monticore.siunit</code></li> <li><code>de.monticore.statements</code></li> <li><code>de.monticore.symbols</code></li> <li><code>de.monticore.types</code></li> </ul> <p>Additionally, the documentation presents some expression/type related language components in projects that extend MontiCore's core languages. For more languages and language components, follow this link.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#general-list-of-grammars-in-package-demonticore","title":"General: List of Grammars in package <code>de.monticore</code>","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasicsmc4-stable","title":"MCBasics.mc4  (stable)","text":"<ul> <li>This grammar defines basic rules for naming, spacing, and Java-like comments being useful in many languages.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#types-list-of-grammars-in-package-demonticoretypes","title":"Types: List of Grammars in package <code>de.monticore.types</code>","text":"<p>These grammars generally deal with type definitions and build on each  other. Some snipets for type definitions:</p> <pre><code>grammars          some examples\nMCBasicTypes      boolean  byte  short  int\n                  long  char  float  double\n                  void  Person  a.b.Person\n                  import a.b.Foo.*;\nMCCollectionTypes List&lt;.&gt;   Set&lt;.&gt;\n                  Optional&lt;.&gt;   Map&lt;.,.&gt;\nMCSimpleGenericTypes\n                  Foo&lt;.&gt;  a.b.Bar&lt;.,..,.&gt;\nMCFullGenericTypes\n                  Foo&lt;? extends .&gt;\n                  Foo&lt;? super .&gt;\nMCArrayTypes      Person[]  int[][]\nMCFunctionTypes   Foo-&gt;Bar  (Foo, Bar)-&gt;Foo\nMCStructuralTypes Foo|Bar  Foo&amp;Bar\n                  (Foo, Bar)  (Foo)\nSI Unit types     [km/h]  [km/h]&lt;long&gt;\nRegExType         R\"[a-z][0-9*]\"\n</code></pre>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasictypesmc4-stable","title":"MCBasicTypes.mc4 (stable)","text":"<ul> <li>This grammar defines basic types and thus eases the reuse of type structures in languages similar to Java. However, the type definitions in the grammar are somewhat simplified, e.g., they do not comprise generics.</li> <li>The grammar contains types from Java, e.g., primitives, <code>void</code>, and classes (sometimes referred to as \"reference types\").</li> <li>Example type definitions: <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>void</code>, <code>Person</code>, <code>a.b.Person</code>, <code>import a.b.Foo.*;</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccollectiontypesmc4-stable","title":"MCCollectionTypes.mc4 (stable)","text":"<ul> <li>This grammar defines four generic types: <code>List&lt;A&gt;</code>, <code>Map&lt;A,B&gt;</code>, <code>Set&lt;A&gt;</code> and <code>Optional&lt;A&gt;</code> on top of basic types.</li> <li>These four generic types correspond to a typical predefined set of generic types used, e.g., in connection with UML class diagrams or the OCL. UML associations typically have those association multiplicities which is why the generic types are of general interest.</li> <li>The grammar eases the reuse of type structures in languages similar to Java that are somewhat simplified, e.g., by omitting general generics.</li> <li>Example type definitions: <code>List&lt;.&gt;</code>, <code>Set&lt;.&gt;</code>, <code>Optional&lt;.&gt;</code>, <code>Map&lt;.,.&gt;</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsimplegenerictypesmc4-stable","title":"MCSimpleGenericTypes.mc4 (stable)","text":"<ul> <li>This grammar provides rules for the definition of custom generic types such as <code>Blubb&lt;A&gt;</code>, <code>Bla&lt;B,C&gt;</code>, <code>Foo&lt;Blubb&lt;D&gt;&gt;</code>.</li> <li>The grammar covers a wide range of uses for generic types. Unlike Java, it does however not cover type restrictions on arguments.</li> <li>Example type definitions: <code>Foo&lt;.&gt;</code>, <code>a.b.Bar&lt;.,..,.&gt;</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfullgenerictypesmc4-stable","title":"MCFullGenericTypes.mc4 (stable)","text":"<ul> <li>This grammar completes type definitions to support the full Java type system including wildcards on generic types like <code>Blubb&lt;? extends A&gt;</code>.</li> <li>A general advice: When you are not sure that you need this kind of types, use a simpler version from above. Type checking is tricky.</li> <li>Example type definitions: <code>Foo&lt;? extends .&gt;</code>, <code>Foo&lt;? super .&gt;</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcarraytypesmc4-stable","title":"MCArrayTypes.mc4 (stable)","text":"<ul> <li>The grammar provides means to define arrays.</li> <li>Arrays are orthogonal to the generic extensions and may thus be combined with any of the above grammars.</li> <li>Example type definitions: <code>Person[]</code>, <code>int[][]</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfunctiontypesmc4-stable","title":"MCFunctionTypes.mc4 (stable)","text":"<ul> <li>This grammar introduces function types like <code>int -&gt; int</code>.</li> <li>They are useful when functions shall be passed around   as arguments or stored in a data structure (for later use).</li> <li>The syntax is inspired by the functional programming language Haskell.</li> <li>This grammar may be combined with any of the grammars above.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcstructuraltypesmc4-stable","title":"MCStructuralTypes.mc4 (stable)","text":"<ul> <li>The grammar introduces additional structural types   as known partially from modern programming languages, like Kotlin.</li> <li>The grammar offers three ways to combine types: union types <code>A|B</code>,   intersection types <code>A&amp;B</code>, and tuple types <code>(A,B)</code>.</li> <li>Additionally, bracket types <code>(A)</code> are semantically    isomorphic to their argument (here <code>A</code>).   They allow to represent types not representable otherwise, e.g., <code>(A|B) -&gt; C</code>.</li> <li>They may be combined with any of the grammars above.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunittypes4mathmc4-for-physical-si-units-stable","title":"SIUnitTypes4Math.mc4 for Physical SI Units (stable)","text":"<p>The known units <code>s, m, kg, A, K, mol, cd</code> from the international system of  units (SI Units) and their combinations, such as <code>km/h</code> or <code>mg</code>, etc. can  be used as ordinary types (instead of only numbers).  The typecheck prevents e.g., assignment of a weight to a length  variable or to implicitely add appropriate conversion in the resulting program,  e.g., when a <code>km/h</code>-based velocity is stored in a <code>m/s</code>-based variable.</p> <ul> <li>Example type definitions: <code>[km/h]</code></li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunittypes4computingmc4-for-physical-si-units-stable","title":"SIUnitTypes4Computing.mc4 for Physical SI Units (stable)","text":"<p>Includes the types from <code>SIUnitTypes4Math</code>(see above), like <code>[km/h]</code>,  but also allows to add a resolution, such as <code>[km/h]&lt;int&gt;</code>. Here SI Unit types,  like <code>[km/h]&lt;.&gt;</code>, are used as generic type constructor that may take a number type, such as <code>int</code>, <code>long</code>, <code>double</code>, <code>float</code> as argument.</p> <ul> <li>Example type definitions: <code>[km/h]&lt;long&gt;</code></li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#regextypemc4-stable","title":"RegExType.mc4 (stable)","text":"<ul> <li>If a variable should not use all kinds of <code>String</code>s, its is possible  to use a type definition of form in <code>R\"...\"</code> that contains a regular  expression (see above) to constrain the set of storable strings. This  is e.g. helpful to prevent malign user input in security relevant  codes. </li> <li>Types are e.g. , such as <code>R\"[a-z]\"</code> (single character),  <code>R\"^([01][0-9]|2[0-3])$\"</code> (hours), or <code>R\"[1-9][0-9]*\"</code> (integers). </li> <li>There are two possibilities for interpreters handling these types,   and both are possible uses in interpreters/generators: </li> <li>A typecheck ensures that all assignments, parameters are correct      in the types, or</li> <li>no static typecheck, but a dynamig typecheck is executed       at runtime and e.g. issues an exception, if a type violation       occurs. </li> <li>The static typecheck is recommended when adding RegExTypes to a    language. Note that explicit type coercion is then needed, e.g.    using the <code>typeif</code> construct.</li> <li>In some occasions, e.g. if in assignment <code>R\"re1\" v1 = v2</code> the type  <code>R\"re2\"</code> of <code>v2</code> is a subset then the static typecheck identifies  compatibility of the strings and may omit the dynamic regular  expression check at runtime. Subset  relationship of regular expressions is decidable (at compiletime).</li> <li>If the regular expressions are disjoint, a compile time error may  be issued (instead of runtime errors only).</li> <li><code>String</code> could be treated identical to <code>R\".*\"</code>, but it may be that  the chosen typecheck wants to enforce explicit coercion.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#typeparametersmc4-alpha","title":"TypeParameters.mc4 (alpha)","text":"<p>This grammar defines type parameters for, e.g., classes or functions, such as <code>&lt;T&gt;</code>, <code>&lt;U,V&gt;</code>, <code>T extends Person</code>, <code>U extends T &amp; Comparable&lt;U&gt;</code>. Modeling elements with type parameters therefore take type arguments. For example, the generic type <code>List&lt;T&gt;</code> has the type parameter <code>T</code>  allowing to use the type <code>List&lt;int&gt;</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#symbols-list-of-grammars-in-package-demonticoresymbols","title":"Symbols: List of Grammars in package <code>de.monticore.symbols</code>","text":"<p>These two grammars do not provide syntax themselves, but  characterize important forms of symbols, that will be used in the type and the expression grammars to define shared  kinds of symbols. </p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#basicsymbolsmc4-stable","title":"BasicSymbols.mc4 (stable)","text":"<ul> <li>This grammar defines symbols for Types (of all kinds), Functions,    Variables and TypeVariables.</li> <li>The defined symbols are of general form and can be used in functional, OO   and other contexts. They do not preculde a concrete syntax and do not yet    embody OO specifics.</li> <li>Remark: This grammar is not intended to define concrete or abstract    syntax, but the   infrastructure for symbols. </li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#oosymbolsmc4-stable","title":"OOSymbols.mc4 (stable)","text":"<ul> <li>This grammar defines symbols for objectoriented Types, Methods, and   Fields by mainly extending the symbols defined in <code>BasicTypeSymbols</code>.</li> <li>The newly defined symbols extend the general ones by typical    objectoriented features, such as private, static, etc.   Again they do not preculde a concrete syntax.</li> <li>Remark: This grammar is not intended to define concrete or    abstract syntax, but the   infrastructure for symbols in objectoriented context. </li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressions-list-of-grammars-in-package-demonticoreexpressions","title":"Expressions: List of Grammars in package <code>de.monticore.expressions</code>","text":"<p>Expressions are defined in several grammars forming a (nonlinear) hierarchy, so that developers can choose the optimal grammar they want to build on  for their language and combine these with the appropriate typing  infrastructure.</p> <p>This modularity of expressions and associated types greatly eases  the reuse of type structures in languages similar to Java. Some snipets for operators defined in expressions:</p> <pre><code>grammar        operators and examples in this grammar\nCommonExp:     /  %  +  -  &lt;=  &gt;=  ==  &gt;  &lt;  !=  ~.  !.  .?.:.\n               &amp;&amp;  ||  ~. \nAssigementExp: ++  --  =  +=  -=  *=  /=  &amp;=  |=  ^=  &gt;&gt;=  &gt;&gt;&gt;=  &lt;&lt;=  %=\nBitExp:        &amp;  |  ^  &lt;&lt;  &gt;&gt;  &gt;&gt;&gt;\nOclExp:        implies  &lt;=&gt;  |  &amp;  forall  exists  let.in. .@pre  .[.]  .**\n               Set{.|.}\nSetExp:        .isin.  .in.  union  intersect  setand  setor\n               { item | specifier }\nOptionalOps:   ?:  ?&lt;=  ?&gt;=  ?&lt;  ?&gt;  ?==  ?!=  ?~~   ?!~ \nLambdaExp:     i-&gt;2*i   (a,b)-&gt;a+b\nTupleExp:      (.,.)  (.,.,.,.)\nSIUnits:       5km  3,2m/s  22l  2.400J  \nUglyExp:       .instanceof.  (.).  new\nJavaClass:     this  .[.]  super\n</code></pre>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressionsbasismc4-stable","title":"ExpressionsBasis.mc4 (stable)","text":"<ul> <li>This grammar defines core interfaces for expressions and imports the  kinds of symbols necessary.</li> <li>The symbols are taken over from the TypeSymbols grammar (see below).</li> <li>A hierarchy of conservative extensions to this grammar realize these interfaces in various forms.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#commonexpressionsmc4-stable","title":"CommonExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines a typical standard set of operations for expressions. </li> <li>This is a subset of Java as well as OCL/P,  mainly for arithmetic, comparisons, variable use (v),  attribute use (o.att), method call (foo(arg,arg2)), array access (v[i]), and brackets (exp).</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#assignmentexpressionsmc4-stable","title":"AssignmentExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines all Java expressions that have side effects.</li> <li>This includes assignment expressions like =, +=, etc. and  suffix and prefix expressions like ++, --, etc.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#bitexpressionsmc4-stable","title":"BitExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines a typical standard set of operations for expressions. </li> <li>This is a subset of Java for binary expressions  like &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, ^ and |</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#oclexpressionsmc4-stable","title":"OCLExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines expressions typical to UMLs OCL .   OCL expressions can savely be composed if with other forms of expressions   given in the MontiCore core project (i.e. as conservative extension).</li> <li>It contains various logical operations, such as quantifiers,    the <code>let</code> and the <code>@pre</code> construct, and a transitive closure for    associations, as discussed in [Rum17,Rum17].</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#setexpressionsmc4-stable","title":"SetExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines set expressions like set union, intersection etc. these operations are typical for a logic with set operations, like  UML's OCL. These operators are usually infix and are thus more intuitive as they allow math oriented style of specification.</li> <li>Most of these operators are in principle executable,    so it might be interesting to include them in a high level programming    language (see e.g. Haskell)</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#optionaloperatorsmc4-stable","title":"OptionalOperators.mc4 (stable)","text":"<ul> <li>This grammar defines nine operators dealing with optional values, e.g.   defined by    <code>java.lang.Optional</code>. The operators are also called Elvis operators.</li> <li>E.g.: <code>val ?: 42</code>     equals to   <code>val.isPresent() ? val.get() : 42</code></li> <li><code>x ?&gt;= y</code> equals <code>x.isPresent() ? x.get() &gt;= y : false</code> </li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#lambdaexpressionsmc4-stable","title":"LambdaExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines lambda expressions.   Lambda expression define anonymous functions that can be passed around    as values e.g. to higher-order functions    and that can be evaluated on arguments of appropriate types.</li> <li>Lambda expressions are fully typed (see e.g. in Haskell) and can be nested.</li> <li>This is only the subset of Java's lambda expressions that allows to define    a functional programming style (thus preventing side effects).</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#tupleexpressionsmc4-stable","title":"TupleExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines tuple expressions like <code>(1, \"Hello\")</code>.</li> <li>Tuple Expressions are tuples of expressions that can be used to, e.g.,   return multiple results from a function.</li> <li>The syntax is inspired by the functional programming language Haskell.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunitsmc4-for-physical-si-units-stable","title":"SIUnits.mc4 for Physical SI Units (stable)","text":"<ul> <li>This grammar the international system of units (SI units), based on    the basis units <code>s, m, kg, A, K, mol, cd</code>,    provides a variety of derived units, and can be refined using prefixes such    as <code>m</code>(milli), <code>k</code>(kilo), etc.</li> <li>The SI Unit grammar provides an extension to expressions, but also to the    typing system, e.g. types such as <code>km/h</code> or <code>km/h&lt;long&gt;</code>,   and literals, such as e.g. <code>5.3 km/h</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javaclassexpressionsmc4-stable","title":"JavaClassExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines Java specific class expressions like super,  this, etc.</li> <li>This grammar should only be included, when a mapping to Java is intended and the full power of Java should be available in the  modeling language.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#uglyexpressionsmc4-stable","title":"UglyExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines expressions deemed 'ugly' like   'instanceof', type cast, 'new', because they have some reflective behavior   that is convenient when developing, but not so easy to test.   'new' e.g. should be avoided, because in tests one might use   a mock (from a subclass) instead.</li> <li>The ugly expressions are not included in the usual logic and other   expressions, and only there to complete the Java expression syntax.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#literals-list-of-grammars-in-package-demonticoreliterals","title":"Literals: List of Grammars in package <code>de.monticore.literals</code>","text":"<p>Literals are the basic elements of expressions, such as numbers, strings,  truth values. Some snipets:</p> <pre><code>grammar           examples of this grammar\nMCCommonLit       3  -3  2.17  -4  true  false  'c' \n                  3L  2.17d  2.17f  0xAF  \"string\"  \n                  \"str\\uAF01\\u0001\"  null\nMCJavaLiterals    999_999  0x3F2A  0b0001_0101  0567  1.2e-7F\nSIUnitLiterals    5.3km/h  7mg\n</code></pre>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcliteralsbasismc4-stable","title":"MCLiteralsBasis.mc4 (stable)","text":"<ul> <li>This grammar defines core interface for literals.</li> <li>Several conservative extensions to this grammar realize various forms of literals.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonliteralsmc4-stable","title":"MCCommonLiterals.mc4 (stable)","text":"<ul> <li>This grammar defines the typical literals for an expression language, such as    characters: 'c', Strings \"text\", booleans: \"true\", \"null\", or numbers 10,    -23, 48l, 23.1f.</li> <li>Strings and characters use the Java-like escapes like \"\\n\".</li> <li>Each defined nonterminal is extended by a conversion function <code>getValue()</code>   of appropriate type and a retrieve function <code>getSource()</code> for a text representation   of the literal.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcjavaliteralsmc4-stable","title":"MCJavaLiterals.mc4 (stable)","text":"<ul> <li>This grammar defines Java compliant literals and builds on MCCommonLiterals.</li> <li>The scope of this grammar is to   ease the reuse of literals structures in Java-like sublanguages.</li> <li>The grammar contains literals from Java, e.g., Boolean, Char, String, ....</li> <li>Please note that Java (and this grammar)    has an extended syntax e.g. for integers using underscores   or other kinds of encodings. They parse e.g. 999_999, 0x3F2A, or 0b10100.</li> <li>Like above <code>getValue()</code> and <code>getSource()</code> allow to retrive the content   as value resp. as text string.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunitliteralsmc4-for-physical-si-units-stable","title":"SIUnitLiterals.mc4 for Physical SI Units (stable)","text":"<p>Provides concrete values, such as <code>5.3 km/h</code>or <code>7 mg</code> for the international system of  units (SI Units). </p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#statements-list-of-grammars-in-package-demonticorestatements","title":"Statements: List of Grammars in package <code>de.monticore.statements</code>","text":"<p>Statements are the constructive part of programs: They allow to  change variables, call functions, send messages etc. The following hierarchy of statement definitions should allow the developers to choose needed forms of statements and extend it  by their own additional needs. The provided list of statements is inspired by Java (actually subset of Java). Some example statements:</p> <pre><code>int i;   int j = 2;                     Person p[] = { foo(3+7), p2, ...}\nif (.) then . else .                    for ( i = .; .; .) {.}\nwhile (.) .                             do . while (.)\nswitch (.) { case .: .; default: .}\nfoo(1,2,3)                              return .                                \nassert . : \"...\"\ntry {.} catch (.) {.} finally {.}       throw .           \nbreak .                                 continue .\nlabel:                                  private  static  final  native ...\n</code></pre>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcstatementsbasismc4-stable","title":"MCStatementsBasis.mc4 (stable)","text":"<ul> <li>This grammar defines the core interface for statements.</li> <li>A hierarchy of conservative extensions to this grammar is provided below.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonstatementsmc4-stable","title":"MCCommonStatements.mc4 (stable)","text":"<ul> <li>This grammar defines typical statements, such as method calls   (which are actually expressions),   assignment of variables, if, for, while, switch statements, and blocks.</li> <li>This embodies a complete structured statement language, however does not   provide return, assert, exceptions, and low-level constructs like break.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcassertstatementsmc4-stable","title":"MCAssertStatements.mc4 (stable)","text":"<ul> <li>This grammar defines exactly the assert statement as known from Java.</li> <li>It can be used independently of other Java statements.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcexceptionstatementsmc4-stable","title":"MCExceptionStatements.mc4 (stable)","text":"<ul> <li>This grammar defines the exception statements.</li> <li>This includes Java try with catch and finally, as well as throw.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsynchronizedstatementsmc4-stable","title":"MCSynchronizedStatements.mc4 (stable)","text":"<ul> <li>This grammar defines the Java-like synchronized statement.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mclowlevelstatementsmc4-stable","title":"MCLowLevelStatements.mc4 (stable)","text":"<ul> <li>This grammar defines three low-level statements that Java provides.</li> <li>It contains the break and continue statements and the possibility to label a statement.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcreturnstatementsmc4-stable","title":"MCReturnStatements.mc4 (stable)","text":"<ul> <li>This grammar defines the Java-like return statement.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfulljavastatementsmc4-stable","title":"MCFullJavaStatements.mc4 (stable)","text":"<ul> <li>This grammar defines all Java statements.</li> <li>This is neither a generalized approximation nor a restricted overapproximation,   but exact.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-grammars-in-package-demonticore","title":"Further grammars in package <code>de.monticore</code>","text":"<p>several other grammars are also available:</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#regularexpressionsmc4-stable","title":"RegularExpressions.mc4 (stable)","text":"<ul> <li>This grammar defines regular expressions (RegEx) as used in Java    (see e.g. <code>java.util.regex.Pattern</code>).</li> <li>It provides common regex tokens such as </li> <li>character classes, e.g., lowercase letters (<code>[a-z]</code>), the letters a, b,      and c (<code>[abc]</code>)</li> <li>anchors, e.g., start of line (<code>^</code>), end of line (<code>$</code>), word boundary (<code>\\b</code>),</li> <li>quantifiers, e.g., zero or one (<code>?</code>), zero or more (<code>*</code>), exactly 3 (<code>{3}</code>),</li> <li>RegEx also supports to capture groups and referencing these captured groups    in replacements.  </li> <li>For example, <code>^([01][0-9]|2[0-3]):[0-5][0-9]$</code> matches all valid timestamps in    <code>HH:MM</code> format.</li> <li>The main nonterminal <code>RegularExpression</code> is not part of the expression   hierarchy and    thus regular expressions are not used as ordinary values. Instead    the nonterminal <code>RegularExpression</code> is can be used in aother places    of a language e.g. we do that as additional    restriction for String values in input/output channels in architectural langages.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#cardinalitymc4-stable","title":"Cardinality.mc4 (stable)","text":"<ul> <li>This grammar defines UML Cardinalities of forms <code>*</code>, <code>[n..m]</code> or <code>[n..*]</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#completenessmc4-stable","title":"Completeness.mc4 (stable)","text":"<ul> <li>This grammar defines completeness information in UML   like <code>...</code>, <code>(c)</code>, but also <code>(...,c)</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlmodifiermc4-stable","title":"UMLModifier.mc4 (stable)","text":"<ul> <li>The grammar contains the modifiers that UML provides.</li> <li>This includes <code>public</code> <code>private</code>, <code>protected</code>, <code>final</code>,    <code>abstract</code>, <code>local</code>, <code>derived</code>, <code>readonly</code>, and <code>static</code>,    but also the compact syntactic versions <code>+</code>, <code>#</code>, <code>-</code>, <code>/</code>    and <code>?</code> (for readonly).</li> <li>UML modifiers are not identical to Java modifiers (e.g. <code>native</code> or    <code>threadsafe</code> are missing.)</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlstereotypemc4-stable","title":"UMLStereotype.mc4 (stable)","text":"<ul> <li>This grammars defines Stereotypes like <code>&lt;&lt;val1,val2=\"text\",...&gt;&gt;</code></li> <li>Methods contains(name), getValue(name) assist Stereotype retrieval.</li> <li>Values may only be of type String.   The real value unfortunately in UML is only encoded as String.</li> <li>We suggest to use a tagging infrastructure that even allows to   type the possible forms of tags.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonmc4-stable","title":"MCCommon.mc4 (stable)","text":"<ul> <li>This grammar composes typical UML-like grammar components.</li> <li>This includes Cardinality, Completeness, UMLModifier, and UMLStereotype.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javalightmc4-stable","title":"JavaLight.mc4 (stable)","text":"<pre><code>int age = 3+x; \nList&lt;Person&gt; myParents;\n\n@Override\npublic int print(String name, Set&lt;Person&gt; p) {\n  int a = 2 + name.length();\n  if(a &lt; p.size()) {\n    System.out.println(\"Hello \" + name);\n  }\n  return a;\n}\n</code></pre> <ul> <li>JavaLight is a subset of Java that MontiCore itself   uses as intermediate language for the code generation process.</li> <li>JavaLight doesn't provide all forms of classes (e.g., inner classes)   and reduces the type system to normal generic types.   However, that is sufficient for all code generated by MontiCore.</li> <li>JavaLight supports Java expressions (including anonymous classes),   Java statements as relevant to MontiCore code generation, method declaration,   constructors, constants, interface methods, and annotations.</li> <li>JavaLight composes the grammars <code>CommonExpressions</code>,                                     <code>AssignmentExpressions</code>,                                     <code>JavaClassExpressions</code>,                                     <code>MCCommonStatements</code>,                                     <code>MCBasicTypes</code>, and                                     <code>OOSymbols</code>.</li> <li>JavaLight can be used for other generator tools than MontiCore,   especially as its core templates are reusable and new templates   for customized method bodies can be added using MontiCore's   Hook-Mechanisms.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#monticore-example-grammars-for-the-interested-reader","title":"MontiCore Example Grammars for the Interested Reader","text":"<p>The  <code>monticore-grammar/src/main/examples</code> folder hosts the following example grammars:</p> <ul> <li>StringLiterals.mc4</li> <li>MCHexNumbers.mc4</li> <li>MCNumbers.mc4</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/","title":"JavaLight","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#javalight","title":"JavaLight","text":"<p>The JavaLight language defines a subset of the Java programming language. The JavaLight language is dedicated  for embedding Java language elementsin arbitrary DSLs. It is therfore defined in a compositional style, i.e. for black box reuse (without need for copy-paste).</p> <p>The JavaLight language introduces * all forms of attribute declarations, * all forms of method declarations (including constructors), * all forms of Java expressions (including those with side effects,    such as <code>i++</code>, but without anonymous classes), * almost all Java statements, with the exception of    statements for exception handling, continue- and break-statement, and synchronization,   which are omitted because there are many DSLs, where these are of no use; * and it allows to import usable types, method, and attribute symbols,   which may be predefined or imported from of Java-like models.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#example","title":"Example","text":"<p><pre><code>int age = 3+x; \nList&lt;Person&gt; myParents;\n\n@Override\npublic int print(String name, Set&lt;Person&gt; p) {\n  int a = 2 + name.length();\n  if(a &lt; p.size()) {\n    System.out.println(\"Hello \" + name);\n  }\n  return a;\n}\n</code></pre> The example shows a Java method with one parameter and three statements.  Expressions are supported in all their forms.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#grammar","title":"Grammar","text":"<ul> <li>The main grammar file is <code>de.monticore.JavaLight</code>.   It deals with the definition of the method and constructor signatures,    and the annotations, while it reuses MontiCore's library components    <code>AssignmentExpressions</code>, <code>JavaClassExpressions</code>, <code>MCCommonStatements</code>,    and <code>MCArrayStatements</code> for expressions and statements.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#extension-of-javalight","title":"Extension of JavaLight","text":"<p>JavaLight is designed for easy black-box reuse. It can be extended by domain specific constructs, such as     1. special statements for message processing (<code>c?x; c!3+x</code>),     2. statements for testing such as Hoare-like <code>asserts</code> or pre/postconditions, or    3. additional logical or otherwise interesting expression operators        (<code>forall x in Set:</code>).     4. The omitted Java-special statements, such as eception handling, can also        be addded through a predefined language library component. </p> <p>JavaLight is fully compatible with various expression language components that MontiCore's library provides. These extensions can  simply be added by MontiCore's language composition mechanism  (see Handbook).</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#embedding-of-javalight-expression-or-statement","title":"Embedding of JavaLight <code>Expression</code> or <code>Statement</code>","text":"<p>JavaLight's expressions can be embedded as expression sublanguage in any  other interesting domain specific language, such as Automata, Activity Diagrams, etc. (even MontiCore's primary language uses this). The statements can also be embedded as sublanguage e.g. as actions in  StateCharts.</p> <p>JavaLight is a strict subset of the Java programming language and thus can be mapped directly to itself when generating code for Java.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#parser","title":"Parser","text":"<ul> <li>JavaLight is a component grammar. To retrieve a parser it is to be    embedded into a full grammar. </li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#symboltable-and-symbol-classes","title":"Symboltable and Symbol classes","text":"<ul> <li>JavaLight introduces the <code>JavaMethodSymbol</code> extending the existing <code>MethodSymbol</code>   for general object-oriented types.   The <code>JavaMethodSymbol</code> class carries the additional attributes:</li> <li>annotations,</li> <li>exceptions,</li> <li>and Booleans for <code>isEllipsisParameterMethod</code>, <code>isFinal</code>, <code>isAbstract</code>,      <code>isSynchronized</code>, <code>isNative</code>, and <code>isStrictfp</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#symbols-imported-and-exported","title":"Symbols (imported and exported)","text":"<ul> <li>Import: the following symbols can be imported from outside, when the symbol table    in the embedding language provides these symbols:</li> <li><code>VariableSymbol</code> for attributes and otherwise accessible variables.</li> <li><code>MethodSymbol</code> for method and constructor calls (this includes also <code>JavaMethodSymbol</code>).</li> <li><code>TypeSymbols</code> for using types, e.g., defined via classes, interfaces, and enums.</li> <li>Symbol definition and export: It is possible to define new symbols, for attributes,    methods, and constructors. The provided symbol table will include them as</li> <li><code>VariableSymbol</code> for attributes</li> <li><code>MethodSymbol</code> for methods and constructors    and thus will make the accessibility of these symbols available outside the JavaLight    sub-models.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#functionality","title":"Functionality","text":"<p>As usual functionality is implemented in a compositional form,  which means that in a composed language these functions should be largely reusable as pre-compiled black-boxes.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#context-conditions","title":"Context Conditions","text":"<p>JavaLight defines the following CoCos: * <code>ConstructorFormalParametersDifferentName</code> checks if all input parameters of a constructor have distinct names. * <code>ConstructorModifiersValid</code> checks that a constructor is not marked as <code>abstract</code>, <code>final</code>, <code>static</code>, or <code>native</code>. * <code>ConstructorNoAccessModifierPair</code> checks that no duplicate visibility occurs for a constructor. * <code>ConstructorNoDuplicateModifier</code> checks that no duplicate modifier occurs for a constructor. * <code>MethodAbstractAndOtherModifiers</code> checks that an <code>abstract</code> method is not marked as <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, or <code>synchronized</code>. * <code>MethodBodyAbsence</code> ensures that a method body may only be absent for <code>abstract</code> or <code>native</code> methods.  * <code>MethodBodyPresence</code> checks that a method with a present method body is neither <code>abstract</code> nor <code>native</code>.  * <code>MethodExceptionThrows</code> ensures that thrown exceptions are of type <code>java.lang.Throwable</code>. * <code>MethodFormalParametersDifferentName</code> checks if all input parameters of a method have distinct names. * <code>MethodNoDuplicateModifier</code> checks that no duplicate modifier occurs for a method. * <code>MethodNoNativeAndStrictfp</code> checks that method is not marked as <code>native</code> and <code>strictfp</code>.</p> <p>The CoCos of embedded languages, such as statements and expressions are defined there and reused as black-boxes.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#prettyprinter","title":"PrettyPrinter","text":"<ul> <li> <p>The basic pretty printer for JavaLight is <code>de.monticore.prettyprint.JavaLightPrettyPrinter</code></p> </li> <li> <p>When the expression language is used as high-level language, it might make sense to map attribute   access to get-functions respectively also use set-functions for modification.   This can be done using a more elaborated pretty printer.</p> </li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>License definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/","title":"Expressions","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#monticore-expression-language-modules","title":"MontiCore - Expression-Language Modules","text":"<p>MC Expressions can be used to formulate mathematical and programmatic expressions from a set of literals. MC Expressions are based on a system of modular and pluggable grammar parts.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#given-expression-languages-in-monticore","title":"Given Expression languages in MontiCore","text":"<p>Currently, MontiCore comprises the following expression languages:</p> <ul> <li>ExpressionsBasis: Basis for all other expression languages. Supports names and literals.</li> <li>AssignmentExpressions: Extends <code>ExpressionsBasis</code>  with basic assignments.</li> <li>CommonExpressions: Extends <code>ExpressionsBasis</code>  with common expressions like <code>+</code> and <code>-</code>.</li> <li>BitExpressions: Extends <code>ExpressionsBasis</code>  with bit expressions like <code>&amp;</code> or <code>&lt;&lt;</code>.</li> <li>SetExpressions: Extends <code>ExpressionBasis</code> with set expressions like <code>{a * a | a in b, a &lt; 10}</code>.</li> <li>LambdaExpressions: Extends <code>ExpressionBasis</code>  with lambda expressions like <code>a -&gt; a + 2</code>.</li> <li>TupleExpressions: Extends <code>ExpressionBasis</code> with tuple expressions like <code>(a, b)</code> or <code>(a, b, c, d)</code>.</li> <li>OCLExpressions: Extends <code>ExpressionsBasis</code> with OCL expressions like <code>a implies b</code>.</li> <li>UglyExpressions: Extends <code>ExpressionBasis</code>   with expressions like <code>instanceof</code> and <code>(Person)a</code>.</li> <li>OptionalOperators: Extends <code>CommonExpressions</code>   with expressions for optionals like <code>a ?: 0</code></li> <li>JavaClassExpressions: Extends <code>CommonExpressions</code>  with Java expressions like <code>new</code>.</li> <li>StreamExpressions: Extends <code>CommonExpressions</code> with stream expressions like <code>a : b</code>.</li> </ul> <p>Furthermore, composite SI unit expressions are defined in the SI Units project:</p> <ul> <li>SI Units (can be used to parse primitive units as well as their products, quotients, and powers)</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#using-expressions","title":"Using Expressions","text":"<p>To use one or more of the existing expression languages in your MontiCore-based language its grammar needs to extend those expression languages.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#creating-your-own-expression-language","title":"Creating your own Expression language","text":"<p>There are some expressions you need desperately and that are not covered by the existing expression languages?  In this case, you can create a new grammar that extends at least <code>ExpressionsBasis</code>. In the extending grammar, you are now free to add your own expressions which however must implement the <code>Expression</code> interface from <code>ExpressionsBasis</code> grammar. To then include the new expressions in a language let it extend the corresponding grammar. See here for an example.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/","title":"Literals","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#monticore-literals","title":"MontiCore - Literals","text":"<p>Literals are the basis to parse numbers, strings and other atomic language elements. The language module <code>MCLiteralBasis</code> defines the root nonterminal <code>Literal</code> but no other terminals representing literal terms. MCCommonLiterals, MCJavaLiterals, and SIUnitLiterals define concrete literal terms that can  be included in a MontiCore-based language as desired.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mccommonliteralsmc4","title":"Grammar <code>MCCommonLiterals.mc4</code>","text":"<p>This grammar includes the following parser rules:</p> <ul> <li><code>NullLiteral</code>: Recognizes <code>null</code>.</li> <li><code>BooleanLiteral</code>: Recognizes <code>true</code> and <code>false</code>.</li> <li><code>CharLiteral</code>: Recognizes <code>a</code>, ... , <code>Z</code>.</li> <li><code>StringLiteral</code>: Recognizes <code>\"...\"</code>.</li> <li><code>NatLiteral</code>: Recognizes literals like <code>123</code>.</li> <li><code>SignedNatLiteral</code>: Recognizes literals like <code>-13</code>.</li> <li><code>BasicLongLiteral</code>: Recognizes literals like <code>6L</code> and <code>6l</code>.</li> <li><code>SignedBasicLongLiteral</code>: Recognizes literals like <code>-6L</code>, <code>-6l</code>, <code>6L?</code>, and <code>6l</code>.</li> <li><code>BasicFloatLiteral</code>: Recognizes literals like <code>1.2F</code> and <code>1.2f</code>.</li> <li><code>SignedBasicFloatLiteral</code>: Recognizes literals like <code>-1.2F</code>, <code>-1.2f</code>, <code>1.2F</code>, and <code>1.2f</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mcjavaliteralsmc4","title":"Grammar <code>MCJavaLiterals.mc4</code>","text":"<p>This grammar extends <code>MCCommonLiterals</code> and includes the following parser rules:</p> <ul> <li><code>IntLiteral</code>: Recognizes literals like <code>123</code>, <code>0734</code>, <code>1001001</code>, and <code>0x1a</code>.</li> <li><code>LongLiteral</code>: Recognizes literals like <code>2L</code>, <code>0734l</code>, <code>1001001L</code>, and <code>0x1al</code>.</li> <li><code>FloatLiteral</code>: Recognizes literals like <code>1.23F</code> and <code>1.23E4f</code>.</li> <li><code>DoubleLiteral</code>: Recognizes literals like <code>1.23</code>, <code>1.23d</code>, <code>1.23E4D</code>.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-siunitliteralsmc4","title":"Grammar <code>SIUnitLiterals.mc4</code>","text":"<p>This grammar allows recognition of SI unit literals like <code>1km/h</code>. This is documented in <code>SIUnits</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/","title":"RegEx","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#regular-expressions-and-regular-expression-types","title":"Regular Expressions and Regular Expression Types","text":"<p>This document describes the MontiCore language RegEx, which introduces regular expressions.  Based thereon, it introduces a new form of types <code>RegExType</code>s that are used as subtypes of <code>String</code> and help to make model even more typesafe.</p> <p>A regular expression describe patterns that can be applied to text in order to allow/deny certain sequences of characters and also to find specific sequences within the text. </p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#motivation-and-basic-examples","title":"Motivation and Basic Examples","text":"<p>In theoretical computer science, a regular expression is a character string that is used to describe sets of character strings with the help of certain syntactic rules. Regular expressions are used in a variety of applications. In addition to implementations in many programming languages, many text editors also process regular expressions in the Find and Replace function. A simple use case of regular expressions are wildcards.</p> <p>Regular expressions can be used as filter criteria in text search by matching the text with the regular expression pattern. This process is also called pattern matching. For example, it is possible to find all words from a word list that begin with S and end with D without having to explicitly specify the intervening letters or their number.</p> <p>This project introduces regular expressions as a MontiCore grammar, allowing modelers to write regular expressions. The regular expressions which are defined by the grammars in this project adhere to the definition which can be found at https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory. More specifically, it is modeled after the Java syntax for regular expressions.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#examples-for-regular-expressions","title":"Examples for Regular Expressions","text":"<p>Below are a few examples for regular expressions along with words they match (taken and adapted from https://cs.lmu.edu/~ray/notes/regex/).</p> Regular Expression Example Matches hello hello gray|grey gray, grey gr(a|e)y gray, grey gr[ae]y gray, grey b[aeiou]bble babble, bebble, bibble, bobble, bubble [b-chm-pP]at|ot bat, cat, hat, mat, nat, oat, pat, Pat, ot colou?r color, colour rege(x(es)?|xps?) regex, regexes, regexp, regexps go*gle ggle, gogle, google, gooogle, .. go+gle gogle, google, gooogle, ... g(oog)+le google, googoogle, googoogoogle, ... z{3} zzz z{3,6} zzz, zzzz, zzzzz, zzzzzz z{3,} zzz, zzzz, zzzzz, ... [Bb]rainch\\*\\*k Brainch**k, brainch**k \\d 0,1,2,3,4,5,6,7,8,9 \\d{5}(-\\d{4})? 12345-1234, 67890 1\\d{10} 11231231231, 19999999999 [2-9]|[12]\\d|3[0-6] 2, 3, 4, ..., 34, 35, 36 Hello\\nworld Hello [newline] world mi.....ft microsoft, mi.....ft, mi123456ft \\d+(.\\d\\d)? 123.45, 6.78, 9 [^i*&amp;2@] anything besides i, *, &amp;, 2 or @ //[^\\r\\n]*[\\r\\n] //hello world, //I am a comment ^dog dog at the start of a line dog$ dog at the end of a line ^dog$ a line which only contains dog"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#language-components-for-regular-expressions","title":"Language Components for Regular Expressions","text":"<p>The regular expressions which are defined by these grammars adhere to the definition which can be found at  https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory. More specifically, it is modeled after the Java syntax for regular expressions.</p> <p>This RegEx language component contains</p> <ul> <li>two grammars, </li> <li>context conditions for a regular expression</li> <li>a symbol table infrastructure, and</li> <li>pretty-printers for both grammars, resp. their main nonterminals.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#grammars","title":"Grammars","text":"<p>The RegEx language component contains two grammars: 1. RegularExpressions, 1. RegExType</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#regularexpressions","title":"RegularExpressions","text":"<p>The grammar RegularExpressions is a component grammar which defines the syntax of regular expressions. The grammar is supposed to be embedded in DSLs where a regular expression is of use, e.g. when describing allowed input patterns.</p> <p>The grammar only extends the grammar MCCommonLiterals as it uses the Digit token as well as the Name nonterminal. Although the main nonterminals is called RegularExpression, this grammar and its nonterminals are defined independent of MontiCore's expression grammars.</p> <p>The grammar uses a special mode <code>REGEX</code> to distinguish regular expressions from, e.g., from algebraic expressions.</p> <p>The nonterminal RegularExpression is designed in such a way that it assumes that the mode <code>REGEX</code> has already been switched on (and will be switched off) by the calling nonterminal. This is provided by the nonterminal <code>RegExLiteral</code> in the grammar.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#context-conditions-for-the-regularexpressions-language","title":"Context Conditions for the RegularExpressions language","text":"<ul> <li><code>RangeHasLowerOrUpperBound</code> ensures that the nonterminal RangeQualification is bounded in at least one direction.</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#symbol-table-for-the-regularexpressions-language","title":"Symbol Table for the RegularExpressions language","text":"<p>RegularExpressions introduces symbols for * named capturing groups (<code>NamedCapturingGroupSymbol</code>), which can then, e.g., be used to select a part of the accepted pattern for later repeated matching.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#regextype","title":"RegExType","text":"<p>The grammar RegExType extends the MCType hierarchy by the notion of regular types. The new nonterminal RegExType consists of a regular expression embedded in <code>R\"...\"</code>. It is used to define a subtype of <code>String</code> which contains only the text accepted by the regular expressions. </p> <p>Therefore, this grammar is used to define a type system for strings, which can be used to define variables that can only have values of a subset of all strings. This is, e.g., helpful in notoriously unsafe infrastructures, such as Internet-Of-Things or otherwise distributed systems, where permanently strings are accepted from unsafe external sources.</p> <p>The grammar RegExType extends the grammars * RegularExpressions to use regular expressions, and  * MCBasicTypes for the nonterminal MCType</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#typecheck-for-regextype","title":"TypeCheck for RegExType","text":"<p>TypeChecks are important when using the RegExType grammar, as they prevent the assignments of irregular values to variables with a regular expression type. Unfortunately, the type checks for our regular expressions cannot be completely performed at compile-time, as checking whether two different expression types are compatible is not solvable in general, because of the extended capabilities of the language, which in fact goes beyond mere regularity. However, if variables/fields with a regular expression type get assigned a static string, the compatibility can be checked at compile-time. And also, in a number of cases, when a string of one known regular type is assigned to a variable of a second regular type, the subtyping property can be statically resolved.</p> <p>The TypeCheck classes in this project provide functionality using MontiCore's type checking mechanism. A new SymTypeExpression SymTypeOfRegEx is introduced, which carries information about which type of regular expression it accepts and is a subtype of the SymTypeExpression String.</p> <p>For more info see TypeSystem.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/regex/RegEx/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/","title":"SIUnits","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#siunits","title":"SIUnits","text":"<p>This language introduces SI units and allows language developers to integrate literals enriched with an SI unit to their language. Furthermore, this language provides functionality for unit compatibility and type checking.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#the-grammar-files-are-see-details-below","title":"The grammar files are (see details below):","text":"<ul> <li>SIUnits.mc4</li> <li>SIUnitLiterals.mc4</li> <li>SIUnitTypes4Math.mc4</li> <li>SIUnitTypes4Computing.mc4</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#siunitsmc4","title":"SIUnits.mc4","text":"<p>This is the base grammar of the SIUnits language. It introduces SI units and other units that can be derived from them. This grammar defines SI units with their prefixes and complex, composed SI units allowing us to parse simple and derived units such as <code>m</code>, <code>km</code>, <code>km^2</code> or <code>km^2/VA^2h</code>.</p> <p>Some Si units are ambiguous, e.g., <code>ms</code> can be interpreted as metre times second, or as milliseconds. In ambiguous cases, the interpretation with the prefix is preferred, e.g., by the typecheck. To write metre times second, <code>m^1s</code> can be used.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#siunitliteralsmc4","title":"SIUnitLiterals.mc4","text":"<p>The SIUnitLiterals allow to describe concrete values, such as <code>5km</code> or <code>23.4m/s</code> that can be used within ordinary expressions. For that purpose, they combine a NumericalLiteral resp. SignedNumericalLiteral from the MCCommonLiterals.mc4 grammar with a SIUnit from the SIUnits grammar.</p> <p>SIUnitLiterals allows us to parse literals of the following forms. Literals in combination with a unit. The unit may be of any form allowed by the SIUnits.mc4 grammar, i.e. including unit expressions: * Integer with unit: <code>5km</code> or <code>5 km/h</code> * Long with unit: <code>5l km</code> * Float with unit: <code>5.0km</code> or <code>5.0 km</code>; The space is obligatory for Farads to   avoid confusion with floats (<code>5.0 F</code>) * Float (explicit) with unit: <code>5.0f kg</code> or <code>5.0F kg</code>     * Caution: A space is obligatory for liters to       avoid confusion with longs (<code>5 l</code>)       Standard unitless literals are parsed as Literals as provided by the       MCCommonLiterals grammar: * Unitless integer: <code>5</code> * Unitless long: <code>5l</code> or <code>5L</code> * Unitless float: <code>5.0</code> * Unitless float (explicit): <code>5.0f</code> or <code>5.0F</code></p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#siunittypes4mathmc4","title":"SIUnitTypes4Math.mc4","text":"<p>The SIUnitTypes interpret the SIUnits as a type in the MontiCore type universe, such as <code>[m]</code>. Therefore, the grammar extends SIUnits.mc4 and de.monticore.types.MCBasicTypes.mc4. A SIUnitType implements the MCType and can therefore be used wherever a type is used, e.g., when a variable is declared or a method parameter is typed.</p> <p>The idea of this grammar is that the types are used in a mathematically ideal world (e.g., also in early stages of systems development), where no limitations on the type of numbers plays a role yet. This is opposed to the below-defined SIUnitTypes4Computing grammar, where concrete types of numbers can be added as well.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#siunittypes4computingmc4","title":"SIUnitTypes4Computing.mc4","text":"<p>SIUnitType4Computing interprets the SIUnits as a generic type that  have exactly one parameter, which is of a numeric type. This allows one to specify SI unit and underlying numeric type, such as <code>[km/h]&lt;float&gt;</code> or <code>[m]&lt;long&gt;</code> in combination and use that as type. This is more oriented toward computation because it allows one to model numeric restrictions. Please note that e.g. <code>[km]&lt;int&gt;</code> has a different behavior that <code>[m]&lt;int&gt;</code> in terms of rounding and overflow.</p> <p>Technically, SIUnitType4Computing defines a type expression with an SI unit as a generic type (not SymTypeOfGenerics) and a MCPrimitiveType as an argument. The primitive part must be a numeric type.</p> <p>Remark: while the syntax of SI Units is very carefully standardized, the use of SI Units as type definitions, and especially as generic types is an invention by the MontiCore team. Alternative syntaxes are definitely possible.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#typecheck","title":"TypeCheck","text":"<p>There are two main approaches how to handle si units: at compile-time or at runtime. The former variant is highly preferable as all unit-related checks and conversions are performed at compile-time and unit information can be thrown away completely at runtime. This approach is only feasible if our type system is static, i.e., it is not possible to change the unit  of a variable at runtime. A variable with type <code>[km/h]</code> will always be interpreted as <code>[km/h]</code>. Assignments of compatible variables, e.g., typed as <code>[m/s]</code> lead to an implicit conversion by the compiler or code generator.</p> <p>If static typing is not desired in an SI unit-based language and types can be altered dynamically at runtime, type information needs to be carried at runtime. Consequentially, all the compatibility checks and conversions need to be performed by the generated code. This approach is much less efficient, and we recommend to prefer static typing instead if possible.</p> <ul> <li>With the TypeCheck class SymTypeExpressions   (MontiCore's internal form of storage for types) can be   synthesized from a <code>MCType</code> and returns a SymTypeOfSIUnit   or a SymTypeOfNumericWithSIUnit for a   <code>SIUnitType</code> or <code>SIUnitType4Computing</code>.</li> <li>With the TypeCheck class SymTypeExpressions   can be derived from a <code>Literal</code> or an <code>Expression</code> and returns a SymTypeOfSIUnit   or a SymTypeOfNumericWithSIUnit for expressions   containing <code>SIUnits</code>.   The resulting types of the most common expressions is defined as follows:<ul> <li>The type of a SIUnitLiteral is a <code>SymTypeOfNumericWithSIUnit</code>   as a combination of the types of its NumericLiteral and its SIUnit. \\   E.g. <code>typeOf(3.2f m) -&gt; [m]&lt;float&gt;</code></li> <li>The multiplication of two <code>SymTypeOfNumericWithSIUnit</code> results in the   combination of the multiplication of their numeric parts and   of their SI unit parts. \\   E.g. <code>typeOf(3 m * 1.5 s) -&gt; [m^s]&lt;double&gt;</code></li> <li>The division of two <code>SymTypeOfNumericWithSIUnit</code> results in the   combination of the division of their numeric parts   of their SI unit parts. \\   E.g. <code>typeOf(3 m / 2l s) -&gt; [m/s]&lt;long&gt;</code></li> <li>The addition of two <code>SymTypeOfNumericWithSIUnit</code> results in the   combination of the addition of their numeric parts and   their SI unit parts. The addition of the SI unit parts is only   defined if the units are compatible (same base units with different prefix)   and results in the smaller unit. \\   E.g. <code>typeOf(3 m + 2 s) -&gt; undefined</code> (results in an error) \\   <code>typeOf(1.25 h + 30 min) -&gt; [min]&lt;double&gt;</code> \\   <code>typeOf(30 min + 1.25 h) -&gt; [min]&lt;double&gt;</code></li> <li>Subtraction and modulo are defined in the same way as the addition.</li> </ul> </li> </ul> <p>The TypeCheck classes here are:</p> <ul> <li>SIUnitBasic   which defines the SymType of a single SI unit basis, e.g. <code>m</code> or <code>ms^2</code>,   but not <code>K^2m</code>, as it contains two SI unit basis.</li> <li>SymTypeOfSIUnit   which contains a numerator and denominator list of SIUnitBasic.</li> <li>SymTypeOfNumericWithSIUnit   which contains a numeric type and a SymTypeOfSIUnit.</li> </ul> <p>For more info, see TypeCheck.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#runtime-executing-calculations","title":"Runtime: Executing Calculations","text":"<p>While the previous part described, how SI Units are used in grammars and thus mainly for the concrete and abstract syntax of a modeling language, we here also discuss possibilities to execute calculations.</p> <p>There are mainly two approaches, while the latter also comes in variants:</p> <ol> <li> <p>Due to the strong typing system that is provided, the generator in principle    can throw all type information away after consistency has been checked.    This is efficient and type safe, given a correctly implemented type checker.    All needed scalar transformations can be explicitly added during the generation    process, SI Unit information is not present in the values anymore.    (efficient compilers do exactly that with their datatypes today).    I.e., <code>[km/h]&lt;int&gt; x = 100 * 30m / 100sec</code> would be translated to    <code>int x =  (100 * 30 / 60)  * 3600 / 1000</code> where the later multiplication    and division handles the scaling. (Further optimization is not needed here,    but handled by a subsequent compiler.)</p> </li> <li> <p>In some target languages, such as C, C++, or python,    strong typing doesn't really exist, and people    have implemented frameworks that make units explicit. I.e., instead of storing    a value for <code>[km/h]&lt;int&gt; x</code> in form of a simple <code>int</code> value, an object    with attributes like <code>int value</code>, <code>String siUnit</code>, and <code>int scaleFactor</code> are    carried around at runtime.    Unit    is such a framework for Java.</p> <ul> <li>As a side effect, the SI Units are themselves encoded as values   (whereas in our language, we treat them as types, what they actually are)   and thus the typing system is encoded explicitly \u2014 a common approach,   when the programming language doesn't provide a strong typing system.</li> </ul> </li> </ol> <p>It is up to the developer of a generator to decide which solution to take.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/siunit/SIUnits/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/","title":"Types","text":""},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#monticore-types","title":"MontiCore - Types","text":"<p>Type systems are available in a variety of (programming) languages and facilitate programming because they allow for detecting typing errors already  at compile time. To express type usages in MontiCore-based languages a language component hierarchy for type modeling was developed. The hierarchy consists of the following language components:</p> <ul> <li><code>MCBasicTypes</code></li> <li><code>MCCollectionTypes</code></li> <li><code>MCSimpleGenericTypes</code></li> <li><code>MCFullGenericTypes</code></li> <li><code>MCArrayTypes</code></li> <li><code>MCFunctionTypes</code></li> <li><code>MCStructuralTypes</code></li> <li><code>TypeParameters</code></li> <li><code>SIUnitTypes4Math</code></li> <li><code>SIUnitTypes4Computing</code></li> <li><code>RegExType</code></li> </ul>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcbasictypes","title":"<code>MCBasicTypes</code>","text":"<p><code>MCBasicTypes</code> is the most basic language component. It provides the central interface nonterminal <code>MCType</code>. Additionally, it defines nonterminals that enable modeling primitive types as well as qualified and non-qualified types. Furthermore, the component comprises a rule that covers return types which can be <code>MCType</code>s or <code>void</code>s. In general, the component represents a relativity small, yet useful, collection of rules for type modeling that supports statements such as <code>int</code>, <code>Person</code>, and <code>java.lang.String</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mccollectiontypes","title":"<code>MCCollectionTypes</code>","text":"<p>This language component builds upon <code>MCBasicTypes</code> and enables to model four kinds of generics:</p> <ul> <li><code>Set</code></li> <li><code>List</code></li> <li><code>Map</code></li> <li><code>Optional</code></li> </ul> <p>These generics cannot be nested as the purpose of the <code>MCCollectionTypes</code> language component is the provisioning of some commonly used collection types whose functionality is limited to support the construction of high-level models. With the language component types such as <code>List&lt;Integer&gt;</code>, <code>Set&lt;char&gt;</code>, or <code>Map&lt;java.lang.String, Person&gt;</code> become expressible.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcsimplegenerictypes","title":"<code>MCSimpleGenericTypes</code>","text":"<p>This language component extends the <code>MCCollectionTypes</code> component to allow the expression of types with custom generics of arbitrary classes with arbitrary arguments. When using the component, types such as <code>Person&lt;String&gt;</code> or <code>Map&lt;Person&lt;String&gt;, Integer&gt;</code> are expressible. Please note that these types still do not cover all possible Java types as Java additionally supports inner types of generic types. Specifically, types such as <code>a.b.C&lt;D&gt;.E.F&lt;G&gt;.H</code> are not expressible by <code>MCSimpleGenericTypes</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcfullgenerictypes","title":"<code>MCFullGenericTypes</code>","text":"<p>This language component extends the <code>MCSimpleGenericTypes</code> component to allow the expression of inner generic types of arbitrary classes with arbitrary arguments including wild card types. When using this language component, types such as <code>Person&lt;?&gt;</code>, <code>Map&lt;Person&lt;String&gt;, ? extends Person&gt;</code>, and <code>a.b.C&lt;D&gt;.E.F&lt;G&gt;.H</code> are expressible.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#typeparameters","title":"<code>TypeParameters</code>","text":"<p>This language component offers ways to define type parameter lists for generic model elements, e.g., generic classes such as <code>Map&lt;K, V&gt;</code>. The resulting Symbols can than be used with, e.g.,  <code>MCSimpleGenericTypes</code>, or <code>MCFullGenericTypes</code> to define types by providing the corresponding type arguments. Type parameters may optionally have upper bounds, e.g., <code>T extends Person</code>, <code>U extends T &amp; Comparable&lt;U&gt;</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcarraytypes","title":"<code>MCArrayTypes</code>","text":"<p>This language component allows to express array types like <code>Person[]</code> or <code>int[][]</code>. As array types are orthogonal to other kinds of  types, <code>MCArrayTypes</code> can be combined with any of the above language components.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcfunctiontypes","title":"<code>MCFunctionTypes</code>","text":"<p>This language component allows developers to express function types like <code>int -&gt; int</code> or <code>(String -&gt; int) -&gt; void</code>. Function types are independent from and not interfering with  generic and array types, <code>MCFunctionTypes</code> can be combined with any of the above language components.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcstructuraltypes","title":"<code>MCStructuralTypes</code>","text":"<p>This language component allows to express additional types by combining other types, like the union type <code>Foo | Bar</code> which is the type that is \"<code>Foo</code> or <code>Bar</code>\". As structural types are orthogonal to other kinds of types, <code>MCStructuralTypes</code> can be combined with any of the above language components.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#siunittypes4math","title":"<code>SIUnitTypes4Math</code>","text":"<p>When using this language component, SI unit types like <code>[km/h]</code> become expressible. The documentation can be found in <code>SIUnits</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#siunittypes4computing","title":"<code>SIUnitTypes4Computing</code>","text":"<p>When using this language component, SI unit types like <code>[km/h]&lt;int&gt;</code> become expressible. The documentation can be found in <code>SIUnits</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#regextype","title":"<code>RegExType</code>","text":"<p>When using this language component, Subtypes of <code>String</code> defined as RegEx types like  <code>R\"H(a|e)llo\"</code>, or <code>R\"-?[0-9]+\"</code> <code>R\"0x[a-f0-9]+\"</code>  become expressible. This is useful to prevent e.g. security breaches by  malign input text. This is documented in <code>RegEx</code>.</p>"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/","title":"TypeCheck","text":"<p>In MontiCore, the TypeCheck is used to calculate the SymTypeExpression of a set of expressions, types and literals. This is made possible by traversing the AST of an expression, type or literal, calculating the SymTypeExpression of its subexpressions, -types or -literals and combining them to the SymTypeExpression of the main expression, type or literal.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#given-infrastructure-in-monticore","title":"Given infrastructure in MontiCore","text":"<ul> <li>TypeCheck (facade for using the TypeCheck)</li> <li>DeriveSymTypeOfExpression (calculate a SymTypeExpression for the expressions in the grammar ExpressionsBasis)</li> <li>DeriveSymTypeOfCommonExpressions (calculate a SymTypeExpression for the expressions in the grammar CommonExpressions)</li> <li>DeriveSymTypeOfAssignmentExpressions (calculate a SymTypeExpression for the expressions in the grammar AssignmentExpressions)</li> <li>DeriveSymTypeOfBitExpressions (calculate a SymTypeExpression for the expressions in the grammar BitExpressions)</li> <li>DeriveSymTypeOfLiterals (calculate a SymTypeExpression for the literals in the grammar LiteralsBasis)</li> <li>DeriveSymTypeOfMCCommonLiterals (calculate a SymTypeExpression for the literals in the grammar MCCommonLiterals)</li> <li>DeriveSymTypeOfMCJavaLiterals (calculate a SymTypeExpression for the literals in the grammar MCJavaLiterals)</li> <li>SynthesizeSymTypeFromMCBasicTypes (calculate a SymTypeExpression for the types in the grammar MCBasicTypes)</li> <li>SynthesizeSymTypeFromMCCollectionTypes (calculate a SymTypeExpression for the types in the grammar MCCollectionTypes)</li> <li>SynthesizeSymTypeFromMCSimpleGenericTypes (calculate a SymTypeExpression for the types in the grammar MCSimpleGenericTypes)</li> <li>SynthesizeSymTypeFromMCFullGenericTypes (calculate a SymTypeExpression for the types in the grammar MCFullGenericTypes)</li> <li>BasicSymbols (defines the symbols needed for the symboltable)</li> <li>OOSymbols (specialization of the BasicSymbols for object-oriented languages)</li> <li>SymTypeExpression (result of the TypeCheck, represents type usage)</li> <li>SymTypeArray (subclass of SymTypeExpression, represents arrays)</li> <li>SymTypePrimitive (subclass of SymTypeExpression, represents primitive types)</li> <li>SymTypeOfGenerics (subclass of SymTypeExpression, represents generic types)</li> <li>SymTypeOfObject (subclass of SymTypeExpression, represents non-primitive types without type arguments)</li> <li>SymTypeVariable (subclass of SymTypeExpression, represents type variables)</li> <li>SymTypeOfNull (subclass of SymTypeExpression, represents the null type)</li> <li>SymTypeVoid (subclass of SymTypeExpression, represents the void type)</li> <li>SymTypeOfWildcard (subclass of SymTypeExpression, represents wildcard types)</li> <li>SymTypeExpressionFactory (factory for creating the subclasses of SymTypeExpression)</li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#what-is-the-difference-between-typesymbols-and-symtypeexpressions","title":"What is the difference between TypeSymbols and SymTypeExpressions?","text":"<p>The TypeCheck uses the TypeSymbols of the BasicSymbols grammar and the handwritten SymTypeExpressions. While they are very similar, there is a big difference between them and when to use them. The TypeSymbols represent a type definition (example in Java: class List) while the SymTypeExpressions represent a type usage (example in Java: List). There is only one type definition, but there can be many type usages. The SymTypeExpression knows its corresponding  TypeSymbol (like the type usage knows its definition) and can refer to its methods and fields. <p>So when talking about a type definition, a type symbol, which can be stored and is present only once in the symboltable, has to be used. A SymTypeExpression is not stored in the symboltable, but refers to the definition of its type (its corresponding TypeSymbol) in the symboltable. Thus, a SymTypeExpression can be used multiple times and represents the usage of a type.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#the-typecheck-facade","title":"The TypeCheck facade","text":"<p>The TypeCheck class of MontiCore is used as a facade to make TypeChecking easier for the user. It needs a Derive-Class and/or a Synthesize-Class to be instantiated. Here is a list of the methods and functions of the TypeCheck. * SymTypeExpression typeOf(ASTExpression expr) (uses the Derive-Class to derive a SymTypeExpression from an ASTExpression) * SymTypeExpression typeOf(ASTLiteral lit) (uses the Derive-Class to derive a SymTypeExpression from an ASTLiteral) * SymTypeExpression symTypeFromAST(ASTType type) (uses the Synthesize-Class to derive a SymTypeExpression from an ASTType) * static boolean compatible(SymTypeExpression left, SymTypeExpression right) (checks if the type of the right SymTypeExpression would be assignable to a variable with the type of the left SymTypeExpression) * static boolean isSubTypeOf(SymTypeExpression sub, SymTypeExpression sup) (checks if the type of sub is a subtype of the type of sup) * static boolean isInt(SymTypeExpression sym) (there are methods like this for all primitive types, checks if the SymTypeExpression represents the type 'int')</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#how-does-the-typecheck-work","title":"How does the TypeCheck work?","text":"<p>The TypeCheck can be used to derive a SymTypeExpression from an expression or type. For example, when using an ASTPlusExpression '3+4', the TypeCheck returns a SymTypeExpression representing the type 'int'. You can use the ASTPlusExpression as a parameter for the  method typeOf of the TypeCheck facade. This method delegates the calculation to your Derive-Class. First it derives the SymTypeExpression of the subexpressions '3' and '4' (the LiteralExpressions used in the PlusExpression) and then it calculates the SymTypeExpression of the whole PlusExpression by combining the SymTypeExpressions of its subexpressions in the context of the '+' operator.</p> <p>In general, the derivation of SymTypeExpressions for expressions first calculates the  SymTypeExpressions of its subexpressions and (depending on the results) then combines these SymTypeExpression adequately to one SymTypeExpression for the whole expression.</p> <p>Deriving the SymTypeExpression of a type is often easier than deriving the SymTypeExpression of an expression. The ASTMCPrimitiveType 'int' will result in a SymTypeExpression 'int', the  ASTMCBasicGenericType 'java.util.Map' will result in a SymTypeExpression  'java.util.Map'. <p>The derivation of types is very similar to the derivation of expressions with regard to  subtypes and subexpressions. If a type has subtypes (like type arguments), then the SymTypeExpressions representing these subtypes will be calculated first. They can be used to put together the SymTypeExpression of the whole type.</p> <p>Because both types and expressions are converted into SymTypeExpressions, you can compare them. This is useful in the next example:</p> <pre><code>int a = \"Hello\";\n</code></pre> <p>The SymTypeExpression derived from the ASTPrimitiveType 'int' will be 'int', the SymTypeExpression derived from the ASTLiteralExpression \"Hello\" will be 'String'. In a CoCo, you can check if they are compatible by using the function 'compatible' of the TypeCheck facade.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#i-want-to-write-a-coco-for-my-language-that-uses-the-typecheck-how","title":"I want to write a CoCo for my language that uses the TypeCheck - How?","text":"<p>You can use the TypeCheck facade. The facade needs a Derive-Class (for expressions and literals) and/or a Synthesize-Class (for types) and calculates the SymTypeExpression of your given expressions/literals/types.  Create a DelegatorVisitor which combines all expression grammars and literal grammars used by your language. The DelegatorVisitor needs to implement the Interface IDerive. Use this Delegator as Derive-Class in the TypeCheck facade. The Synthesize-Class depends on the types grammar you use (see above-mentioned classes). For an example of the Delegator-Visitor see  here.  If you want to create a Derive-Class for your expression/literal grammar, you have to extend the Derive-Class of the supergrammar and implement the standard visitor of  your language. There you can override the traverse methods for your expressions/literals so that it calculates the SymTypeExpression of the expression/literal (see implementation in one of the above-mentioned classes). You can add your visitor to the DelegatorVisitor later on. For an example of the Derive-Class for one language see here. For an example of the Synthesize-Class for one language see here  Writing a CoCo to check the correctness of your type/expression/literal should be easy now that you have the TypeCheck facade to use. Just use the correct Derive-Class and/or the correct Synthesize-Class as parameters and check if the SymTypeExpression of your expression or type is  correctly calculated.  Example for a CoCo: <pre><code>@Override\npublic void check(ASTExpression expr){\n    YourDeriveClass deriveClass = new YourDeriveClass(...); //instance of your Derive-Class\n    YourSynthesizeClass synthesizeClass = new YourSynthesizeClass(...); //instance of your Synthesize-Class\n    TypeCheck check = new TypeCheck(synthesizeClass,deriveClass); //instance of the TypeCheck-facade, parameters are your Synthesize-Class and your Derive-Class\n    if(!\"double\".equals(check.typeOf(expr).print())){ //test if your expression is of the correct type (here: double)\n        Log.error(...); //your specified error message\n    }\n}\n</code></pre></p> <p>An example for the case that a plus expression needs to return 'int' can be found here.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/","title":"TypeSystem3","text":"<p>A type system is as set of rules that assign types to terms, e.g., the type <code>int</code> can be assigned to the literal <code>2</code>.  In Monticore, the type system implementations assign SymTypeExpressions to expressions (e.g., <code>2</code>) and types (e.g., <code>int</code>). This is made possible first and foremost by traversing the AST of the expression or type, calculating the SymTypeExpressions of its subnodes, and combining their information to the SymTypeExpression currently calculated.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#given-infrastructure-in-monticore","title":"Given infrastructure in MontiCore","text":"<ul> <li>TypeCheck3   (offers <code>typeOf</code>, etc., to query the SymtypeExpressions of AST nodes.)<ul> <li>MapBasedTypeCheck3   (default implementation of TypeCheck3)<ul> <li>Type4Ast   (maps ASTNodes to SymTypeExpressions, filled by the TypeVisitors)</li> </ul> </li> </ul> </li> <li>SymTypeExpression   (calculated by the TypeVisitors, represents types and \"pseudo-types\")<ul> <li>ISymTypeVisitor   (interface for traversal of SymTypeExpressions)</li> <li>SymTypeArray   (subclass of SymTypeExpression, represents arrays,   e.g., <code>int[]</code>)</li> <li>SymTypeObscure   (subclass of SymTypeExpression, pseudo-type representing typing errors)</li> <li>SymTypeOfFunction   (subclass of SymTypeExpression, represents functions,   e.g., <code>int -&gt; void</code>)</li> <li>SymTypeOfGenerics   (subclass of SymTypeExpression,   represents (non-primitive) generic nominal data types,   e.g., <code>java.util.List&lt;Person&gt;</code>)</li> <li>SymTypeOfIntersection   (subclass of SymTypeExpression, represents intersections of types,   e.g., <code>Car &amp; Ship</code>)</li> <li>SymTypeOfNull   (subclass of SymTypeExpression, represents the null type)</li> <li>SymTypeOfObject   (subclass of SymTypeExpression,   represents non-primitive non-generic nominal data types,   e.g., <code>java.lang.String</code>)</li> <li>SymTypeOfRegEx   (subclass of SymTypeExpression, represents subsets of Strings,   e.g., <code>R\"gr(a|e)y\"</code>)</li> <li>SymTypeOfUnion   (subclass of SymTypeExpression, represents unions of types,   e.g., <code>TreeInnerNode | TreeLeaf</code>)</li> <li>SymTypePrimitive   (subclass of SymTypeExpression, represents primitive types,   e.g., <code>int</code>)</li> <li>SymTypeVariable   (subclass of SymTypeExpression, represents bound type variables,   e.g., <code>T</code> in <code>List&lt;T&gt;</code>)</li> <li>SymTypeInferenceVariable   (subclass of SymTypeExpression, represents free type variables)</li> <li>SymTypeVoid   (subclass of SymTypeExpression, pseudo-type corresponding to <code>void</code>)</li> </ul> </li> <li>SymTypeExpressionFactory   (factory for creating instances of the subclasses of SymTypeExpression) <ul> <li>MCCollectionSymTypeFactory   (factory for CollectionTypes, convenience methods)</li> </ul> </li> <li>Functionality to work with SymTypeExpressions, Expressions<ul> <li>SymTypeRelations   (relations over SymTypeExpressions, e.g., <code>isSubTypeOf</code>, <code>isCompatible</code>)<ul> <li>MCCollectionSymTypeRelations   (relations over MCCollection SymTypeExpressions, e.g., <code>isList</code>)</li> <li>FunctionRelations   (relations regarding functions, e.g, <code>canBeCalledWith</code>)</li> <li>SIUnitTypeRelations   (SIUnit relations, e.g., <code>multiply</code>, <code>isOfDimensionOne</code>)</li> </ul> </li> <li>WithinScopeBasicSymbolsResolver   (resolves contained variables, functions, ect. within a given scope;   unlike symbol resolving this returns SymTypeExpressions)<ul> <li>OOWithinScopeBasicSymbolsResolver   (resolves using OO-specific rules)</li> </ul> </li> <li>WithinTypeBasicSymbolsResolver   (resolves contained fields, methods, etc. within a given type;    unlike symbol resolving this returns SymTypeExpressions)<ul> <li>OOWithinTypeBasicSymbolsResolver   (resolves using OO-specific rules)</li> </ul> </li> <li>TypeContextCalculator   (provides context information for an expression wrt. types, e.g.,   whether a type's private members can be accessed)</li> <li>ILValueRelations   (whether an expression is an L-value, e.g., a variable)</li> </ul> </li> <li>TypeVisitors traverse the AST and   store the calculated SymTypeExpression in the Type4Ast map<ul> <li>Expressions<ul> <li>AssignmentExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar AssignmentExpressions)</li> <li>BitExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar BitExpressions)</li> <li>CommonExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar CommonExpressions)</li> <li>ExpressionsBasisTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar ExpressionBasis)</li> <li>LambdaExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar LambdaExpressions)</li> <li>OCLExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar OCLExpressions)</li> <li>OptionalOperatorsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar OptionalOperators)</li> <li>SetExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar SetExpressions)</li> <li>TupleExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar TupleExpressions)</li> <li>UglyExpressionsTypeVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar UglyExpressions)</li> </ul> </li> <li>Literals<ul> <li>MCCommonLiteralsTypeVisitor   (calculates the SymTypeExpressions for the literals   in the grammar MCCommonLiterals)</li> <li>MCJavaLiteralsTypeVisitor   (calculates the SymTypeExpressions for the literals   in the grammar MCJavaLiterals)</li> <li>SIUnitLiteralsTypeVisitor   (calculates the SymTypeExpressions for the literals   in the grammar SIUnitLiterals)</li> </ul> </li> <li>Types<ul> <li>MCArrayTypesTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCArrayTypes)</li> <li>MCBasicTypesTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCBasicTypes)</li> <li>MCCollectionTypesTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCCollectionTypes)</li> <li>MCFullGenericTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCFullGenericTypes)</li> <li>MCFunctionTypesTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCFunctionTypes)</li> <li>MCSimpleGenericTypesTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar MCArrayTypes)</li> <li>RegExTypeTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar RegExType)</li> <li>SIUnitTypes4ComputingTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar SIUnitTypes4Computing)</li> <li>SIUnitTypes4MathTypeVisitor   (calculates the SymTypeExpressions for the types   in the grammar SIUnitTypes4Math)</li> </ul> </li> </ul> </li> <li>Generics infrastructure is documented separately!</li> <li>TypeCheck1 Adapters   (adapts the TypeSystem3 to the deprecated TypeCheck1 interface,   offering implementations for IDerive and ISynthesize,   not compatible with generics,   s. TypeCheck1 documentation)</li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#what-is-the-difference-between-basicsymbols-and-symtypeexpressions","title":"What is the difference between BasicSymbols and SymTypeExpressions?","text":"<p>The type system uses the Symbols of the BasicSymbols grammar and the handwritten SymTypeExpressions. While they are very similar, there is a big difference between them and when to use them. The symbols represent definitions, including nominal data type definitions (e.g., in Java: <code>class List&lt;T&gt;</code>), while the SymTypeExpressions represent a type usage (e.g., in Java: <code>List&lt;String&gt; listOfStrings;</code> or <code>List&lt;T&gt; tempList;</code>). There is only one type definition, but there can be many type usages.  The SymTypeExpression knows its corresponding Symbol (if applicable): * SymTypeOfGenerics, SymTypeOfObject, SymTypePrimitive, and SymTypeVariable   know their corresponding TypeSymbol * SymTypeOfFunction may have a corresponding FunctionSymbol   (e.g., a named function declaration)   or not (e.g., a lambda function definition) * Other SymTypeExpressions do not have a corresponding symbol.</p> <p>A type symbol, as it defines a nominal data type, is present only once in the symbol table. A SymTypeExpression is not stored in the symbol table (except as an attribute of a symbol, s. e.g., VariableSymbol), but, as far as applicable, refers to the definitions / declarations in the symbol table. Thus, multiple identical SymTypeExpressions can be used at the same time.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#how-to-use-the-type-system-implementation","title":"How to use the type system implementation?","text":"<p>In MontiCore, the type system implementations have multiple usages. For example: * writing context conditions;   The CoCos reduce a set of models to those,   that adhere to the typing rules of the language.    An example would be a CoCo that checks   for the condition of an <code>if</code>-statement to be a Boolean expression. * printing dependent on the types;   As an example, The model contains the expression <code>f(1)</code>   with <code>f</code> being a variable of function type <code>int -&gt; int</code>   and the expression is to be printed to a Java expression.   In Java, functions are not first-class citizens.   An option is to use Java's functional interfaces   and print <code>f.apply(1)</code>.</p> <p>To these ends, MontiCore's type system implementations offer the following functionalities:</p> <ul> <li>Given an expression, the type of the expression is deduced   (e.g., given expression <code>2+2</code>, a SymTypeExpression for <code>int</code> is created)</li> <li>Given a type,   the SymTypeExpression of this type is constructed   (e.g., given MCType <code>int</code> in the model,   a corresponding SymTypeExpression is created)</li> <li>Given one or more types, a relation is checked   (e.g., whether an expression of type <code>int</code>   can be assigned to a variable of type <code>double</code>)</li> </ul> <p>In the first two cases, SymTypeExpressions are assigned to ASTNodes by the use of TypeVisitors. In the third case, the SymTypeRelations class is queried using SymTypeExpressions.  This implies how to select a specific type system implementation in the first place: To select a type system one selects a set of TypeVisitors  and an implementation of SymTypeRelations to use. This is described in detail further below.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#how-to-get-the-type-of-an-astnode","title":"How to get the type of an ASTNode?","text":"<p>Types can be calculated for ASTNodes representing either expressions (<code>2+2</code>) or types (<code>String</code>). This functionality is offered by the class TypeCheck3, which uses a static delegate pattern; This static delegate needs to be initialized; The default (and currently only) implementation is MapBasedTypeCheck3.</p> <p>First, a Type4Ast map has to be constructed to store the typing information, thus avoiding recalculation if they are queried again, e.g., by different CoCos.  After creating the map, a traverser is created with the TypeVisitors of the language components; The TypeVisitors are given the Type4Ast instance. Note: Multiple type visitors, which contain different typing rules, may be available for a given sub-grammar, the visitor to select is to be specified by the language. In the end, a MapBasedTypeCheck3 has to be created and set as the delegate of TypeCheck3.</p> <p>Example: <pre><code>// traverser of your language\n// no inheritance traverser is used, as it is recommended\n// to create a new traverser for each language.\nMyLangTraverser traverser = MyLang.traverser();\n// map to store the results\nType4Ast type4Ast = new Type4Ast();\n\n// one of many type visitors\n// check their documentation, whether further configuration is required\nBitExpressionsTypeVisitor visBitExpressions = new BitExpressionsTypeVisitor();\nvisBitExpressions.setType4Ast(type4Ast);\ntraverser.add4BitExpressions(visBitExpressions);\n\n// create the TypeCheck3 delegate\nnew MapBasedTypeCheck3(traverser, type4Ast)\n    .setThisAsDelegate();\n</code></pre> An example of instantiating a traverser can be found  here. It is recommended to initialize the TypeCheck3 directly after the Mill.</p> <p>After initializing the TypeCheck3 delegate, TypeCheck3 can be used to query SymTypeExpressions of expressions <code>TypeCheck3.typeOf(expr)</code>, as well as MCTypes <code>TypeCheck3.symTypeFromAST(mcType)</code>.</p> <p>Note: If the language supports generics, additional steps have to be taken.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#how-to-check-relations-on-types","title":"How to check relations on types?","text":"<p>To check relations of SymTypeExpressions, the SymTypeExpressions are passed to the corresponding method of SymTypeRelations or one of its subclasses. A non-exhaustive List of relation methods: * <code>boolean isCompatible(SymTypeExpression assignee, SymTypeExpression assigner)</code>   (whether an assignment is allowed in the type system) * <code>boolean isSubTypeOf(SymTypeExpression subType, SymTypeExpression)</code>   (whether one type is considered a subtype of the other) * <code>SymTypeExpression normalize(SymTypeExpression type)</code>   (converts a SymTypeExpression into normal form) * <code>boolean isInt(SymTypeExpression type)</code>   (whether the type is an <code>int</code> or boxed version thereof)</p> <p>It is strongly recommended to make oneself familiar not just with the functionality offered by the SymTypeRelations class, but also its subclasses, as they can offer further functionality like, e.g.:  <code>boolean isList(SymTypeExpression type)</code> (whether the type is considered a list).</p> <p>As different languages have different typing rules, the corresponding set of rules has to be selected. While this is partially done by selecting the TypeVisitors, relations between types are unrelated to the TypeVisitors and have to be initialized accordingly.</p> <p>As an example, the default type relations are initialized using <code>SymTypeRelations.init()</code>. The default typing relations are initialized per default and calling, e.g., <code>OCLSymTypeRelations.init()</code> of the OCL language project changes the relations according to the rules of the OCL language. According to the default, java-inspired type relations <code>List&lt;Student&gt;</code> is not a subtype of <code>List&lt;Person&gt;</code> and after initializing the OCL type relations <code>List&lt;Student&gt;</code> is calculated to be a subtype of <code>List&lt;Person&gt;</code>. Initializing the OCL type relations does not just allow usage of <code>OCLSymTypeRelations</code>,  but also changes the behavior of the methods in <code>SymTypeRelations</code>. This is done to allow reuse of CoCos between languages.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/TypeSystem3/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>TypeCheck1 Readme</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/generics/Generics/","title":"Generics","text":"<p>This is an extension of the TypeSystem3 documentation focusing on the support of generics.</p> <p>A generic type is a type which contains type parameters. For example, <code>List&lt;T&gt;</code> is a generic type with the name <code>List</code> and one type parameter <code>T</code>. A generic type cannot be used in a model directly! Instead, it needs to be instantiated by providing type arguments. <code>List&lt;int&gt;</code> is an instantiation of the generic type <code>List&lt;T&gt;</code>, and as such can be used in a model as, e.g., the type of a variable. In other words, generic types are type-level functions, that map a non-empty list of types to a new type.</p> <p>For MCTypes, the type arguments have to be provided explicitly, as with <code>List&lt;int&gt;</code>. That is not the case for expressions; <code>[]</code> is an expression that returns an empty <code>List</code>. The type argument is implicitly inferred by using information of the context the expression is used in. An Example:</p> <pre><code>List&lt;Person&gt; persons = [];\nList&lt;Car&gt; cars = [];\n</code></pre> <p>For <code>persons</code> a <code>List&lt;Person&gt;</code> is expected. <code>List&lt;Person&gt;</code> is the target type of the expression <code>[]</code>. Therefore, (in languages that have side effects) the type argument must be <code>Person</code>, thus resulting in the type <code>List&lt;Person&gt;</code> for <code>[]</code>. The same goes for <code>cars</code>; Here, the type argument is required to be <code>Car</code>. As can be seen, the same expression can have different types depending on the context the expression is used in.</p> <p>The implicit type arguments are inferred for</p> <ul> <li>checking the type-correctness of the expression</li> <li>providing additional information for potential CoCos</li> <li>providing additional information for code generators</li> </ul> <p>To this end, MontiCore provides a type inference algorithm.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/generics/Generics/#given-infrastructure-in-monticore-wrt-type-inference","title":"Given infrastructure in MontiCore wrt. Type Inference","text":"<ul> <li>TypeParameterRelations   (relations over SymTypeExpressions wrt. generics, e.g., hasWildcards)</li> <li>Constraint   (statements over SymTypeExpression that have to hold   for inference to succeed. Leads to Bounds.)<ul> <li>SubTypingConstraint   (e.g., <code>&lt;Student &lt;: Person&gt;</code>: one SymTypeExpression needs to be   the subtype of another SymTypeExpression)</li> <li>TypeEqualityConstraint   (e.g., <code>&lt;List&lt;FV#0&gt; = List&lt;Person&gt;&gt;</code>: two SymTypeExpression need to be   the same)</li> <li>TypeCompatibilityConstraint   (e.g., <code>&lt;int --&gt; FV#0&gt;</code>: one SymTypeExpression needs to be compatible   to another SymTypeExpression)</li> <li>ExpressionCompatibilityConstraint   (e.g., <code>&lt;Expression --&gt; float&gt;</code>: the SymTypeExpression of an expression   needs to be compatible to another SymTypeExpression)</li> <li>BoundWrapperConstraint   (e.g., <code>&lt;Bound: FV#0 = int&gt;</code>: a Bound in place of a Constraint)</li> </ul> </li> <li>Bound   (limits the range of inference variables, intermediate result of inference)<ul> <li>SubTypingBound   (e.g., <code>FV#0 &lt;: Person</code>: represents a variable to be   a subtype/supertype of a SymTypeExpression)</li> <li>TypeEqualityBound   (e.g., <code>FV#0 = int</code>: represents a variable being a SymTypeExpression)</li> <li>CaptureBound   (e.g., <code>List&lt;CAP#1&gt; = capture(List&lt;FV#0&gt;)</code>: represents that   capture conversion needs to be done later)</li> <li>UnsatisfiableBound   (<code>unsatisfiable</code>: represents that no instantiation can be found)</li> </ul> </li> <li>Bounds and Constraints:<ul> <li>ConstraintReduction   (takes Constraints and reduces them to Bounds)</li> <li>BoundIncorporation   (takes Bounds and finds new Constraints)</li> <li>BoundResolution   (takes Bounds and resolves instantiations)</li> </ul> </li> <li>InferenceContext4Ast   (maps ASTNodes to SymTypeExpressions, filled by the TypeVisitors)<ul> <li>InferenceContext   (stores information required for inference for one ASTNode)</li> <li>InferenceResult   (stores partial results of inference)</li> <li>InferenceVisitorMode   (the mode the type visitor is in,   this changes the expected behavior wrt. inference)</li> </ul> </li> <li>CompileTimeTypeCalculator   (handles type inference for most visitors. Requires the inference problem   to be representable as a function call.)</li> <li>CTTIVisitors are TypeVisitors extended with type inference,   they only exist for expressions<ul> <li>AssignmentExpressionsCTTIVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar AssignmentExpressions)</li> <li>CommonExpressionsCTTIVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar CommonExpressions)</li> <li>ExpressionsBasisCTTIVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar ExpressionBasis)</li> <li>SetExpressionsCTTIVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar SetExpressions)</li> <li>UglyExpressionsCTTIVisitor   (calculates the SymTypeExpressions for the expressions   in the grammar UglyExpressions)</li> </ul> </li> </ul>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/generics/Generics/#extended-symtypeexpression-world","title":"Extended SymTypeExpression World","text":"<p>When adding generics support, one can encounter new SymTypeExpressions; First of all, there is SymTypeOfGenerics, which directly corresponds to SymTypeOfObject and represents an object type with type arguments, e.g., <code>List&lt;int&gt;</code> (s. above),</p> <p>SymTypeOfFunction does not have a corresponding, e.g., SymTypeOfGenericFunction; Instead, type arguments are calculated by comparing the SymTypeOfFunction with the function defined by the FunctionSymbol. S. <code>SymtypeOfFunction::getTypeArguments()</code>.</p> <p>There are further types that can be encountered. Types printed with a <code>#</code> are types that are used internally during type calculations but cannot be explicitly used in a model. As such, a modeler may only ever encounter them in error messages.</p> <p><code>\"FV#{number}\"</code> (and <code>CAP#{number}</code>, etc.) represent inference variables (free type variables). They are used in place of the actual type arguments, until their instantiations are calculated using bounds.</p> <p><code>#TOP</code> (commonly written as \u22a4) represents the top type, the type that is the supertype of all types. It is used internally to represent that there is no upper bound that limits the set of types an inference variable can be instantiated to. Example: <code>&lt;T&gt; T f()</code> here, the type variable <code>T</code> is has no upper bound and a corresponding inference variable would use <code>#TOP</code> to represent this.</p> <p>Inference variables can be instantiated to <code>#TOP</code> in specific circumstances; The return type of <code>f</code> in the statement <code>f();</code> has no bounds, it can be any type. As such, <code>#TOP</code> is used to represent this. More often than not, a type of <code>#TOP</code> suggests that a type/function has not been used \"to their full potential\": * some information goes unused (for <code>f</code> it is the return value), or * e.g., in the comparison of an empty List and Set <code>[] == {}</code>   the potential to store values in the collections goes unused.</p> <p><code>#BOTTOM</code> (commonly written as \u22a5) represents the bottom type, the type that is the subtype of all types. Analogue to <code>#TOP</code>, <code>#BOTTOM</code> represents the lack of a more specific lower bound. <code>#BOTTOM</code> has no values. Inference variables are never instantiated to <code>#BOTTOM</code>.</p>"},{"location":"monticore-grammar/src/main/java/de/monticore/types3/generics/Generics/#how-to-get-the-type-of-an-astnode-with-generics","title":"How to get the type of an ASTNode with generics?","text":"<p>Note: This is an extension of the general documentation, which you should read first.</p> <p>When calculating types in a language with support for generics, additional steps have to be taken, due to the inference algorithm</p> <ul> <li>using different visitors (not necessarely, but that is usually the case)</li> <li>needing to store additional information for ASTNodes,</li> <li>and requiring access to the target types of expressions,</li> </ul> <p>The additional information will be stored in the InferenceContext4Ast that is shared between all visitors.</p> <p>The visitors supporting type inference, so far they exist, are usually called CTTIVisitors, for \"(extended) compile-time type inference\".</p> <p>Example: <pre><code>MyLangTraverser traverser = MyLang.traverser();\nType4Ast type4Ast = new Type4Ast();\nInferenceContext4Ast ctx4Ast = new InferenceContext4Ast();\n\n// one of many type visitors\nSetExpressionsCTTIVisitor visSetExpressions = new SetExpressionsCTTIVisitor();\nvisSetExpressions.setType4Ast(type4Ast);\nvisSetExpressions.setContext4Ast(ctx4Ast);\ntraverser.add4SetExpressions(visSetExpressions);\n// due to more complex traversal during type inference,\n// most CTTIVisitors need to control the order of traversal\ntraverser.setSetExpressionsHandler(visSetExpressions);\n\n// create the TypeCheck3 delegate\nnew MapBasedTypeCheck3(traverser, type4Ast, ctx4Ast)\n    .setThisAsDelegate();\n</code></pre></p> <p>Again, after initializing the TypeCheck3 delegate, TypeCheck3 can be used to query SymTypeExpressions of expressions <code>TypeCheck3.typeOf(expr)</code>, as well as MCTypes <code>TypeCheck3.symTypeFromAST(mcType)</code>. However, for the expressions, the target types are required, as far as they exist. To pass this information to TypeCheck3, the function <code>TypeCheck3.typeOf(expr, targetType)</code> can be used. This, in addition to calculating the type of <code>expr</code>, stores the target type information; Any subsequent call to <code>TypeCheck3.typeOf(expr)</code> will have the type according to the target type information stored by the first call. This data is stored, as there are circumstances there the target type information is not available (e.g., inside some CoCos).</p> <p>It holds that * Each ASTExpression has exactly one target type * Each ASTExpression has exactly one type.   In the case of a language with variability, special care has to be taken to     * either reset the value cache accordingly,     * or clone the ASTExpression * The call to <code>TypeCheck3.typeOf</code> with the target type has to be the first.   It is recommended to split the post-symbol-table-creation CoCos   into two groups     1. The group of CoCos that provide the target type information     2. The group of CoCos that cannot provide the information,        they must run after the CoCos of the first group</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/","title":"Symboltable","text":""},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#documentation-of-the-symbol-table-infrastructure","title":"Documentation of the Symbol Table Infrastructure","text":""},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#conceptual-model-of-symbol-tables","title":"Conceptual Model of Symbol Tables","text":"<ul> <li>What is a symbol? </li> <li>What is a symbol kind? </li> <li>What is a scope? </li> <li>What are properties of scopes? </li> <li>What is symbol resolution?</li> </ul>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#define-the-symbol-table-of-a-language-via-its-grammar","title":"Define the Symbol Table of a Language via its Grammar","text":"<ul> <li>Indicate that a nonterminal defines a symbol</li> <li>Indicate that a nonterminal spans a scope</li> <li>Indicate that a nonterminal uses the name of a symbol</li> </ul>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#runtime-environment-for-symbol-table-infrastructure","title":"Runtime Environment for Symbol Table Infrastructure","text":"<p>This section explains classes and interfaces that are part of the MontiCore runtime environment.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-table-infrastructure-interfaces","title":"Symbol Table Infrastructure Interfaces","text":"<p>Most of the interfaces of the MontiCore runtime enviroenment are super types of generated classes or interfaces that are explained here.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iscope-interface","title":"IScope Interface","text":"<p>This interface is the super type of the generated scope interfaces and thus, it is also transitive of global scope interfaces and artifact scope interfaces. <code>IScope</code> contains signatures for methods realizing the scope's connection to its environment (i.e., AST classes, sub scopes, enclosing scopes). Generated, language-specific scope interfaces refine the types of these methods. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iartifactscope-interface","title":"IArtifactScope Interface","text":"<p>The <code>IArtifactScope</code> interface is an interface that all generated language-specific artifact scope interfaces extend. It provides an abstract method for obtaining an artifact scope's package as String. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific artifact scope interfaces.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iglobalscope-interface","title":"IGlobalScope Interface","text":"<p>The <code>IGlobalScope</code> interface is an interface that all generated language-specific global scope interfaces extend. It provides an abstract method for obtaining the global scope's Modelpath. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific global scope interfaces.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#isymbol-interface","title":"ISymbol Interface","text":"<p>The <code>ISymbol</code> interface is an interface that all generated language-specific symbol classes implement. It provides the signatures for methods to obtaining the symbol's name, its package,  its fully-qualified name, and its enclosing scope, and its AST node.  Further, the interface contains the signatures of methods for getting and setting the access  modifier of the symbol and default implementations for getting the source position of the symbol. It also includes a static method for sorting a collection of symbols by their source position, which is handy for realizing the semantics of ordered scopes.  All further methods have either language-specific arguments or return types and are, thus, introduced in the specific symbol classes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#isymbolpredicate-interface","title":"ISymbolPredicate Interface","text":"<p>An <code>ISymbolPredicate</code> is a predicate of a symbol and is used for filtering the results of symbol  resolution. This is explained in more detail in [HR17]. The MontiCore runtime contains the class <code>IncludesAccessModifierSymbolPredicate</code>, which is an  implementation of a symbol predicate for filtering symbols based on their access modifier. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iscopespanningsymbol-interface","title":"IScopeSpanningSymbol Interface","text":"<p>The <code>IScopeSpanningSymbol</code> interface extends the interface <code>ISymbol</code> and adds a method signature for obtaining the scope that this symbol spans. Symbols that span a scope (which is the case, e.g.,  if the respective nonterminal in the grammar is annotated with both the keywords <code>symbol</code> and <code>scope</code>) implement this interface instead of the <code>ISymbol</code> interface.  </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#modifiers","title":"Modifiers","text":"<p>The modifiers contained in the MontiCore runtime implement the interface <code>AccessModifier</code>, which again is a <code>Modifier</code>. Out of the box, MontiCore supports the two access modifier  implementations <code>BasicAccessModifier</code> and <code>NoAccessModifier</code>. Further, more sophisticated access modifiers have to be engineered individually, dedicated to their use for a specific modeling language.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-infrastructure-for-symbol-table-serialization","title":"JSON Infrastructure for Symbol Table Serialization","text":"<p>The MontiCore runtime contains classes that are required for serializing and deserializing  symbol tables to Json-encoded Strings. The following explains these in short:</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsonprinter-class","title":"JsonPrinter Class","text":"<p>The class <code>JsonPrinter</code> wraps the concrete syntax of Json. It is an API for building Json-encoded  String via a series of method calls. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsonparser-class","title":"JsonParser Class","text":"<p>The class <code>JsonParser</code> parses a Json-encoded String into an instance of the Json  abstract syntax model. The central method of this class is the static method  <code>JsonElement parse(String s)</code>. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-parsing-infrastructure","title":"Json Parsing Infrastructure","text":"<p>Besides the <code>JsonParser</code> class, the MontiCore runtime contains more classes required for translating JSON-encoded Strings into instances of the Json abstract syntax model. The class <code>JsonLexer</code> lexes an input String into a sequence of <code>JsonToken</code> instances.  JsonToken instances realizes tokens that have a certain kind in form of a value from the  enumeration <code>JsonTokenKind</code>. The <code>NumberLexer</code> is able to lex all kinds of valid numbers encoded in Json.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-model","title":"Json Model","text":"<p>The MontiCore runtime contains a model of the abstract syntax of JSON that is used by the <code>JsonParser</code> and the <code>JsonPrinter</code> for serialization of symbol tables. Individual classes exist for the different abstract syntax types of JSON. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsondesers-class","title":"JsonDeSers Class","text":"<p>The class <code>JsonDeSers</code> contains constants and static methods that support the generated language-specific  symbol and scope DeSer classes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#generated-symbol-table-infrastructure","title":"Generated Symbol Table Infrastructure","text":"<p>MontiCore generates large parts of the symbol table infrastructure that is strongly typed for each MontiCore language. The following gives a short and technical introduction of each of these generated classes, interfaces, and enums. The concepts behind each of these infrastructure part if  explained in the MontiCore Reference Manual [HR17].</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#infrastructure-generated-per-language","title":"Infrastructure Generated per Language","text":"<p>This section explains all parts of the symbol table infrastructure that MontiCore generates once per  language. For scopes, artifact scopes, and global scopes, MontiCore separated classes and interfaces. The  interfaces follow the (multiple) inheritance of the grammars and realized most behavior in form  of default method implementations. The classes implement the interface and manage access to attributes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-interface","title":"Scope Interface","text":"<p>For each language, MontiCore generates a scope interface. The scope interface prescribes all public  methods of the scope class and realized some methods as default implementations. The hierarchy of  MontiCore grammars is also reflected in the hierarchy of scope interfaces. To realize the multiple  inheritance of MontiCore in Java, the scope interface is separated from the scope class. If a language inherits from one or more grammars, the scope interface of the language extends all scope interfaces of the inherited languages. Otherwise, if a language does not inherit from any  language, the scope interface extends the <code>IScope</code> interface from the MontiCore runtime.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-class","title":"Scope Class","text":"<p>The scope class is generated for each MontiCore language. It implements the scope interface of the  language and realizes scope attributes as well as method implementations that realize direct access  to scope attributes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-builder-class","title":"Scope Builder Class","text":"<p>MontiCore generated builder classes for each scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the scope class can be initialized and a new instance of the scope can be created. </p> <p>We highly recommend instantiating scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-interface","title":"ArtifactScope Interface","text":"<p>The artifact scope interface is generated once for each MontiCore language. It extends the scope interface of the language and the artifact scope interface of the MontiCore runtime. Artifact scopes are instantiated once for each processed artifact and, conceptually, slightly differ from scopes established within a model. To this end, their realization overrides some methods of the scope interface with a special behavior and adds new methods.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-class","title":"ArtifactScope Class","text":"<p>MontiCore generates a single artifact scope class for each language that extends the scope class of  the language and implements the artifact scope interface of the language. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-builder-class","title":"ArtifactScope Builder Class","text":"<p>MontiCore generated builder classes for each artifact scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the artifact scope class can be initialized and a new instance of the artifact scope can be created. </p> <p>We highly recommend instantiating artifact scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-interface","title":"GlobalScope Interface","text":"<p>Similar to artifact scope interfaces, global scope interfaces extends the scope interface of the language. Additionally, they implement the global scope interfaces of their parent languages or the  <code>IGlobalScope</code> of the MontiCore runtime if the languages do not inherit from another language.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-class","title":"GlobalScope Class","text":"<p>The global scope class is generated for each MontiCore language and realizes the concrete global scope of a language. It extends the scope class and implements the global scope iterface of the  language.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-builder-class","title":"GlobalScope Builder Class","text":"<p>MontiCore generated builder classes for each global scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the global scope class can be initialized and a new instance of the global scope can be created. </p> <p>We highly recommend instantiating global scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scopegenitor-class","title":"ScopeGenitor Class","text":"<p>The scope genitor creates the skeleton of the scope tree for the model and instantiates all its symbols. Additionally, it connects the scope and symbol objects with their AST nodes. The scope genitor does not initialize any additional attributes of the scope and symbol objects it created. These attributes have to be initialized manually.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scopegenitordelegator-class","title":"ScopeGenitorDelegator Class","text":"<p>For instantiating symbol tables in the context of language composition, MontiCore generates a ScopesGenitorDelegator class for each language. This class instantiates a traverser of a language and adds scope genitors of the current language and all inherited languages. It further provides a createFromAST method that delegates to the respective method from the scopes genitor. The scopes genitor delegator is instantiated through the method scopesGenitorDelegator() of a language's mill.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#common-symbol-interface","title":"Common Symbol Interface","text":"<p>The common symbol interface of a language extends the MontiCore runtime class <code>ISymbol</code> and provides methods for the connection to the enclosing scope and the visitor of the language. As these are specifically typed for each language, the common symbol interface is generated. All symbol classes of a language implement the common symbol interface. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symboltableprinter","title":"SymbolTablePrinter","text":"<p>The symbol table printer traverses the scope tree of an artifact using a visitor and serializes it  in form of a JSON-encoded String. Traversal typically begins with an artifact scope. In each scope,  the local symbols are visited and serialized. If a symbol spans a scope, the spanned scope is visited while visiting the symbol. It, therefore, realizes traversal of the scope tree along the  enclosingScope &lt;-&gt; localSymbols and the symbol &lt;-&gt; spannedScope associations. Symbol table printers are used by ScopeDeSers and SymbolDeSers. For language composition, the symbol table printers of individual languages are combined with a delegator visitor in the DeSer classes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scopedeser","title":"ScopeDeSer","text":"<p>The scope deser class provides methods realizing the loading and storing of scope objects of a language. Besides this, it realizes the deserialization of scopes. The deserialization of symbols within this scope is delegated to the respective symbol DeSers and serialization of symbols and scopes is  delegated to the symbol table printer. The reason for this separation is that employing a visitor is  suitable for serialization, but not for deserialization. The latter would visit elements of the  abstract syntax of JSON, such as a Json object, and would require a large number of case distinctions within handling different objects that can be serialized as a Json object. Combining the visitor-based serialization and the deserialization into a single class would be inefficient in terms of compilation time.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#generated-per-symbol","title":"Generated per Symbol","text":"<p>This section explains parts of the symbol table infrastructure that MontiCore generates once for  each symbol of a language.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-class","title":"Symbol Class","text":"<p>For each symbol of the language, MontiCore generates a symbol class that implements the common  symbol interface of the language. The symbol class realizes symbols of a certain kind. For example, the class <code>StateSymbol</code> realizes the kind StateSymbol and objects of this class are concrete symbols. A symbol kind can inherit from at most one other symbol kind. This is reflected in the symbol classes by extending the class of the super kind. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-builder-class","title":"Symbol Builder Class","text":"<p>MontiCore generated builder classes for each symbol. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol class can be initialized and a new instance of the symbol can be created. </p> <p>We highly recommend instantiating symbol classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages, e.g., in case the symbol production is overridden in the grammar.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-deser","title":"Symbol DeSer","text":"<p>The symbol DeSer classes are generated for each symbol and realize serialization and deserialization of symbols of a certain kind. The serialization is visitor-based and, thus, delegated to the symbol table printer. Symbol DeSers are used by scope DeSers to realize the deserialization of symbols and as such, are reused for all languages that inherit from the current language. As serialization and  deserialization of individual symbols is rarely triggered manually, no load and store methods exist in symbol DeSer classes.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-surrogate-class","title":"Symbol Surrogate Class","text":"<p>Symbol surrogate classes extend the generated symbol classes and realize lazy loading of symbls of this kind. Surrogates have a delegate of the symbol class that is empty during initialization of the surrogate., where only the enclosing scope and the name are set. They further define a method for resolving the symbol with the on demand. Symbol surrogates must only be if both of the following two conditions are met: 1. If on type level, a symbol has an attribute of another symbol, the attribute may be initialized with the surrogate as the symbol's subtype. 2. If on instance level, the symbol definition of the  Surrogates must never be used to simplify instantiation of local symbols, i.e., of symbols that are contained in a single model for which the symbol table currently is build. In this case, it is always possible to split symbol table creation into multiple phases: In the first phase, all symbol definitions  instantiate symbol class objects, for which the symbol attributes are not instantiated yet. In a later phase, the symbol attributes are filled with values.</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-surrogate-builder","title":"Symbol Surrogate Builder","text":"<p>MontiCore generated builder classes for each symbol surrogate. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol surrogate class can be initialized and a new instance of the symbol surrogate can be created. </p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#resolvers","title":"Resolvers","text":"<p>MontiCore generates a resolver interface for each symbol kind of a language. Resolvers have a method for resolving adapted symbol kinds. Language engineers can develop concrete resolving delegates that implement a resolver interface. Such classes can be added to the global scope of a language to integrate resolving for adapted symbols into the resolution process.  For example, an automata language defines the generated resolver interface <code>IStateSymbolResolver</code>. This interface can be used by language engineers to implement a <code>CDClass2StateResolver</code> class  implementing the interface that resolves, for example, for symbols of a CD class whenever resolving for state symbols is invoked. The result of this is typically an adapter symbol, which adapts the foreign symbol (e.g., CDClassSymbol) to the expected symbol (e.g., StateSymbol).</p>"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"}]}